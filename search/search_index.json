{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyNodeWidget","text":"<p>Build interactive node-based UIs in Jupyter notebooks without writing JavaScript.</p> <p>PyNodeWidget is a Python wrapper for ReactFlow using AnyWidget that enables you to create rich, interactive node-based graph UIs entirely from Python. Perfect for building data processing pipelines, machine learning workflows, and visual programming interfaces.</p>"},{"location":"#key-features","title":"Key Features","text":"<p> Pure Python API :   Define nodes, layouts, and behaviors entirely in Python using Pydantic models. No JavaScript required.</p> <p> Bidirectional Sync :   Changes in the UI automatically sync back to Python. Update values from Python and see them reflected in the UI instantly.</p> <p> Extensible Architecture :   Protocol-based design with registries for custom fields, layouts, and handle types. Build plugins to extend functionality.</p> <p> Rich UI Components :   Multiple layout options, handle types, and field renderers. Style nodes with Tailwind classes and custom configurations.</p> <p> Import/Export :   Save and load complete workflows as JSON. Share configurations and reproduce results easily.</p> <p> Auto-Layout :   Built-in Dagre-based automatic graph layout. Organize complex workflows with a single click.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget, NodeFlowWidget\n\n# Define node parameters with Pydantic\nclass ProcessorParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0, le=1, description=\"Processing threshold\")\n    mode: str = Field(default=\"auto\", description=\"Processing mode\")\n\n# Create a custom node class\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Data Processor\"\n    parameters = ProcessorParams\n    icon = \"\u2699\ufe0f\"\n    category = \"processing\"\n    inputs = [{\"id\": \"data_in\", \"label\": \"Data\"}]\n    outputs = [{\"id\": \"data_out\", \"label\": \"Processed\"}]\n\n    def execute(self, inputs):\n        \"\"\"Process data using configured parameters.\"\"\"\n        config = self.get_values()\n        data = inputs.get(\"data_in\")\n        # Your processing logic here\n        return {\"data_out\": processed_data}\n\n# Create widget and register node\nflow = NodeFlowWidget(nodes=[ProcessorNode], height=\"800px\")\n\n# Display in Jupyter\nflow\n</code></pre> <p>The node appears in the sidebar and can be dragged onto the canvas. All parameter editing happens through a generated form, with values syncing automatically between Python and JavaScript.</p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#data-processing-pipelines","title":"Data Processing Pipelines","text":"<p>Create visual workflows for ETL, data transformation, and analysis tasks. Connect data sources, filters, and outputs in an intuitive graph.</p>"},{"location":"#machine-learning-workflows","title":"Machine Learning Workflows","text":"<p>Build ML pipelines with nodes for data loading, preprocessing, training, evaluation, and prediction. Visualize model architectures and data flow.</p>"},{"location":"#visual-programming","title":"Visual Programming","text":"<p>Develop visual programming interfaces where users can create logic by connecting nodes. Perfect for low-code/no-code applications.</p>"},{"location":"#configuration-uis","title":"Configuration UIs","text":"<p>Generate rich configuration interfaces from Pydantic models. Use conditional fields, validation, and custom widgets for complex settings.</p>"},{"location":"#technology-stack","title":"Technology Stack","text":"<p>Python Backend:</p> <ul> <li>AnyWidget: Jupyter widget communication</li> <li>Pydantic: Type-safe configuration schemas</li> <li>Traitlets: Observable attributes</li> </ul> <p>JavaScript Frontend:</p> <ul> <li>React 18: Component framework</li> <li>ReactFlow 12: Node graph library</li> <li>TypeScript: Type safety</li> <li>Tailwind CSS: Styling</li> <li>Zustand: State management</li> <li>Dagre: Auto-layout algorithm</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph Python\n        A[Pydantic Model] --&gt; B[JsonSchemaNodeWidget]\n        B --&gt; C[NodeFlowWidget]\n        C --&gt; D[AnyWidget Comm]\n    end\n\n    subgraph JavaScript\n        D --&gt; E[React Component]\n        E --&gt; F[ReactFlow Canvas]\n        F --&gt; G[JsonSchemaNode]\n        G --&gt; H[Field Renderers]\n    end\n\n    subgraph Extensibility\n        I[Field Registry] --&gt; H\n        J[Layout Registry] --&gt; G\n        K[Handle Registry] --&gt; G\n    end\n\n    style Python fill:#e3f2fd\n    style JavaScript fill:#f3e5f5\n    style Extensibility fill:#fff3e0</code></pre>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li> <p> Get Started</p> <p>Install PyNodeWidget and create your first node-based workflow in minutes.</p> </li> <li> <p> User Guide</p> <p>Learn how to create custom nodes, fields, and layouts for your specific use case.</p> </li> <li> <p> API Reference</p> <p>Comprehensive documentation of Python and JavaScript APIs.</p> </li> <li> <p> Examples</p> <p>Explore complete examples covering common patterns and advanced use cases.</p> </li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>GitHub: Report issues and contribute</li> <li>Examples: Check the <code>examples/</code> folder in the repository</li> <li>API Docs: Browse the full API reference</li> </ul>"},{"location":"#license","title":"License","text":"<p>PyNodeWidget is open source software. Check the repository for license details.</p>"},{"location":"ROADMAP/","title":"Roadmap","text":"<p>Development priorities and planned features for PyNodeWidget.</p>"},{"location":"ROADMAP/#current-status","title":"Current Status","text":"<p>Version: 0.1.x (Alpha) Focus: Core functionality, API stabilization, documentation</p> <p>Widget are able to render nodes with two way interaction </p>"},{"location":"ROADMAP/#next-steps","title":"Next Steps","text":"<ul> <li>[ ] Test Coverage - Pytest for Python, Vitest for JavaScript</li> <li>[ ] Code Style Enforcement - Ruff (Python), Prettier/ESLint (JavaScript)</li> <li>[ ] CI/CD Pipeline - Automated testing, builds, releases</li> <li> <p>[ ] Type Safety - Complete type hints in Python, strict TypeScript</p> </li> <li> <p>[ ] Define Python API</p> </li> <li>[ ] Define the use cases of this library</li> </ul>"},{"location":"ROADMAP/#documentation","title":"Documentation","text":"<ul> <li>[ ] Contributing guides (testing, code style)</li> <li>[ ] Revise documentation</li> <li>[ ] generate html from marimo notebooks to show the interactity of the library</li> </ul>"},{"location":"ROADMAP/#use-cases","title":"Use Cases","text":"<p>PyNodeWidget supports two primary use cases:</p>"},{"location":"ROADMAP/#1-visualization-display-workflowsgraphs","title":"1. Visualization - Display Workflows/Graphs","text":"<p>Show existing workflows, data pipelines, or computational graphs in Jupyter notebooks.</p> <p>Examples: - Visualize ML pipelines (data \u2192 preprocessing \u2192 model \u2192 output) - Display computation graphs (DAGs, neural networks) - Show system architectures and data flows - Document process workflows</p>"},{"location":"ROADMAP/#2-interactive-editing-build-workflowsgraphs","title":"2. Interactive Editing - Build Workflows/Graphs","text":"<p>Create and modify workflows interactively with drag-and-drop and forms.</p> <p>Examples: - Build data processing pipelines interactively - Design computational workflows - Prototype system architectures - Experiment with graph structures</p>"},{"location":"ROADMAP/#planned-features","title":"Planned Features","text":""},{"location":"ROADMAP/#visualization-use-case","title":"Visualization Use Case","text":""},{"location":"ROADMAP/#interactive-editing-use-case","title":"Interactive Editing Use Case","text":""},{"location":"ROADMAP/#technical-debt","title":"Technical Debt","text":""},{"location":"ROADMAP/#future-exploration","title":"Future Exploration","text":"<p>Ideas that may align with future use cases:</p>"},{"location":"api/python/","title":"Python API Overview","text":"<p>PyNodeWidget's Python API consists of several key modules that work together to create interactive node-based UIs in Jupyter notebooks.</p>"},{"location":"api/python/#core-components","title":"Core Components","text":""},{"location":"api/python/#nodeflowwidget","title":"NodeFlowWidget","text":"<p>The main widget for creating and managing node-based workflows. This is your entry point for creating interactive node graphs in Jupyter.</p> <pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget(nodes=[MyNode], height=\"800px\")\nflow\n</code></pre> <p>Key Features:</p> <ul> <li>Register and manage node types</li> <li>Access and modify node values</li> <li>Import/export workflows as JSON</li> <li>Bidirectional synchronization with UI</li> </ul>"},{"location":"api/python/#jsonschemanodewidget","title":"JsonSchemaNodeWidget","text":"<p>Base class for creating custom node types. Implements the NodeFactory protocol and provides a convenient way to define nodes using Pydantic models.</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass MyNode(JsonSchemaNodeWidget):\n    label = \"My Node\"\n    parameters = MyParamsModel\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n</code></pre> <p>Key Features:</p> <ul> <li>Pydantic-based parameter definition</li> <li>Automatic UI generation</li> <li>Validation and type safety</li> <li>Optional execute() method for processing logic</li> </ul>"},{"location":"api/python/#observabledict","title":"ObservableDict","text":"<p>Auto-syncing dictionary that triggers callbacks on mutations. Used internally for efficient Python-JavaScript synchronization.</p> <pre><code>from pynodewidget import ObservableDict\n\ndata = ObservableDict(callback=lambda: print(\"changed\"))\ndata[\"key\"] = \"value\"  # Triggers callback\n</code></pre>"},{"location":"api/python/#protocols","title":"Protocols","text":"<p>Protocol definitions for extending PyNodeWidget with custom node factories.</p> <pre><code>from pynodeflow.protocols import NodeFactory, NodeMetadata\n</code></pre>"},{"location":"api/python/#quick-reference","title":"Quick Reference","text":""},{"location":"api/python/#creating-a-widget","title":"Creating a Widget","text":"<pre><code>from pynodewidget import NodeFlowWidget, JsonSchemaNodeWidget\nfrom pydantic import BaseModel, Field\n\n# Define parameters\nclass ProcessorParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0, le=1)\n\n# Define node class\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    icon = \"\u2699\ufe0f\"\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n\n# Create widget\nflow = NodeFlowWidget(nodes=[ProcessorNode])\nflow\n</code></pre>"},{"location":"api/python/#accessing-node-values","title":"Accessing Node Values","text":"<pre><code># Get all values for a node\nvalues = flow.get_node_values(\"node-1\")\n\n# Update a single value\nflow.update_node_value(\"node-1\", \"threshold\", 0.8)\n\n# Get a specific value\nthreshold = flow.get_node_value(\"node-1\", \"threshold\", default=0.5)\n\n# Set multiple values\nflow.set_node_values(\"node-1\", {\"threshold\": 0.8, \"enabled\": True})\n</code></pre>"},{"location":"api/python/#registering-node-types","title":"Registering Node Types","text":"<pre><code># Register during initialization\nflow = NodeFlowWidget(nodes=[Node1, Node2, Node3])\n\n# Register after initialization\nflow.register_node_type(Node4)\nflow.register_node_type(Node5, type_name=\"custom_name\")\n</code></pre>"},{"location":"api/python/#importexport","title":"Import/Export","text":"<pre><code># Export workflow to file\nflow.export_json(\"my_workflow.json\")\n\n# Load workflow from file\nflow.load_json(\"my_workflow.json\")\n\n# Export as dict\nworkflow_data = flow.get_flow_data()\n\n# Access nodes and edges\nnodes = flow.nodes\nedges = flow.edges\n</code></pre>"},{"location":"api/python/#type-system","title":"Type System","text":"<p>PyNodeWidget uses Pydantic for type-safe parameter definitions:</p> <pre><code>from pydantic import BaseModel, Field\nfrom typing import Literal\n\nclass NodeParams(BaseModel):\n    # String with validation\n    name: str = Field(min_length=1, max_length=50)\n\n    # Number with range\n    threshold: float = Field(ge=0, le=1)\n\n    # Integer\n    count: int = Field(default=10, ge=1)\n\n    # Boolean\n    enabled: bool = True\n\n    # Enum (becomes dropdown)\n    mode: Literal[\"auto\", \"manual\", \"advanced\"] = \"auto\"\n\n    # Optional field\n    description: str | None = None\n</code></pre> <p>These automatically generate appropriate UI inputs:</p> <ul> <li><code>str</code> \u2192 Text input</li> <li><code>int</code>, <code>float</code> \u2192 Number input</li> <li><code>bool</code> \u2192 Checkbox</li> <li><code>Literal</code> / Enum \u2192 Dropdown</li> <li>Optional \u2192 Nullable field</li> </ul>"},{"location":"api/python/#advanced-features","title":"Advanced Features","text":""},{"location":"api/python/#conditional-fields","title":"Conditional Fields","text":"<p>Show/hide fields based on other field values:</p> <pre><code>fieldConfigs = {\n    \"threshold\": {\n        \"showWhen\": {\n            \"field\": \"mode\",\n            \"operator\": \"equals\",\n            \"value\": \"advanced\"\n        }\n    }\n}\n\nnode = JsonSchemaNodeWidget.from_pydantic(\n    MyParams,\n    label=\"Advanced\",\n    fieldConfigs=fieldConfigs\n)\n</code></pre>"},{"location":"api/python/#custom-styling","title":"Custom Styling","text":"<pre><code>config = {\n    \"header\": {\n        \"show\": True,\n        \"icon\": \"\u2728\",\n        \"className\": \"bg-gradient-to-r from-blue-500 to-purple-500 text-white\"\n    },\n    \"style\": {\n        \"minWidth\": \"300px\",\n        \"shadow\": \"lg\",\n        \"borderRadius\": \"12px\"\n    }\n}\n\nnode = JsonSchemaNodeWidget.from_pydantic(MyParams, **config)\n</code></pre>"},{"location":"api/python/#node-execution","title":"Node Execution","text":"<p>Implement custom processing logic:</p> <pre><code>class ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n\n    def execute(self, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Execute node logic.\"\"\"\n        # Get configuration\n        config = self.get_values()\n        threshold = config[\"threshold\"]\n\n        # Get input data\n        data = inputs.get(\"data_in\")\n\n        # Process\n        filtered = [x for x in data if x &gt;= threshold]\n\n        # Return outputs\n        return {\"data_out\": filtered}\n</code></pre>"},{"location":"api/python/#next-steps","title":"Next Steps","text":"<ul> <li>NodeFlowWidget Reference: Complete widget API</li> <li>JsonSchemaNodeWidget Reference: Node creation API</li> <li>User Guides: Practical tutorials</li> </ul>"},{"location":"api/python/json-schema-node/","title":"NodeBuilder","text":"<p>Base class for creating custom node types using Pydantic models.</p>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder","title":"<code>NodeBuilder(id=None, data=None, selected=None, **initial_values)</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>Base class for custom node widgets implementing the NodeFactory protocol.</p> <p>This class can be used in two ways: 1. As a standalone widget for configuration UI 2. As a base class for custom node types registered with NodeFlowWidget</p> <p>To create a custom node, inherit from this class and define: - parameters: A Pydantic BaseModel class defining configuration fields - label: Display name for the node - Optional: icon, category, description, inputs, outputs</p> Example <p>from pydantic import BaseModel, Field</p> <p>class ProcessingConfig(BaseModel): ...     threshold: float = Field(default=0.5, ge=0, le=1) ...     mode: str = \"auto\"</p> <p>class ProcessingNode(NodeBuilder): ...     parameters = ProcessingConfig ...     label = \"Image Processor\" ...     icon = \"\ud83d\uddbc\ufe0f\" ...     category = \"processing\" ...     inputs = [{\"id\": \"input\", \"label\": \"Image\"}] ...     outputs = [{\"id\": \"output\", \"label\": \"Processed\"}]</p> <p>Initialize the node builder.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>Widget ID (default: \"json-schema-node\")</p> <code>None</code> <code>data</code> <p>Initial data dict (for standalone widget mode)</p> <code>None</code> <code>selected</code> <p>Selection state</p> <code>None</code> <code>**initial_values</code> <p>Initial parameter values (passed to Pydantic model)</p> <code>{}</code> Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>def __init__(self, id=None, data=None, selected=None, **initial_values):\n    \"\"\"Initialize the node builder.\n\n    Args:\n        id: Widget ID (default: \"json-schema-node\")\n        data: Initial data dict (for standalone widget mode)\n        selected: Selection state\n        **initial_values: Initial parameter values (passed to Pydantic model)\n    \"\"\"\n    super().__init__()\n\n    # Initialize Pydantic model instance for parameters\n    if self.__class__.parameters is not None:\n        try:\n            self._config = self.__class__.parameters(**initial_values)\n        except Exception as e:\n            # If initialization fails, create with defaults\n            self._config = self.__class__.parameters()\n    else:\n        self._config = None\n\n    # Set widget properties\n    if id is not None:\n        self.id = id\n\n    # Handle two modes: standalone widget vs. node definition\n    if data is not None:\n        # Standalone widget mode: use provided data dict\n        self.data = data\n    elif self.__class__.parameters is not None:\n        # Node definition mode: generate data from class attributes\n        self.data = self._generate_data_dict()\n\n    if selected is not None:\n        self.selected = selected\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.get_values","title":"<code>get_values()</code>","text":"<p>Get current configuration values.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing all current parameter values</p> Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>def get_values(self) -&gt; Dict[str, Any]:\n    \"\"\"Get current configuration values.\n\n    Returns:\n        Dictionary containing all current parameter values\n    \"\"\"\n    if self._config is not None:\n        return self._config.model_dump()\n\n    # Fallback for standalone widget mode\n    return self.data.get(\"values\", {})\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.set_values","title":"<code>set_values(values)</code>","text":"<p>Update configuration values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict[str, Any]</code> <p>Dictionary of parameter values to update</p> required Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>def set_values(self, values: Dict[str, Any]) -&gt; None:\n    \"\"\"Update configuration values.\n\n    Args:\n        values: Dictionary of parameter values to update\n    \"\"\"\n    if self._config is not None:\n        # Update Pydantic model with new values\n        current_values = self._config.model_dump()\n        current_values.update(values)\n        self._config = self.__class__.parameters(**current_values)\n\n        # Update widget data\n        if \"values\" in self.data:\n            self.data = {**self.data, \"values\": self._config.model_dump()}\n    else:\n        # Fallback for standalone widget mode\n        if \"values\" in self.data:\n            self.data = {**self.data, \"values\": {**self.data[\"values\"], **values}}\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.set_value","title":"<code>set_value(key, value)</code>","text":"<p>Update a single configuration value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Parameter name</p> required <code>value</code> <code>Any</code> <p>New value</p> required Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>def set_value(self, key: str, value: Any) -&gt; None:\n    \"\"\"Update a single configuration value.\n\n    Args:\n        key: Parameter name\n        value: New value\n    \"\"\"\n    self.set_values({key: value})\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.validate","title":"<code>validate()</code>","text":"<p>Validate current configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration is valid, False otherwise</p> Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"Validate current configuration.\n\n    Returns:\n        True if configuration is valid, False otherwise\n    \"\"\"\n    if self._config is None:\n        return True\n\n    try:\n        # Pydantic validation happens automatically on assignment\n        # If we can recreate the model with current values, it's valid\n        self.__class__.parameters(**self._config.model_dump())\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.execute","title":"<code>execute(inputs)</code>","text":"<p>Execute node logic (to be overridden in subclasses).</p> <p>This is a placeholder for future execution engine support. Subclasses can override this to implement custom node logic.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Dict[str, Any]</code> <p>Dictionary of input values from connected nodes</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of output values</p> Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>def execute(self, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute node logic (to be overridden in subclasses).\n\n    This is a placeholder for future execution engine support.\n    Subclasses can override this to implement custom node logic.\n\n    Args:\n        inputs: Dictionary of input values from connected nodes\n\n    Returns:\n        Dictionary of output values\n    \"\"\"\n    raise NotImplementedError(\n        f\"{self.__class__.__name__} does not implement execute(). \"\n        \"Override this method to add execution logic.\"\n    )\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.from_pydantic","title":"<code>from_pydantic(model_class, label=None, icon='', category='general', description='', grid_layout=None, initial_values=None, header=None, footer=None, style=None, validation=None, fieldConfigs=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a node from a Pydantic model (factory method for convenience).</p> <p>This is a convenience method for creating a node widget without defining a full subclass. For better code organization, prefer creating a proper subclass instead.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>Type[BaseModel]</code> <p>Pydantic BaseModel class</p> required <code>label</code> <code>Optional[str]</code> <p>Display name</p> <code>None</code> <code>icon</code> <code>str</code> <p>Unicode emoji or icon</p> <code>''</code> <code>category</code> <code>str</code> <p>Node category</p> <code>'general'</code> <code>description</code> <code>str</code> <p>Help text</p> <code>''</code> <code>grid_layout</code> <code>Optional[Dict[str, Any]]</code> <p>Grid layout configuration dict</p> <code>None</code> <code>initial_values</code> <code>Optional[Dict[str, Any]]</code> <p>Initial parameter values</p> <code>None</code> <code>header</code> <code>Optional[Dict[str, Any]]</code> <p>Header configuration dict</p> <code>None</code> <code>footer</code> <code>Optional[Dict[str, Any]]</code> <p>Footer configuration dict</p> <code>None</code> <code>style</code> <code>Optional[Dict[str, Any]]</code> <p>Style configuration dict</p> <code>None</code> <code>validation</code> <code>Optional[Dict[str, Any]]</code> <p>Validation configuration dict</p> <code>None</code> <code>fieldConfigs</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>Per-field configuration dict</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional configuration options</p> <code>{}</code> <p>Returns:</p> Type Description <code>NodeBuilder</code> <p>New JsonSchemaNodeWidget instance</p> Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>@classmethod\ndef from_pydantic(\n    cls,\n    model_class: Type[BaseModel],\n    label: Optional[str] = None,\n    icon: str = \"\",\n    category: str = \"general\",\n    description: str = \"\",\n    grid_layout: Optional[Dict[str, Any]] = None,\n    initial_values: Optional[Dict[str, Any]] = None,\n    # Enhanced configuration options\n    header: Optional[Dict[str, Any]] = None,\n    footer: Optional[Dict[str, Any]] = None,\n    style: Optional[Dict[str, Any]] = None,\n    validation: Optional[Dict[str, Any]] = None,\n    fieldConfigs: Optional[Dict[str, Dict[str, Any]]] = None,\n    **kwargs: Any,  # Catch any additional config options\n) -&gt; \"NodeBuilder\":\n    \"\"\"Create a node from a Pydantic model (factory method for convenience).\n\n    This is a convenience method for creating a node widget without\n    defining a full subclass. For better code organization, prefer\n    creating a proper subclass instead.\n\n    Args:\n        model_class: Pydantic BaseModel class\n        label: Display name\n        icon: Unicode emoji or icon\n        category: Node category\n        description: Help text\n        grid_layout: Grid layout configuration dict\n        initial_values: Initial parameter values\n        header: Header configuration dict\n        footer: Footer configuration dict\n        style: Style configuration dict\n        validation: Validation configuration dict\n        fieldConfigs: Per-field configuration dict\n        **kwargs: Additional configuration options\n\n    Returns:\n        New JsonSchemaNodeWidget instance\n    \"\"\"\n    # Create anonymous subclass\n    class AnonymousNode(cls):\n        pass\n\n    # Set class attributes\n    AnonymousNode.parameters = model_class\n    AnonymousNode.label = label or model_class.__name__\n    AnonymousNode.icon = icon\n    AnonymousNode.category = category\n    AnonymousNode.description = description\n    AnonymousNode.grid_layout = grid_layout\n\n    # Create instance with initial values\n    instance = AnonymousNode(**(initial_values or {}))\n\n    # Apply enhanced configuration to the data dict\n    data = instance.data.copy()\n\n    if header:\n        data[\"header\"] = header\n    if footer:\n        data[\"footer\"] = footer\n    if style:\n        data[\"style\"] = style\n    if validation:\n        data[\"validation\"] = validation\n    if fieldConfigs:\n        data[\"fieldConfigs\"] = fieldConfigs\n\n    # Apply any additional kwargs to data\n    for key, value in kwargs.items():\n        if value is not None:\n            data[key] = value\n\n    instance.data = data\n    return instance\n</code></pre>"},{"location":"api/python/json-schema-node/#pynodewidget.json_schema_node.NodeBuilder.from_schema","title":"<code>from_schema(schema, label, icon='', category='general', description='', grid_layout=None, initial_values=None)</code>  <code>classmethod</code>","text":"<p>Create a node from a JSON schema (legacy support for rapid prototyping).</p> <p>This method provides backward compatibility for code using raw JSON schemas. For new code, use Pydantic models with the parameters attribute instead.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dict[str, Any]</code> <p>JSON Schema definition</p> required <code>label</code> <code>str</code> <p>Display name</p> required <code>icon</code> <code>str</code> <p>Unicode emoji or icon</p> <code>''</code> <code>category</code> <code>str</code> <p>Node category</p> <code>'general'</code> <code>description</code> <code>str</code> <p>Help text</p> <code>''</code> <code>grid_layout</code> <code>Optional[Dict[str, Any]]</code> <p>Grid layout configuration dict</p> <code>None</code> <code>initial_values</code> <code>Optional[Dict[str, Any]]</code> <p>Initial parameter values</p> <code>None</code> <p>Returns:</p> Type Description <code>NodeBuilder</code> <p>New JsonSchemaNodeWidget instance</p> Source code in <code>pynodewidget/json_schema_node.py</code> <pre><code>@classmethod\ndef from_schema(\n    cls,\n    schema: Dict[str, Any],\n    label: str,\n    icon: str = \"\",\n    category: str = \"general\",\n    description: str = \"\",\n    grid_layout: Optional[Dict[str, Any]] = None,\n    initial_values: Optional[Dict[str, Any]] = None,\n) -&gt; \"NodeBuilder\":\n    \"\"\"Create a node from a JSON schema (legacy support for rapid prototyping).\n\n    This method provides backward compatibility for code using raw JSON schemas.\n    For new code, use Pydantic models with the parameters attribute instead.\n\n    Args:\n        schema: JSON Schema definition\n        label: Display name\n        icon: Unicode emoji or icon\n        category: Node category\n        description: Help text\n        grid_layout: Grid layout configuration dict\n        initial_values: Initial parameter values\n\n    Returns:\n        New JsonSchemaNodeWidget instance\n    \"\"\"\n    # Extract default values from schema\n    default_values = {}\n    if schema and \"properties\" in schema:\n        for key, prop in schema[\"properties\"].items():\n            if \"default\" in prop:\n                default_values[key] = prop[\"default\"]\n\n    # Merge with initial values\n    if initial_values:\n        default_values.update(initial_values)\n\n    # Create standalone widget with data dict\n    data = {\n        \"label\": label,\n        \"grid\": {\"cells\": [], \"rows\": [\"1fr\"], \"columns\": [\"1fr\"], \"gap\": \"8px\"},\n        \"values\": default_values,\n    }\n\n    widget = cls()\n    widget.data = data\n    return widget\n</code></pre>"},{"location":"api/python/json-schema-node/#overview","title":"Overview","text":"<p><code>JsonSchemaNodeWidget</code> implements the NodeFactory protocol and provides a convenient base class for defining custom nodes. It automatically generates UI from Pydantic models and handles value synchronization.</p>"},{"location":"api/python/json-schema-node/#basic-usage","title":"Basic Usage","text":""},{"location":"api/python/json-schema-node/#creating-a-node-class","title":"Creating a Node Class","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget\n\n# 1. Define parameters with Pydantic\nclass ProcessorParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0, le=1)\n    mode: str = \"auto\"\n    enabled: bool = True\n\n# 2. Create node class\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    icon = \"\u2699\ufe0f\"\n    category = \"processing\"\n    description = \"Process data with threshold\"\n\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n\n    layout_type = \"horizontal\"\n    handle_type = \"button\"\n</code></pre>"},{"location":"api/python/json-schema-node/#required-attributes","title":"Required Attributes","text":"<ul> <li><code>label</code>: Display name (string)</li> <li><code>parameters</code>: Pydantic BaseModel class</li> </ul>"},{"location":"api/python/json-schema-node/#optional-attributes","title":"Optional Attributes","text":"<ul> <li><code>icon</code>: Emoji or Unicode symbol (default: \"\")</li> <li><code>category</code>: Grouping category (default: \"general\")</li> <li><code>description</code>: Help text (default: \"\")</li> <li><code>inputs</code>: List of input handle configs (default: [])</li> <li><code>outputs</code>: List of output handle configs (default: [])</li> <li><code>layout_type</code>: Layout style - \"horizontal\", \"vertical\", \"compact\" (default: \"horizontal\")</li> <li><code>handle_type</code>: Handle type - \"base\", \"button\", \"labeled\" (default: \"base\")</li> </ul>"},{"location":"api/python/json-schema-node/#handle-configuration","title":"Handle Configuration","text":""},{"location":"api/python/json-schema-node/#input-and-output-handles","title":"Input and Output Handles","text":"<pre><code>class MyNode(JsonSchemaNodeWidget):\n    label = \"My Node\"\n    parameters = MyParams\n\n    inputs = [\n        {\"id\": \"data_in\", \"label\": \"Data\"},\n        {\"id\": \"config_in\", \"label\": \"Config\"}\n    ]\n\n    outputs = [\n        {\"id\": \"result\", \"label\": \"Result\"},\n        {\"id\": \"metadata\", \"label\": \"Metadata\"}\n    ]\n</code></pre>"},{"location":"api/python/json-schema-node/#using-pydantic-for-handles","title":"Using Pydantic for Handles","text":"<pre><code>from pydantic import BaseModel\n\nclass InputHandles(BaseModel):\n    data_in: str\n    config_in: str\n\nclass OutputHandles(BaseModel):\n    result: str\n    metadata: str\n\nclass MyNode(JsonSchemaNodeWidget):\n    label = \"My Node\"\n    parameters = MyParams\n    inputs = InputHandles\n    outputs = OutputHandles\n</code></pre>"},{"location":"api/python/json-schema-node/#working-with-values","title":"Working with Values","text":""},{"location":"api/python/json-schema-node/#getting-values","title":"Getting Values","text":"<pre><code># Inside node class\ndef execute(self, inputs):\n    config = self.get_values()\n    threshold = config[\"threshold\"]\n    mode = config[\"mode\"]\n    # ... use values\n\n# From widget instance\nnode = ProcessorNode(threshold=0.8, enabled=True)\nvalues = node.get_values()\n# {\"threshold\": 0.8, \"mode\": \"auto\", \"enabled\": True}\n</code></pre>"},{"location":"api/python/json-schema-node/#setting-values","title":"Setting Values","text":"<pre><code># Set multiple values\nnode.set_values({\"threshold\": 0.9, \"mode\": \"manual\"})\n\n# Set single value\nnode.set_value(\"threshold\", 0.9)\n\n# During initialization\nnode = ProcessorNode(threshold=0.7, mode=\"advanced\")\n</code></pre>"},{"location":"api/python/json-schema-node/#validation","title":"Validation","text":"<pre><code># Check if current values are valid\nif node.validate():\n    print(\"Configuration is valid\")\nelse:\n    print(\"Invalid configuration\")\n</code></pre>"},{"location":"api/python/json-schema-node/#execution-logic","title":"Execution Logic","text":""},{"location":"api/python/json-schema-node/#implementing-execute","title":"Implementing execute()","text":"<pre><code>class ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    inputs = [{\"id\": \"data_in\", \"label\": \"Data\"}]\n    outputs = [{\"id\": \"data_out\", \"label\": \"Processed\"}]\n\n    def execute(self, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Process input data.\"\"\"\n        # Get configuration\n        config = self.get_values()\n        threshold = config[\"threshold\"]\n\n        # Get input data\n        data = inputs.get(\"data_in\", [])\n\n        # Process\n        filtered = [x for x in data if x &gt;= threshold]\n\n        # Return outputs\n        return {\"data_out\": filtered}\n</code></pre>"},{"location":"api/python/json-schema-node/#execute-signature","title":"execute() Signature","text":"<pre><code>def execute(self, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute node logic.\n\n    Args:\n        inputs: Dictionary mapping input handle IDs to values\n                e.g., {\"data_in\": [1, 2, 3], \"config_in\": {...}}\n\n    Returns:\n        Dictionary mapping output handle IDs to values\n        e.g., {\"data_out\": [1, 2], \"metadata\": {...}}\n    \"\"\"\n    pass\n</code></pre> <p>Execution is Optional</p> <p>PyNodeWidget provides the graph structure but doesn't enforce an execution model. Implement <code>execute()</code> if you plan to run workflows programmatically.</p>"},{"location":"api/python/json-schema-node/#factory-methods","title":"Factory Methods","text":""},{"location":"api/python/json-schema-node/#from_pydantic","title":"from_pydantic()","text":"<p>Create a node without defining a full subclass:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\nfrom pynodeflow.node_builder import with_style\n\n# Quick node creation\nnode = JsonSchemaNodeWidget.from_pydantic(\n    model_class=ProcessorParams,\n    label=\"Quick Processor\",\n    icon=\"\u26a1\",\n    category=\"processing\",\n    inputs=[{\"id\": \"in\", \"label\": \"Input\"}],\n    outputs=[{\"id\": \"out\", \"label\": \"Output\"}],\n    initial_values={\"threshold\": 0.7}\n)\n\n# With styling\nnode = JsonSchemaNodeWidget.from_pydantic(\n    model_class=ProcessorParams,\n    label=\"Styled Processor\",\n    header={\n        \"show\": True,\n        \"icon\": \"\u2728\",\n        \"className\": \"bg-blue-600 text-white\"\n    },\n    style={\n        \"minWidth\": \"300px\",\n        \"shadow\": \"lg\"\n    }\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#from_schema","title":"from_schema()","text":"<p>Create a node from raw JSON schema (legacy):</p> <pre><code>schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"threshold\": {\n            \"type\": \"number\",\n            \"default\": 0.5,\n            \"minimum\": 0,\n            \"maximum\": 1\n        }\n    }\n}\n\nnode = JsonSchemaNodeWidget.from_schema(\n    schema=schema,\n    label=\"Schema Node\",\n    icon=\"\ud83d\udccb\",\n    inputs=[{\"id\": \"in\", \"label\": \"Input\"}],\n    outputs=[{\"id\": \"out\", \"label\": \"Output\"}]\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#layout-and-styling","title":"Layout and Styling","text":""},{"location":"api/python/json-schema-node/#layout-types","title":"Layout Types","text":"<pre><code># Horizontal: inputs left, outputs right\nclass HorizontalNode(JsonSchemaNodeWidget):\n    layout_type = \"horizontal\"\n\n# Vertical: inputs top, outputs bottom\nclass VerticalNode(JsonSchemaNodeWidget):\n    layout_type = \"vertical\"\n\n# Compact: minimal spacing\nclass CompactNode(JsonSchemaNodeWidget):\n    layout_type = \"compact\"\n</code></pre>"},{"location":"api/python/json-schema-node/#handle-types","title":"Handle Types","text":"<pre><code># Base: small dot handles (default)\nclass BaseNode(JsonSchemaNodeWidget):\n    handle_type = \"base\"\n\n# Button: larger, interactive buttons\nclass ButtonNode(JsonSchemaNodeWidget):\n    handle_type = \"button\"\n\n# Labeled: handles with visible labels\nclass LabeledNode(JsonSchemaNodeWidget):\n    handle_type = \"labeled\"\n</code></pre>"},{"location":"api/python/json-schema-node/#mixed-handle-types","title":"Mixed Handle Types","text":"<pre><code># Different types for inputs and outputs\nnode = JsonSchemaNodeWidget.from_pydantic(\n    MyParams,\n    label=\"Mixed Handles\",\n    input_handle_type=\"labeled\",\n    output_handle_type=\"button\"\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/python/json-schema-node/#enhanced-styling","title":"Enhanced Styling","text":"<pre><code>from pynodeflow.node_builder import create_processing_node, with_style\n\n# Using node builder utilities\nconfig = create_processing_node(\"Advanced Node\", icon=\"\ud83d\ude80\")\nconfig = with_style(config, \n    min_width=\"350px\",\n    max_width=\"600px\",\n    border_radius=\"12px\",\n    shadow=\"xl\",\n    class_name=\"border-2 border-blue-500\"\n)\n\nnode = JsonSchemaNodeWidget.from_pydantic(\n    MyParams,\n    **config\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#custom-header-and-footer","title":"Custom Header and Footer","text":"<pre><code>node = JsonSchemaNodeWidget.from_pydantic(\n    MyParams,\n    label=\"Custom Node\",\n    header={\n        \"show\": True,\n        \"icon\": \"\u2728\",\n        \"bgColor\": \"#3b82f6\",\n        \"textColor\": \"#ffffff\",\n        \"className\": \"font-bold\"\n    },\n    footer={\n        \"show\": True,\n        \"text\": \"v1.0.0\",\n        \"className\": \"text-xs text-gray-500\"\n    }\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#conditional-fields","title":"Conditional Fields","text":"<pre><code>from pynodeflow.node_builder import make_fields_conditional\n\nfieldConfigs = make_fields_conditional(\n    trigger_field=\"mode\",\n    trigger_value=\"advanced\",\n    dependent_fields=[\"threshold\", \"iterations\"]\n)\n\nnode = JsonSchemaNodeWidget.from_pydantic(\n    MyParams,\n    label=\"Conditional Node\",\n    fieldConfigs=fieldConfigs\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#validation-configuration","title":"Validation Configuration","text":"<pre><code>node = JsonSchemaNodeWidget.from_pydantic(\n    MyParams,\n    label=\"Validated Node\",\n    validation={\n        \"showErrors\": True,\n        \"errorPosition\": \"inline\",  # or \"tooltip\", \"footer\"\n        \"validateOnChange\": True\n    }\n)\n</code></pre>"},{"location":"api/python/json-schema-node/#complete-example","title":"Complete Example","text":"<pre><code>from pydantic import BaseModel, Field\nfrom typing import Literal\nfrom pynodewidget import JsonSchemaNodeWidget, NodeFlowWidget\n\n# Define parameters\nclass ImageProcessorParams(BaseModel):\n    algorithm: Literal[\"blur\", \"sharpen\", \"edge\"] = \"blur\"\n    strength: float = Field(default=0.5, ge=0, le=1, description=\"Effect strength\")\n    preserve_alpha: bool = Field(default=True, description=\"Preserve transparency\")\n    iterations: int = Field(default=1, ge=1, le=10, description=\"Number of passes\")\n\n# Create node class\nclass ImageProcessorNode(JsonSchemaNodeWidget):\n    \"\"\"Image processing node with multiple algorithms.\"\"\"\n\n    label = \"Image Processor\"\n    parameters = ImageProcessorParams\n    icon = \"\ud83d\uddbc\ufe0f\"\n    category = \"image\"\n    description = \"Apply various image processing algorithms\"\n\n    inputs = [\n        {\"id\": \"image\", \"label\": \"Image\"},\n        {\"id\": \"mask\", \"label\": \"Mask (optional)\"}\n    ]\n    outputs = [\n        {\"id\": \"result\", \"label\": \"Processed Image\"},\n        {\"id\": \"metadata\", \"label\": \"Processing Info\"}\n    ]\n\n    layout_type = \"vertical\"\n    handle_type = \"labeled\"\n\n    def execute(self, inputs):\n        \"\"\"Execute image processing.\"\"\"\n        config = self.get_values()\n        image = inputs.get(\"image\")\n        mask = inputs.get(\"mask\")\n\n        # Processing logic here\n        result = self._process_image(\n            image,\n            algorithm=config[\"algorithm\"],\n            strength=config[\"strength\"],\n            iterations=config[\"iterations\"]\n        )\n\n        metadata = {\n            \"algorithm\": config[\"algorithm\"],\n            \"iterations\": config[\"iterations\"]\n        }\n\n        return {\n            \"result\": result,\n            \"metadata\": metadata\n        }\n\n    def _process_image(self, image, algorithm, strength, iterations):\n        \"\"\"Internal processing method.\"\"\"\n        # Your image processing code\n        pass\n\n# Use in workflow\nflow = NodeFlowWidget(nodes=[ImageProcessorNode])\nflow\n</code></pre>"},{"location":"api/python/json-schema-node/#see-also","title":"See Also","text":"<ul> <li>NodeFlowWidget: Main widget for workflows</li> <li>Protocols: NodeFactory protocol</li> <li>Custom Nodes Guide: Practical examples</li> </ul>"},{"location":"api/python/observable-dict/","title":"ObservableDict","text":"<p>Auto-syncing dictionary that triggers callbacks on mutations.</p>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict","title":"<code>ObservableDict(*args, callback=None, **kwargs)</code>","text":"<p>               Bases: <code>dict[str, Any]</code></p> <p>A dictionary that triggers a callback on any mutation.</p> <p>Wraps a standard dict and intercepts all mutation operations to trigger a callback, enabling automatic sync with traitlets without manual reassignment.</p> <p>Nested dicts are automatically wrapped to enable recursive observation.</p> <p>Initialize an ObservableDict.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments passed to dict constructor</p> <code>()</code> <code>callback</code> <code>Optional[Callable[[], None]]</code> <p>Optional callback function to call on mutations</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments passed to dict constructor</p> <code>{}</code> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def __init__(self, *args: Any, callback: Optional[Callable[[], None]] = None, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize an ObservableDict.\n\n    Args:\n        *args: Positional arguments passed to dict constructor\n        callback: Optional callback function to call on mutations\n        **kwargs: Keyword arguments passed to dict constructor\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    # Store callback in __dict__ to avoid triggering __setitem__\n    object.__setattr__(self, '_callback', callback)\n\n    # Wrap any existing nested dicts\n    for key, value in list(self.items()):\n        if isinstance(value, dict) and not isinstance(value, ObservableDict):\n            super().__setitem__(key, ObservableDict(value, callback=callback))\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item and trigger callback. Wraps nested dicts.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def __setitem__(self, key: Any, value: Any) -&gt; None:\n    \"\"\"Set an item and trigger callback. Wraps nested dicts.\"\"\"\n    if isinstance(value, dict) and not isinstance(value, ObservableDict):\n        callback = object.__getattribute__(self, '_callback')\n        value = ObservableDict(value, callback=callback)\n    super().__setitem__(key, value)\n    self._notify()\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete an item and trigger callback.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def __delitem__(self, key: Any) -&gt; None:\n    \"\"\"Delete an item and trigger callback.\"\"\"\n    super().__delitem__(key)\n    self._notify()\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.update","title":"<code>update(*args, **kwargs)</code>","text":"<p>Update dict and trigger callback. Wraps nested dicts.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def update(self, *args, **kwargs) -&gt; None:\n    \"\"\"Update dict and trigger callback. Wraps nested dicts.\"\"\"\n    callback = object.__getattribute__(self, '_callback')\n    if args:\n        other = args[0]\n        if isinstance(other, dict):\n            for key, value in other.items():\n                if isinstance(value, dict) and not isinstance(value, ObservableDict):\n                    other[key] = ObservableDict(value, callback=callback)\n    for key, value in kwargs.items():\n        if isinstance(value, dict) and not isinstance(value, ObservableDict):\n            kwargs[key] = ObservableDict(value, callback=callback)\n    super().update(*args, **kwargs)\n    self._notify()\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.pop","title":"<code>pop(*args)</code>","text":"<p>Remove and return an item, triggering callback.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def pop(self, *args) -&gt; Any:\n    \"\"\"Remove and return an item, triggering callback.\"\"\"\n    result = super().pop(*args)\n    self._notify()\n    return result\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.popitem","title":"<code>popitem()</code>","text":"<p>Remove and return an arbitrary item, triggering callback.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def popitem(self) -&gt; tuple[Any, Any]:\n    \"\"\"Remove and return an arbitrary item, triggering callback.\"\"\"\n    result = super().popitem()\n    self._notify()\n    return result\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.clear","title":"<code>clear()</code>","text":"<p>Remove all items and trigger callback.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items and trigger callback.\"\"\"\n    super().clear()\n    self._notify()\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>Get item or set default, triggering callback if key doesn't exist.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def setdefault(self, key: Any, default: Any = None) -&gt; Any:\n    \"\"\"Get item or set default, triggering callback if key doesn't exist.\"\"\"\n    if key not in self:\n        if isinstance(default, dict) and not isinstance(default, ObservableDict):\n            callback = object.__getattribute__(self, '_callback')\n            default = ObservableDict(default, callback=callback)\n        self._notify()\n    return super().setdefault(key, default)\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDict.__reduce_ex__","title":"<code>__reduce_ex__(protocol)</code>","text":"<p>Support for pickling - return as regular dict.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def __reduce_ex__(self, protocol: int) -&gt; tuple[type[dict[str, Any]], tuple[dict[str, Any]]]:\n    \"\"\"Support for pickling - return as regular dict.\"\"\"\n    return (dict, (dict(self),))\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDictTrait","title":"<code>ObservableDictTrait(default_value=t.Undefined, **kwargs)</code>","text":"<p>               Bases: <code>TraitType[ObservableDict, dict[str, Any]]</code></p> <p>A traitlet that maintains ObservableDict with automatic callback rewiring.</p> <p>Ensures values are wrapped in ObservableDict and callbacks are preserved across serialization/deserialization.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def __init__(self, default_value: Any = t.Undefined, **kwargs: Any) -&gt; None:\n    if default_value is t.Undefined:\n        default_value = {}\n    super().__init__(default_value=default_value, **kwargs)\n</code></pre>"},{"location":"api/python/observable-dict/#pynodewidget.observable_dict.ObservableDictTrait.validate","title":"<code>validate(obj, value)</code>","text":"<p>Validate and wrap value in ObservableDict.</p> Source code in <code>pynodewidget/observable_dict.py</code> <pre><code>def validate(self, obj: Any, value: Any) -&gt; ObservableDict:\n    \"\"\"Validate and wrap value in ObservableDict.\"\"\"\n    callback = lambda: obj.notify_change({'name': self.name, 'type': 'change'})\n    if isinstance(value, ObservableDict):\n        value._rewrap_with_callback(callback)\n        return value\n    elif isinstance(value, dict):\n        return ObservableDict(value, callback=callback)\n    else:\n        self.error(obj, value)\n</code></pre>"},{"location":"api/python/observable-dict/#overview","title":"Overview","text":"<p><code>ObservableDict</code> is a specialized dictionary subclass that automatically notifies a callback function whenever it's mutated. This enables automatic synchronization with Traitlets without manual reassignment.</p>"},{"location":"api/python/observable-dict/#the-problem-it-solves","title":"The Problem It Solves","text":"<p>Standard Python dictionaries don't trigger Traitlet observers when nested values change:</p> <pre><code># \u274c This doesn't trigger sync to JavaScript\nflow.node_values[\"node-1\"][\"threshold\"] = 0.8\n\n# \u2705 This works but is cumbersome\nvalues = flow.node_values[\"node-1\"]\nvalues[\"threshold\"] = 0.8\nflow.node_values = flow.node_values  # Manual trigger\n</code></pre> <p><code>ObservableDict</code> makes nested mutations work automatically:</p> <pre><code># \u2705 This triggers sync automatically\nflow.node_values[\"node-1\"][\"threshold\"] = 0.8\n</code></pre>"},{"location":"api/python/observable-dict/#basic-usage","title":"Basic Usage","text":""},{"location":"api/python/observable-dict/#creating-an-observabledict","title":"Creating an ObservableDict","text":"<pre><code>from pynodewidget import ObservableDict\n\ndef on_change():\n    print(\"Dictionary was modified!\")\n\n# Create with callback\ndata = ObservableDict(callback=on_change)\n\n# Mutations trigger callback\ndata[\"key\"] = \"value\"  # Prints: \"Dictionary was modified!\"\ndata.update({\"a\": 1, \"b\": 2})  # Prints: \"Dictionary was modified!\"\ndel data[\"key\"]  # Prints: \"Dictionary was modified!\"\n</code></pre>"},{"location":"api/python/observable-dict/#from-existing-dict","title":"From Existing Dict","text":"<pre><code>existing = {\"a\": 1, \"b\": 2, \"c\": {\"nested\": 3}}\nobservable = ObservableDict(existing, callback=on_change)\n\n# Nested dicts are automatically wrapped\nobservable[\"c\"][\"nested\"] = 4  # Triggers callback!\n</code></pre>"},{"location":"api/python/observable-dict/#without-callback","title":"Without Callback","text":"<pre><code># Can be used as a regular dict\ndata = ObservableDict({\"x\": 1, \"y\": 2})\ndata[\"z\"] = 3  # No callback triggered\n</code></pre>"},{"location":"api/python/observable-dict/#supported-operations","title":"Supported Operations","text":"<p>All standard dictionary operations trigger the callback:</p> <pre><code>data = ObservableDict(callback=on_change)\n\n# Assignment\ndata[\"key\"] = \"value\"  # \u2713 Triggers\n\n# Update\ndata.update({\"a\": 1, \"b\": 2})  # \u2713 Triggers\n\n# Deletion\ndel data[\"key\"]  # \u2713 Triggers\n\n# Pop\nvalue = data.pop(\"a\")  # \u2713 Triggers\n\n# Pop item\nkey, value = data.popitem()  # \u2713 Triggers\n\n# Clear\ndata.clear()  # \u2713 Triggers\n\n# Set default\ndata.setdefault(\"new_key\", \"default\")  # \u2713 Triggers (if key doesn't exist)\n\n# Read operations don't trigger\nvalue = data[\"key\"]  # \u2717 No trigger\nkeys = data.keys()  # \u2717 No trigger\n</code></pre>"},{"location":"api/python/observable-dict/#nested-dictionaries","title":"Nested Dictionaries","text":"<p>ObservableDict automatically wraps nested dictionaries:</p> <pre><code>data = ObservableDict(callback=on_change)\n\n# Assigning a regular dict converts it to ObservableDict\ndata[\"config\"] = {\"threshold\": 0.5, \"enabled\": True}\n\n# Now nested mutations trigger the callback\ndata[\"config\"][\"threshold\"] = 0.8  # \u2713 Triggers!\n\n# Works recursively\ndata[\"deep\"] = {\"level1\": {\"level2\": {\"value\": 42}}}\ndata[\"deep\"][\"level1\"][\"level2\"][\"value\"] = 100  # \u2713 Triggers!\n</code></pre>"},{"location":"api/python/observable-dict/#usage-in-nodeflowwidget","title":"Usage in NodeFlowWidget","text":""},{"location":"api/python/observable-dict/#the-node_values-trait","title":"The node_values Trait","text":"<p><code>NodeFlowWidget.node_values</code> uses <code>ObservableDictTrait</code> to automatically wrap values:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\n# node_values is automatically an ObservableDict\nflow.node_values[\"node-1\"] = {\"threshold\": 0.5}\n\n# Nested mutations automatically sync to JavaScript\nflow.node_values[\"node-1\"][\"threshold\"] = 0.8  # \u2713 Syncs!\n</code></pre>"},{"location":"api/python/observable-dict/#how-it-works-internally","title":"How It Works Internally","text":"<pre><code>class NodeFlowWidget(anywidget.AnyWidget):\n    node_values = ObservableDictTrait().tag(sync=True)\n</code></pre> <p>When you assign to <code>node_values</code>, <code>ObservableDictTrait</code>:</p> <ol> <li>Wraps the value in <code>ObservableDict</code></li> <li>Sets callback to notify Traitlets</li> <li>Ensures nested dicts are also wrapped</li> </ol>"},{"location":"api/python/observable-dict/#observabledicttrait","title":"ObservableDictTrait","text":"<p>Custom Traitlet for maintaining ObservableDict across serialization.</p>"},{"location":"api/python/observable-dict/#purpose","title":"Purpose","text":"<p>Ensures values are always wrapped in <code>ObservableDict</code> with correct callbacks, even after deserialization from JavaScript.</p>"},{"location":"api/python/observable-dict/#usage","title":"Usage","text":"<pre><code>import traitlets as t\nfrom pynodewidget import ObservableDictTrait\n\nclass MyWidget(anywidget.AnyWidget):\n    data = ObservableDictTrait().tag(sync=True)\n</code></pre>"},{"location":"api/python/observable-dict/#validation","title":"Validation","text":"<p>The trait automatically:</p> <ol> <li>Wraps plain dicts in <code>ObservableDict</code></li> <li>Re-wires callbacks after deserialization</li> <li>Recursively wraps nested dicts</li> </ol> <pre><code># All of these work correctly\nwidget.data = {\"a\": 1}  # Plain dict \u2192 wrapped\nwidget.data = ObservableDict({\"a\": 1})  # Already wrapped \u2192 callback re-wired\nwidget.data = {\"nested\": {\"value\": 1}}  # Nested dicts \u2192 wrapped recursively\n</code></pre>"},{"location":"api/python/observable-dict/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/python/observable-dict/#custom-callbacks","title":"Custom Callbacks","text":"<pre><code>class MyWidget:\n    def __init__(self):\n        self.changes = []\n        self.data = ObservableDict(callback=self._on_change)\n\n    def _on_change(self):\n        self.changes.append(dict(self.data))\n        print(f\"Total changes: {len(self.changes)}\")\n\nwidget = MyWidget()\nwidget.data[\"a\"] = 1  # Prints: \"Total changes: 1\"\nwidget.data[\"b\"] = 2  # Prints: \"Total changes: 2\"\n</code></pre>"},{"location":"api/python/observable-dict/#rewiring-callbacks","title":"Rewiring Callbacks","text":"<p>After serialization/deserialization, you may need to rewire callbacks:</p> <pre><code>data = ObservableDict({\"a\": 1}, callback=lambda: print(\"Old callback\"))\n\n# Create new callback\ndef new_callback():\n    print(\"New callback\")\n\n# Rewire recursively\ndata._rewrap_with_callback(new_callback)\n\ndata[\"a\"] = 2  # Prints: \"New callback\"\n</code></pre> <p>This is handled automatically by <code>ObservableDictTrait</code>.</p>"},{"location":"api/python/observable-dict/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/python/observable-dict/#overhead","title":"Overhead","text":"<p>Each mutation triggers the callback, which may:</p> <ul> <li>Notify Traitlets</li> <li>Serialize to JSON</li> <li>Send message to JavaScript</li> </ul> <p>For bulk updates, consider batching:</p> <pre><code># \u274c Multiple syncs\nfor key, value in large_dict.items():\n    flow.node_values[\"node-1\"][key] = value  # Syncs each time!\n\n# \u2705 Single sync\nflow.node_values[\"node-1\"].update(large_dict)  # Syncs once\n</code></pre>"},{"location":"api/python/observable-dict/#memory","title":"Memory","text":"<p>ObservableDict stores a reference to the callback function. For large numbers of ObservableDicts, this adds minimal overhead.</p> <p>Nested dicts are wrapped recursively, which adds wrapping objects but shares the same callback reference.</p>"},{"location":"api/python/observable-dict/#serialization","title":"Serialization","text":""},{"location":"api/python/observable-dict/#pickling","title":"Pickling","text":"<p>ObservableDict serializes as a regular dict:</p> <pre><code>import pickle\n\ndata = ObservableDict({\"a\": 1}, callback=lambda: None)\nserialized = pickle.dumps(data)\nrestored = pickle.loads(serialized)\n\n# Restored as regular dict\nassert type(restored) == dict\nassert restored == {\"a\": 1}\n</code></pre> <p>This is intentional - callbacks don't survive serialization.</p>"},{"location":"api/python/observable-dict/#json","title":"JSON","text":"<p>ObservableDict works with JSON serialization:</p> <pre><code>import json\n\ndata = ObservableDict({\"a\": 1, \"b\": {\"c\": 2}})\njson_str = json.dumps(data)  # Works as regular dict\n</code></pre>"},{"location":"api/python/observable-dict/#implementation-details","title":"Implementation Details","text":""},{"location":"api/python/observable-dict/#callback-storage","title":"Callback Storage","text":"<p>The callback is stored in <code>__dict__</code> to avoid triggering <code>__setitem__</code>:</p> <pre><code>def __init__(self, *args, callback=None, **kwargs):\n    super().__init__(*args, **kwargs)\n    # Store in __dict__ to bypass __setitem__\n    object.__setattr__(self, '_callback', callback)\n</code></pre>"},{"location":"api/python/observable-dict/#notification-method","title":"Notification Method","text":"<pre><code>def _notify(self):\n    \"\"\"Trigger the callback if set.\"\"\"\n    callback = object.__getattribute__(self, '_callback')\n    if callback:\n        callback()\n</code></pre> <p>Uses <code>object.__getattribute__</code> to bypass any custom <code>__getattribute__</code>.</p>"},{"location":"api/python/observable-dict/#wrapping-on-assignment","title":"Wrapping on Assignment","text":"<pre><code>def __setitem__(self, key, value):\n    \"\"\"Set an item and trigger callback. Wraps nested dicts.\"\"\"\n    if isinstance(value, dict) and not isinstance(value, ObservableDict):\n        callback = object.__getattribute__(self, '_callback')\n        value = ObservableDict(value, callback=callback)\n    super().__setitem__(key, value)\n    self._notify()\n</code></pre> <p>Automatically wraps plain dicts and shares the callback.</p>"},{"location":"api/python/observable-dict/#examples","title":"Examples","text":""},{"location":"api/python/observable-dict/#simple-callback","title":"Simple Callback","text":"<pre><code>def log_changes():\n    print(\"Data changed!\")\n\ndata = ObservableDict(callback=log_changes)\n\ndata[\"a\"] = 1  # Prints: \"Data changed!\"\ndata.update({\"b\": 2, \"c\": 3})  # Prints: \"Data changed!\"\n</code></pre>"},{"location":"api/python/observable-dict/#tracking-changes","title":"Tracking Changes","text":"<pre><code>class ChangeTracker:\n    def __init__(self):\n        self.change_count = 0\n        self.data = ObservableDict(callback=self.on_change)\n\n    def on_change(self):\n        self.change_count += 1\n\ntracker = ChangeTracker()\ntracker.data[\"a\"] = 1\ntracker.data[\"b\"] = 2\nprint(tracker.change_count)  # 2\n</code></pre>"},{"location":"api/python/observable-dict/#nested-data","title":"Nested Data","text":"<pre><code>def on_change():\n    print(\"Changed!\")\n\ndata = ObservableDict(callback=on_change)\n\n# Nested structures work automatically\ndata[\"user\"] = {\"name\": \"Alice\", \"settings\": {\"theme\": \"dark\"}}\n\ndata[\"user\"][\"name\"] = \"Bob\"  # Prints: \"Changed!\"\ndata[\"user\"][\"settings\"][\"theme\"] = \"light\"  # Prints: \"Changed!\"\n</code></pre>"},{"location":"api/python/observable-dict/#with-nodeflowwidget","title":"With NodeFlowWidget","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\n# Initialize node values\nflow.node_values[\"node-1\"] = {\"threshold\": 0.5, \"enabled\": True}\n\n# Update nested value (syncs to JavaScript automatically)\nflow.node_values[\"node-1\"][\"threshold\"] = 0.8\n\n# Batch update (one sync)\nflow.node_values[\"node-1\"].update({\n    \"threshold\": 0.9,\n    \"enabled\": False,\n    \"mode\": \"advanced\"\n})\n\n# Read value (no sync)\nthreshold = flow.node_values[\"node-1\"][\"threshold\"]\n</code></pre>"},{"location":"api/python/observable-dict/#troubleshooting","title":"Troubleshooting","text":""},{"location":"api/python/observable-dict/#callback-not-firing","title":"Callback Not Firing","text":"<p>Ensure callback is set:</p> <pre><code>data = ObservableDict()  # No callback\ndata[\"key\"] = \"value\"  # Nothing happens\n\ndata = ObservableDict(callback=lambda: print(\"Changed\"))\ndata[\"key\"] = \"value\"  # Prints: \"Changed\"\n</code></pre>"},{"location":"api/python/observable-dict/#nested-dicts-not-observed","title":"Nested Dicts Not Observed","text":"<p>If you assign a dict directly to a nested location:</p> <pre><code>data = {}  # Regular dict, not observable\ndata[\"nested\"] = {\"value\": 1}\n\nobservable = ObservableDict(data, callback=on_change)\nobservable[\"nested\"][\"value\"] = 2  # \u2713 Triggers (wrapped during init)\n</code></pre>"},{"location":"api/python/observable-dict/#performance-issues","title":"Performance Issues","text":"<p>If callbacks fire too frequently, consider batching:</p> <pre><code># Instead of\nfor i in range(1000):\n    data[str(i)] = i  # 1000 callbacks!\n\n# Use\nupdates = {str(i): i for i in range(1000)}\ndata.update(updates)  # 1 callback\n</code></pre>"},{"location":"api/python/observable-dict/#see-also","title":"See Also","text":"<ul> <li>NodeFlowWidget: Uses ObservableDict for node_values</li> <li>Working with Values: Guide on value management</li> <li>Python-JavaScript Architecture: How sync works</li> </ul>"},{"location":"api/python/protocols/","title":"Protocols","text":"<p>Type protocols and metadata utilities for node registration.</p>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeFactory","title":"<code>NodeFactory(**initial_values)</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for node type definitions.</p> <p>DEPRECATION WARNING: The 'parameters' attribute is deprecated. Instead, define nodes using the grid-based architecture: - grid_layout: Dict defining NodeGrid \u2192 GridCell \u2192 Components structure - Use HandleComponent (BaseHandle, ButtonHandle, LabeledHandle) for inputs/outputs - Use FieldComponent (TextField, NumberField, etc.) for configuration fields</p> <p>Any class implementing this protocol can be registered with NodeFlowWidget to create custom node types in the visual editor.</p> Required Attributes <p>label (str): Display name for the node shown in UI parameters (Type[BaseModel]): DEPRECATED - Use grid_layout instead</p> Optional Attributes <p>icon (str): Unicode emoji or icon identifier (default: \"\") category (str): Category for grouping nodes in UI (default: \"general\") description (str): Help text shown to users (default: \"\") inputs (List[Dict[str, str]]): DEPRECATED - Define in grid_layout instead outputs (List[Dict[str, str]]): DEPRECATED - Define in grid_layout instead grid_layout (Dict[str, Any]): Grid layout configuration (RECOMMENDED)</p> Required Methods <p>init: Initialize node instance with optional initial values get_values: Get current configuration values as a dictionary set_values: Update configuration values from a dictionary</p> Optional Methods <p>validate: Validate current configuration, returns True if valid execute: Execute node logic (for future execution engine)</p> <p>Example (deprecated approach):     &gt;&gt;&gt; from pydantic import BaseModel     &gt;&gt;&gt;      &gt;&gt;&gt; class ProcessingConfig(BaseModel):     ...     threshold: float = 0.5     ...     mode: str = \"auto\"     &gt;&gt;&gt;      &gt;&gt;&gt; class ImageProcessor:     ...     label = \"Image Processor\"     ...     parameters = ProcessingConfig     ...     icon = \"\ud83d\uddbc\ufe0f\"</p> <p>Example (recommended grid-based approach):     &gt;&gt;&gt; from pynodewidget.grid_layouts import create_three_column_grid     &gt;&gt;&gt; from pynodewidget.models import ButtonHandle, TextField     &gt;&gt;&gt;      &gt;&gt;&gt; class ImageProcessor:     ...     label = \"Image Processor\"     ...     icon = \"\ud83d\uddbc\ufe0f\"     ...     grid_layout = create_three_column_grid(     ...         left_components=[ButtonHandle(id=\"in\", label=\"Input\", handle_type=\"input\")],     ...         center_components=[TextField(id=\"mode\", label=\"Mode\", value=\"auto\")],     ...         right_components=[ButtonHandle(id=\"out\", label=\"Output\", handle_type=\"output\")]     ...     )</p> <p>Initialize node instance with optional initial values.</p> <p>Parameters:</p> Name Type Description Default <code>**initial_values</code> <code>Any</code> <p>Initial configuration values for the node parameters</p> <code>{}</code> Source code in <code>pynodewidget/protocols.py</code> <pre><code>def __init__(self, **initial_values: Any) -&gt; None:\n    \"\"\"Initialize node instance with optional initial values.\n\n    Args:\n        **initial_values: Initial configuration values for the node parameters\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeFactory.get_values","title":"<code>get_values()</code>","text":"<p>Get current configuration values.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing all current parameter values</p> Source code in <code>pynodewidget/protocols.py</code> <pre><code>def get_values(self) -&gt; Dict[str, Any]:\n    \"\"\"Get current configuration values.\n\n    Returns:\n        Dictionary containing all current parameter values\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeFactory.set_values","title":"<code>set_values(values)</code>","text":"<p>Update configuration values.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Dict[str, Any]</code> <p>Dictionary of parameter values to update</p> required Source code in <code>pynodewidget/protocols.py</code> <pre><code>def set_values(self, values: Dict[str, Any]) -&gt; None:\n    \"\"\"Update configuration values.\n\n    Args:\n        values: Dictionary of parameter values to update\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeFactory.validate","title":"<code>validate()</code>","text":"<p>Validate current configuration.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration is valid, False otherwise</p> Source code in <code>pynodewidget/protocols.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"Validate current configuration.\n\n    Returns:\n        True if configuration is valid, False otherwise\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeFactory.execute","title":"<code>execute(inputs)</code>","text":"<p>Execute node logic with provided inputs.</p> <p>This method is optional and used by the execution engine.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Dict[str, Any]</code> <p>Dictionary of input values from connected nodes</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of output values to pass to connected nodes</p> Source code in <code>pynodewidget/protocols.py</code> <pre><code>def execute(self, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"Execute node logic with provided inputs.\n\n    This method is optional and used by the execution engine.\n\n    Args:\n        inputs: Dictionary of input values from connected nodes\n\n    Returns:\n        Dictionary of output values to pass to connected nodes\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.HandleSpec","title":"<code>HandleSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Specification for a node handle (input or output connection point).</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for the handle within the node</p> <code>label</code> <code>str</code> <p>Display name shown in the UI</p> <code>handle_type</code> <code>Literal['base', 'button', 'labeled']</code> <p>Type of handle component to render (\"base\", \"button\", or \"labeled\")</p>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeMetadata","title":"<code>NodeMetadata(type_name, label, parameters_schema, icon='', category='general', description='', grid_layout=None)</code>","text":"<p>Metadata extracted from a NodeFactory class for serialization.</p> <p>This class is used internally to extract and serialize node metadata for transmission to the JavaScript layer.</p> <p>Initialize node metadata.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>Unique identifier for the node type</p> required <code>label</code> <code>str</code> <p>Display name for the node</p> required <code>parameters_schema</code> <code>Dict[str, Any]</code> <p>JSON Schema for node parameters</p> required <code>icon</code> <code>str</code> <p>Unicode emoji or icon identifier</p> <code>''</code> <code>category</code> <code>str</code> <p>Category for grouping nodes</p> <code>'general'</code> <code>description</code> <code>str</code> <p>Help text</p> <code>''</code> <code>grid_layout</code> <code>Optional[Dict[str, Any]]</code> <p>Grid layout configuration</p> <code>None</code> Source code in <code>pynodewidget/protocols.py</code> <pre><code>def __init__(\n    self,\n    type_name: str,\n    label: str,\n    parameters_schema: Dict[str, Any],\n    icon: str = \"\",\n    category: str = \"general\",\n    description: str = \"\",\n    grid_layout: Optional[Dict[str, Any]] = None,\n):\n    \"\"\"Initialize node metadata.\n\n    Args:\n        type_name: Unique identifier for the node type\n        label: Display name for the node\n        parameters_schema: JSON Schema for node parameters\n        icon: Unicode emoji or icon identifier\n        category: Category for grouping nodes\n        description: Help text\n        grid_layout: Grid layout configuration\n    \"\"\"\n    self.type_name = type_name\n    self.label = label\n    self.parameters_schema = parameters_schema\n    self.icon = icon\n    self.category = category\n    self.description = description\n    self.grid_layout = grid_layout\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeMetadata.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert metadata to dictionary for JSON serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representation of node metadata</p> Source code in <code>pynodewidget/protocols.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert metadata to dictionary for JSON serialization.\n\n    Returns:\n        Dictionary representation of node metadata\n    \"\"\"\n    from .grid_layouts import create_vertical_stack_grid, json_schema_to_components\n    from .models import NodeDefinition, NodeTemplate\n\n    # Get grid layout if specified, otherwise create default vertical grid\n    grid = self.grid_layout\n    if grid is None:\n        # Generate default grid with JSON schema fields\n        field_components = json_schema_to_components(self.parameters_schema, {})\n        grid = create_vertical_stack_grid(middle_components=field_components)\n\n    # Extract default values from schema\n    default_values = {}\n    if \"properties\" in self.parameters_schema:\n        for key, prop in self.parameters_schema[\"properties\"].items():\n            if \"default\" in prop:\n                default_values[key] = prop[\"default\"]\n\n    # Build NodeDefinition (visual structure only)\n    definition_dict = {\n        \"grid\": grid,\n    }\n\n    try:\n        # Validate the definition structure\n        definition = NodeDefinition(**definition_dict)\n\n        # Create and validate the full template\n        template_dict = {\n            \"type\": self.type_name,\n            \"label\": self.label,\n            \"icon\": self.icon,\n            \"category\": self.category,\n            \"description\": self.description,\n            \"definition\": definition.model_dump(),\n            \"defaultValues\": default_values\n        }\n        template = NodeTemplate(**template_dict)\n\n        return template.model_dump()\n    except Exception as e:\n        raise ValueError(f\"Failed to create valid node template from metadata: {e}\")\n</code></pre>"},{"location":"api/python/protocols/#pynodewidget.protocols.NodeMetadata.from_node_class","title":"<code>from_node_class(node_class, type_name=None)</code>  <code>classmethod</code>","text":"<p>Extract metadata from a NodeFactory class.</p> <p>Parameters:</p> Name Type Description Default <code>node_class</code> <code>Type[NodeFactory]</code> <p>Class implementing NodeFactory protocol</p> required <code>type_name</code> <code>Optional[str]</code> <p>Optional custom type name (defaults to class name)</p> <code>None</code> <p>Returns:</p> Type Description <code>NodeMetadata</code> <p>NodeMetadata instance</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If required attributes are missing</p> <code>TypeError</code> <p>If parameters is not a Pydantic BaseModel subclass</p> Source code in <code>pynodewidget/protocols.py</code> <pre><code>@classmethod\ndef from_node_class(cls, node_class: Type[NodeFactory], type_name: Optional[str] = None) -&gt; \"NodeMetadata\":\n    \"\"\"Extract metadata from a NodeFactory class.\n\n    Args:\n        node_class: Class implementing NodeFactory protocol\n        type_name: Optional custom type name (defaults to class name)\n\n    Returns:\n        NodeMetadata instance\n\n    Raises:\n        AttributeError: If required attributes are missing\n        TypeError: If parameters is not a Pydantic BaseModel subclass\n    \"\"\"\n    # Validate required attributes\n    if not hasattr(node_class, 'label'):\n        raise AttributeError(f\"Node class {node_class.__name__} missing required attribute: 'label'\")\n\n    if not hasattr(node_class, 'parameters'):\n        raise AttributeError(f\"Node class {node_class.__name__} missing required attribute: 'parameters'\")\n\n    # Validate parameters is a Pydantic model\n    parameters = node_class.parameters\n    if not (isinstance(parameters, type) and issubclass(parameters, BaseModel)):\n        raise TypeError(\n            f\"Node class {node_class.__name__} 'parameters' must be a Pydantic BaseModel subclass, \"\n            f\"got {type(parameters)}\"\n        )\n\n    # Generate JSON Schema from Pydantic model\n    parameters_schema = parameters.model_json_schema()\n\n    # Extract optional attributes with defaults\n    icon = getattr(node_class, 'icon', '')\n    category = getattr(node_class, 'category', 'general')\n    description = getattr(node_class, 'description', '')\n    grid_layout = getattr(node_class, 'grid_layout', None)\n\n    # Use class name as type_name if not provided\n    if type_name is None:\n        type_name = node_class.__name__\n\n    return cls(\n        type_name=type_name,\n        label=node_class.label,\n        parameters_schema=parameters_schema,\n        icon=icon,\n        category=category,\n        description=description,\n        grid_layout=grid_layout,\n    )\n</code></pre>"},{"location":"api/python/protocols/#overview","title":"Overview","text":"<p>PyNodeWidget uses Protocols to define interfaces for node classes without requiring inheritance. This provides flexibility for creating custom nodes while maintaining type safety.</p>"},{"location":"api/python/protocols/#nodefactory-protocol","title":"NodeFactory Protocol","text":"<p>Defines the interface that node classes must implement to be registered with the widget.</p>"},{"location":"api/python/protocols/#purpose","title":"Purpose","text":"<p>The <code>NodeFactory</code> protocol specifies:</p> <ul> <li>Required attributes: Minimum properties every node must have</li> <li>Optional attributes: Additional customization options</li> <li>Required methods: Functions nodes must implement</li> <li>Optional methods: Extra functionality nodes can provide</li> </ul>"},{"location":"api/python/protocols/#required-attributes","title":"Required Attributes","text":"<p>Every node class must define:</p> <pre><code>from typing import Protocol, ClassVar, Type\nfrom pydantic import BaseModel\n\nclass NodeFactory(Protocol):\n    # Required\n    type: ClassVar[str]  # Unique identifier\n    category: ClassVar[str]  # Organization category\n    label: ClassVar[str]  # Display name\n    FieldsModel: Type[BaseModel]  # Pydantic model for parameters\n</code></pre>"},{"location":"api/python/protocols/#optional-attributes","title":"Optional Attributes","text":"<p>Additional customization:</p> <pre><code>class NodeFactory(Protocol):\n    # Optional\n    description: ClassVar[str]  # Tooltip description\n    icon: ClassVar[str]  # Lucide icon name or emoji\n    color: ClassVar[str]  # Tailwind color class\n\n    # Connection points\n    inputs: ClassVar[list[str]]  # Input handle names\n    outputs: ClassVar[list[str]]  # Output handle names\n\n    # Advanced handle configuration\n    input_specs: ClassVar[list[HandleSpec]]\n    output_specs: ClassVar[list[HandleSpec]]\n\n    # Styling\n    use_custom_header: ClassVar[bool]\n    use_custom_footer: ClassVar[bool]\n    header_class: ClassVar[str]\n    footer_class: ClassVar[str]\n    body_class: ClassVar[str]\n\n    # Validation\n    shadow_on_error: ClassVar[str]\n    errors_at: ClassVar[str]\n</code></pre>"},{"location":"api/python/protocols/#required-methods","title":"Required Methods","text":"<p>Nodes must implement:</p> <pre><code>@classmethod\ndef get_default_values(cls) -&gt; dict:\n    \"\"\"Return default field values.\"\"\"\n    return cls.FieldsModel().model_dump()\n</code></pre>"},{"location":"api/python/protocols/#optional-methods","title":"Optional Methods","text":"<p>Additional functionality:</p> <pre><code>@classmethod\ndef process(cls, inputs: dict, field_values: dict) -&gt; dict:\n    \"\"\"Process node computation.\"\"\"\n    pass\n\n@classmethod\ndef validate_inputs(cls, inputs: dict) -&gt; bool:\n    \"\"\"Validate input data.\"\"\"\n    pass\n\n@classmethod\ndef render_custom_header(cls, field_values: dict) -&gt; str:\n    \"\"\"Generate custom header content.\"\"\"\n    pass\n\n@classmethod\ndef render_custom_footer(cls, field_values: dict) -&gt; str:\n    \"\"\"Generate custom footer content.\"\"\"\n    pass\n</code></pre>"},{"location":"api/python/protocols/#handlespec","title":"HandleSpec","text":"<p>Pydantic model for defining connection point specifications.</p>"},{"location":"api/python/protocols/#fields","title":"Fields","text":"<pre><code>class HandleSpec(BaseModel):\n    name: str  # Handle identifier\n    label: str  # Display name\n    type: Literal[\"base\", \"button\", \"labeled\"] = \"base\"  # Visual style\n    position: Literal[\"left\", \"right\", \"top\", \"bottom\"] = \"left\"  # Location\n    color: str = \"gray\"  # Tailwind color\n    icon: str | None = None  # Lucide icon name\n    description: str | None = None  # Tooltip\n</code></pre>"},{"location":"api/python/protocols/#usage","title":"Usage","text":"<pre><code>from pynodeflow.protocols import HandleSpec\n\ninput_specs = [\n    HandleSpec(\n        name=\"data\",\n        label=\"Data Input\",\n        type=\"labeled\",\n        position=\"left\",\n        color=\"blue\",\n        icon=\"database\",\n        description=\"Connect data source\"\n    ),\n    HandleSpec(\n        name=\"trigger\",\n        label=\"Trigger\",\n        type=\"button\",\n        position=\"top\",\n        color=\"green\",\n        icon=\"play\"\n    )\n]\n</code></pre>"},{"location":"api/python/protocols/#handle-types","title":"Handle Types","text":"<p>base: Standard connection point</p> <pre><code>HandleSpec(name=\"input\", label=\"Input\", type=\"base\")\n</code></pre> <p>button: Prominent button-style handle</p> <pre><code>HandleSpec(name=\"execute\", label=\"Execute\", type=\"button\", color=\"green\")\n</code></pre> <p>labeled: Handle with visible label</p> <pre><code>HandleSpec(\n    name=\"data\",\n    label=\"Data\",\n    type=\"labeled\",\n    icon=\"database\"\n)\n</code></pre>"},{"location":"api/python/protocols/#nodemetadata","title":"NodeMetadata","text":"<p>Utility class for extracting metadata from node classes.</p>"},{"location":"api/python/protocols/#purpose_1","title":"Purpose","text":"<p><code>NodeMetadata</code> inspects a node class and:</p> <ul> <li>Extracts all attributes defined by NodeFactory protocol</li> <li>Generates JSON schema from FieldsModel</li> <li>Provides serializable metadata for JavaScript</li> <li>Handles missing optional attributes gracefully</li> </ul>"},{"location":"api/python/protocols/#usage_1","title":"Usage","text":"<pre><code>from pynodeflow.protocols import NodeMetadata\n\nclass MyNode:\n    type = \"my-node\"\n    category = \"data\"\n    label = \"My Node\"\n\n    class FieldsModel(BaseModel):\n        value: int = 0\n\n# Extract metadata\nmetadata = NodeMetadata.from_class(MyNode)\n\n# Serialize to dict\ndata = metadata.model_dump()\n# {\n#     \"type\": \"my-node\",\n#     \"category\": \"data\",\n#     \"label\": \"My Node\",\n#     \"fields_schema\": {...},\n#     \"default_values\": {\"value\": 0},\n#     ...\n# }\n</code></pre>"},{"location":"api/python/protocols/#fields_1","title":"Fields","text":"<p>All attributes from NodeFactory protocol, plus:</p> <pre><code>class NodeMetadata(BaseModel):\n    # Core\n    type: str\n    category: str\n    label: str\n    fields_schema: dict  # JSON Schema from FieldsModel\n    default_values: dict  # From get_default_values()\n\n    # Optional\n    description: str | None\n    icon: str | None\n    color: str | None\n\n    # Handles\n    inputs: list[str]\n    outputs: list[str]\n    input_specs: list[HandleSpec]\n    output_specs: list[HandleSpec]\n\n    # Styling\n    use_custom_header: bool\n    use_custom_footer: bool\n    header_class: str | None\n    footer_class: str | None\n    body_class: str | None\n\n    # Validation\n    shadow_on_error: str | None\n    errors_at: str | None\n</code></pre>"},{"location":"api/python/protocols/#from-class","title":"From Class","text":"<pre><code>metadata = NodeMetadata.from_class(MyNodeClass)\n</code></pre> <p>Extracts all available attributes and generates schema.</p>"},{"location":"api/python/protocols/#to-dict","title":"To Dict","text":"<pre><code>data = metadata.model_dump()\n</code></pre> <p>Returns serializable dictionary suitable for JSON transmission to JavaScript.</p>"},{"location":"api/python/protocols/#creating-nodes-with-protocols","title":"Creating Nodes with Protocols","text":""},{"location":"api/python/protocols/#minimal-node","title":"Minimal Node","text":"<pre><code>from pydantic import BaseModel\n\nclass MinimalNode:\n    \"\"\"Implements required attributes only.\"\"\"\n\n    type = \"minimal\"\n    category = \"basic\"\n    label = \"Minimal Node\"\n\n    class FieldsModel(BaseModel):\n        value: str = \"\"\n\n    @classmethod\n    def get_default_values(cls):\n        return cls.FieldsModel().model_dump()\n</code></pre>"},{"location":"api/python/protocols/#full-featured-node","title":"Full-Featured Node","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodeflow.protocols import HandleSpec\n\nclass FullNode:\n    \"\"\"Implements all protocol attributes.\"\"\"\n\n    # Required\n    type = \"full-node\"\n    category = \"processing\"\n    label = \"Full Node\"\n\n    # Optional metadata\n    description = \"A fully-featured node example\"\n    icon = \"box\"\n    color = \"blue\"\n\n    # Simple handles\n    inputs = [\"input\"]\n    outputs = [\"output\", \"error\"]\n\n    # Advanced handle specs\n    input_specs = [\n        HandleSpec(\n            name=\"input\",\n            label=\"Data Input\",\n            type=\"labeled\",\n            color=\"blue\",\n            icon=\"database\"\n        )\n    ]\n\n    output_specs = [\n        HandleSpec(\n            name=\"output\",\n            label=\"Success\",\n            type=\"labeled\",\n            color=\"green\",\n            icon=\"check\"\n        ),\n        HandleSpec(\n            name=\"error\",\n            label=\"Error\",\n            type=\"labeled\",\n            color=\"red\",\n            icon=\"x-circle\"\n        )\n    ]\n\n    # Styling\n    use_custom_header = True\n    header_class = \"bg-gradient-to-r from-blue-500 to-purple-500\"\n    body_class = \"bg-gray-50\"\n\n    # Validation\n    shadow_on_error = \"xl\"\n    errors_at = \"bottom\"\n\n    # Fields\n    class FieldsModel(BaseModel):\n        threshold: float = Field(0.5, ge=0.0, le=1.0)\n        mode: str = Field(\"auto\", pattern=\"^(auto|manual)$\")\n\n    # Required method\n    @classmethod\n    def get_default_values(cls):\n        return cls.FieldsModel().model_dump()\n\n    # Optional methods\n    @classmethod\n    def process(cls, inputs: dict, field_values: dict):\n        \"\"\"Process input data.\"\"\"\n        data = inputs.get(\"input\")\n        threshold = field_values[\"threshold\"]\n\n        if data is None:\n            return {\"error\": \"No input data\"}\n\n        try:\n            result = data * threshold\n            return {\"output\": result}\n        except Exception as e:\n            return {\"error\": str(e)}\n\n    @classmethod\n    def validate_inputs(cls, inputs: dict):\n        \"\"\"Validate inputs before processing.\"\"\"\n        return \"input\" in inputs and inputs[\"input\"] is not None\n\n    @classmethod\n    def render_custom_header(cls, field_values: dict):\n        \"\"\"Generate custom header HTML.\"\"\"\n        mode = field_values.get(\"mode\", \"auto\")\n        return f'&lt;div class=\"text-white font-bold\"&gt;Mode: {mode.upper()}&lt;/div&gt;'\n</code></pre>"},{"location":"api/python/protocols/#registration","title":"Registration","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\n# Register nodes\nflow.register_node(MinimalNode)\nflow.register_node(FullNode)\n\n# Nodes are now available in the sidebar\n</code></pre>"},{"location":"api/python/protocols/#type-checking","title":"Type Checking","text":"<p>Use protocols for type safety:</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from pynodeflow.protocols import NodeFactory\n\ndef register_custom_node(node_class: type[NodeFactory]):\n    \"\"\"Type-safe node registration.\"\"\"\n    # node_class is guaranteed to have required attributes\n    print(f\"Registering {node_class.label}\")\n\n# Type checker verifies protocol compliance\nregister_custom_node(MinimalNode)  # \u2713 OK\nregister_custom_node(FullNode)  # \u2713 OK\nregister_custom_node(dict)  # \u2717 Type error\n</code></pre>"},{"location":"api/python/protocols/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/python/protocols/#dynamic-handle-specs","title":"Dynamic Handle Specs","text":"<p>Generate handles programmatically:</p> <pre><code>from pynodeflow.protocols import HandleSpec\n\nclass DynamicNode:\n    type = \"dynamic\"\n    category = \"advanced\"\n    label = \"Dynamic Node\"\n\n    @classmethod\n    def get_input_specs(cls, num_inputs: int):\n        \"\"\"Generate input specs dynamically.\"\"\"\n        return [\n            HandleSpec(\n                name=f\"input_{i}\",\n                label=f\"Input {i+1}\",\n                type=\"labeled\",\n                color=\"blue\"\n            )\n            for i in range(num_inputs)\n        ]\n\n    # Set during initialization\n    input_specs: list[HandleSpec] = []\n\n    class FieldsModel(BaseModel):\n        num_inputs: int = Field(2, ge=1, le=10)\n\n    @classmethod\n    def get_default_values(cls):\n        return cls.FieldsModel().model_dump()\n\n# Before registration, configure handles\nDynamicNode.input_specs = DynamicNode.get_input_specs(3)\nflow.register_node(DynamicNode)\n</code></pre>"},{"location":"api/python/protocols/#conditional-handles","title":"Conditional Handles","text":"<p>Show/hide handles based on field values:</p> <pre><code>class ConditionalNode:\n    type = \"conditional\"\n    category = \"advanced\"\n    label = \"Conditional Node\"\n\n    inputs = [\"input\"]\n    outputs = [\"output\"]\n\n    # Additional optional output\n    output_specs = [\n        HandleSpec(name=\"output\", label=\"Output\"),\n        HandleSpec(name=\"debug\", label=\"Debug Output\")\n    ]\n\n    class FieldsModel(BaseModel):\n        enable_debug: bool = False\n\n    @classmethod\n    def get_default_values(cls):\n        return cls.FieldsModel().model_dump()\n\n    @classmethod\n    def process(cls, inputs, field_values):\n        result = {\"output\": inputs.get(\"input\")}\n\n        if field_values.get(\"enable_debug\"):\n            result[\"debug\"] = {\"raw_input\": inputs}\n\n        return result\n</code></pre>"},{"location":"api/python/protocols/#metadata-inspection","title":"Metadata Inspection","text":"<pre><code>from pynodeflow.protocols import NodeMetadata\n\n# Extract metadata\nmetadata = NodeMetadata.from_class(FullNode)\n\n# Inspect fields\nprint(f\"Node type: {metadata.type}\")\nprint(f\"Category: {metadata.category}\")\nprint(f\"Has custom header: {metadata.use_custom_header}\")\n\n# Access schema\nschema = metadata.fields_schema\nprint(f\"Required fields: {schema.get('required', [])}\")\n\n# Get defaults\ndefaults = metadata.default_values\nprint(f\"Default values: {defaults}\")\n\n# Serialize for JavaScript\njs_data = metadata.model_dump()\n</code></pre>"},{"location":"api/python/protocols/#protocol-implementation-checklist","title":"Protocol Implementation Checklist","text":"<p>Use this checklist when creating custom nodes:</p> <p>Required \u2705: - [ ] <code>type: str</code> - Unique identifier - [ ] <code>category: str</code> - Organization category - [ ] <code>label: str</code> - Display name - [ ] <code>FieldsModel: Type[BaseModel]</code> - Pydantic model - [ ] <code>get_default_values()</code> - Returns defaults dict</p> <p>Recommended \ud83d\udcdd: - [ ] <code>description: str</code> - Tooltip text - [ ] <code>icon: str</code> - Visual identifier - [ ] <code>inputs: list[str]</code> or <code>input_specs: list[HandleSpec]</code> - [ ] <code>outputs: list[str]</code> or <code>output_specs: list[HandleSpec]</code></p> <p>Optional \ud83c\udfa8: - [ ] <code>color: str</code> - Tailwind color class - [ ] <code>use_custom_header: bool</code> + <code>render_custom_header()</code> - [ ] <code>use_custom_footer: bool</code> + <code>render_custom_footer()</code> - [ ] <code>header_class: str</code> - Header styling - [ ] <code>body_class: str</code> - Body styling - [ ] <code>footer_class: str</code> - Footer styling - [ ] <code>shadow_on_error: str</code> - Error shadow size - [ ] <code>errors_at: str</code> - Error position</p> <p>Functional \u2699\ufe0f: - [ ] <code>process()</code> - Computation logic - [ ] <code>validate_inputs()</code> - Input validation</p>"},{"location":"api/python/protocols/#examples","title":"Examples","text":""},{"location":"api/python/protocols/#data-processing-node","title":"Data Processing Node","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodeflow.protocols import HandleSpec\n\nclass DataProcessor:\n    type = \"data-processor\"\n    category = \"data\"\n    label = \"Data Processor\"\n    description = \"Process and transform data\"\n    icon = \"cpu\"\n\n    input_specs = [\n        HandleSpec(name=\"data\", label=\"Data\", type=\"labeled\", color=\"blue\")\n    ]\n    output_specs = [\n        HandleSpec(name=\"result\", label=\"Result\", type=\"labeled\", color=\"green\")\n    ]\n\n    class FieldsModel(BaseModel):\n        operation: str = Field(\"multiply\", pattern=\"^(multiply|divide|add|subtract)$\")\n        factor: float = Field(1.0, description=\"Operation factor\")\n\n    @classmethod\n    def get_default_values(cls):\n        return cls.FieldsModel().model_dump()\n\n    @classmethod\n    def process(cls, inputs, field_values):\n        data = inputs.get(\"data\", 0)\n        operation = field_values[\"operation\"]\n        factor = field_values[\"factor\"]\n\n        if operation == \"multiply\":\n            result = data * factor\n        elif operation == \"divide\":\n            result = data / factor if factor != 0 else 0\n        elif operation == \"add\":\n            result = data + factor\n        else:  # subtract\n            result = data - factor\n\n        return {\"result\": result}\n</code></pre>"},{"location":"api/python/protocols/#visualization-node","title":"Visualization Node","text":"<pre><code>class ChartNode:\n    type = \"chart\"\n    category = \"visualization\"\n    label = \"Chart\"\n    description = \"Display data as chart\"\n    icon = \"bar-chart\"\n    color = \"purple\"\n\n    inputs = [\"data\"]\n\n    use_custom_footer = True\n    footer_class = \"bg-purple-100 p-2\"\n\n    class FieldsModel(BaseModel):\n        chart_type: str = Field(\"bar\", pattern=\"^(bar|line|pie)$\")\n        title: str = \"Data Visualization\"\n\n    @classmethod\n    def get_default_values(cls):\n        return cls.FieldsModel().model_dump()\n\n    @classmethod\n    def render_custom_footer(cls, field_values):\n        title = field_values.get(\"title\", \"Chart\")\n        chart_type = field_values.get(\"chart_type\", \"bar\")\n        return f'&lt;div class=\"text-sm\"&gt;\ud83d\udcca {title} ({chart_type})&lt;/div&gt;'\n</code></pre>"},{"location":"api/python/protocols/#see-also","title":"See Also","text":"<ul> <li>Creating Custom Nodes: Guide on building nodes</li> <li>JsonSchemaNodeWidget: Base class implementing protocol</li> <li>Handle Configuration: Working with HandleSpec</li> </ul>"},{"location":"api/python/widget/","title":"NodeFlowWidget","text":"<p>The main widget for creating and managing interactive node-based workflows in Jupyter notebooks.</p>"},{"location":"api/python/widget/#pynodewidget.widget.NodeFlowWidget","title":"<code>NodeFlowWidget(height='600px', **kwargs)</code>","text":"<p>               Bases: <code>AnyWidget</code></p> <p>A Jupyter widget wrapping ReactFlow for interactive node graph visualization.</p> <p>This widget can be initialized with a list of node classes that implement the NodeFactory protocol. Node types will be automatically registered and made available in the visual editor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pynodewidget import NodeFlowWidget\n&gt;&gt;&gt; \n&gt;&gt;&gt; class MyNode(JsonSchemaNodeWidget):\n...     label = \"My Node\"\n...     parameters = MyParams\n&gt;&gt;&gt; \n&gt;&gt;&gt; flow = NodeFlowWidget(\n...     nodes=[MyNode],\n...     height=\"800px\"\n... )\n</code></pre> <p>Initialize the NodeFlowWidget.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>str</code> <p>Height of the widget canvas (default: \"600px\")</p> <code>'600px'</code> <code>**kwargs</code> <code>Any</code> <p>Additional widget configuration options</p> <code>{}</code> Source code in <code>pynodewidget/widget.py</code> <pre><code>def __init__(self, height: str = \"600px\", **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the NodeFlowWidget.\n\n    Args:\n        height: Height of the widget canvas (default: \"600px\")\n        **kwargs: Additional widget configuration options\n    \"\"\"\n    super().__init__(**kwargs)\n    self.height = height\n    self._export_id = 0\n    self._pending_exports = {}  # Maps export_id -&gt; filename\n\n    # Set up persistent observer for image data\n    self.observe(self._on_image_data_received, names=['_export_image_data'])\n</code></pre>"},{"location":"api/python/widget/#pynodewidget.widget.NodeFlowWidget.export_json","title":"<code>export_json(filename='flow.json')</code>","text":"<p>Export the current flow to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output filename</p> <code>'flow.json'</code> Source code in <code>pynodewidget/widget.py</code> <pre><code>def export_json(self, filename: str = \"flow.json\") -&gt; str:\n    \"\"\"Export the current flow to a JSON file.\n\n    Args:\n        filename: Output filename\n    \"\"\"\n    data = {\n        \"nodes\": self.nodes,\n        \"edges\": self.edges,\n        \"viewport\": self.viewport,\n        \"node_templates\": self.node_templates,\n        \"node_values\": dict(self.node_values)\n    }\n\n    with open(filename, 'w') as f:\n        json.dump(data, f, indent=2)\n\n    print(f\"\u2713 Flow exported to {filename}\")\n    return filename\n</code></pre>"},{"location":"api/python/widget/#pynodewidget.widget.NodeFlowWidget.clear","title":"<code>clear()</code>","text":"<p>Clear all nodes and edges.</p> Source code in <code>pynodewidget/widget.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all nodes and edges.\"\"\"\n    self.nodes = {}  # Empty dict instead of list\n    self.edges = []\n    self.node_values = {}  # Clear values too\n    return self\n</code></pre>"},{"location":"api/python/widget/#pynodewidget.widget.NodeFlowWidget.get_flow_data","title":"<code>get_flow_data()</code>","text":"<p>Get the current flow data as a dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with nodes and edges</p> Source code in <code>pynodewidget/widget.py</code> <pre><code>def get_flow_data(self) -&gt; Dict[str, Any]:\n    \"\"\"Get the current flow data as a dictionary.\n\n    Returns:\n        Dictionary with nodes and edges\n    \"\"\"\n    return {\n        \"nodes\": self.nodes,\n        \"edges\": self.edges\n    }\n</code></pre>"},{"location":"api/python/widget/#pynodewidget.widget.NodeFlowWidget.add_node_type_from_schema","title":"<code>add_node_type_from_schema(json_schema, type_name, label, description='', icon='', grid_layout=None, style=None, _default_values_override=None)</code>","text":"<p>Add a node type from a JSON schema with grid layout support.</p> <p>Parameters:</p> Name Type Description Default <code>json_schema</code> <code>Dict[str, Any]</code> <p>JSON Schema definition (can be from Pydantic model_json_schema())</p> required <code>type_name</code> <code>str</code> <p>Unique type identifier</p> required <code>label</code> <code>str</code> <p>Display label for the node</p> required <code>description</code> <code>str</code> <p>Description shown in the panel</p> <code>''</code> <code>icon</code> <code>str</code> <p>Unicode emoji or symbol (e.g., \"\ud83d\udd27\", \"\u2699\ufe0f\", \"\ud83d\udcca\")</p> <code>''</code> <code>grid_layout</code> <code>Optional[Dict[str, Any]]</code> <p>Grid layout configuration (use helpers from grid_layouts module).         Can be a dict or a NodeGrid Pydantic model.         If not provided, defaults to vertical layout with JSON schema fields.</p> <code>None</code> <code>style</code> <code>Optional[Dict[str, Any]]</code> <p>Style configuration dict with 'minWidth', 'maxWidth', 'shadow', etc.</p> <code>None</code> <code>_default_values_override</code> <code>Optional[Dict[str, Any]]</code> <p>Internal parameter to override default values extraction</p> <code>None</code> Example <p>from pynodewidget.grid_layouts import create_three_column_grid from pynodewidget.models import BaseHandle, TextField</p> <p>widget.add_node_type_from_schema( ...     json_schema={\"type\": \"object\", \"properties\": {...}}, ...     type_name=\"processor\", ...     label=\"Data Processor\", ...     icon=\"\u2699\ufe0f\", ...     grid_layout=create_three_column_grid( ...         left_components=[BaseHandle(id=\"in1\", label=\"Input\", handle_type=\"input\")], ...         center_components=[TextField(id=\"name\", label=\"Name\")], ...         right_components=[BaseHandle(id=\"out1\", label=\"Output\", handle_type=\"output\")] ...     ) ... )</p> Source code in <code>pynodewidget/widget.py</code> <pre><code>def add_node_type_from_schema(\n    self, \n    json_schema: Dict[str, Any],\n    type_name: str,\n    label: str,\n    description: str = \"\",\n    icon: str = \"\",\n    grid_layout: Optional[Dict[str, Any]] = None,\n    style: Optional[Dict[str, Any]] = None,\n    _default_values_override: Optional[Dict[str, Any]] = None\n):\n    \"\"\"Add a node type from a JSON schema with grid layout support.\n\n    Args:\n        json_schema: JSON Schema definition (can be from Pydantic model_json_schema())\n        type_name: Unique type identifier\n        label: Display label for the node\n        description: Description shown in the panel\n        icon: Unicode emoji or symbol (e.g., \"\ud83d\udd27\", \"\u2699\ufe0f\", \"\ud83d\udcca\")\n        grid_layout: Grid layout configuration (use helpers from grid_layouts module).\n                    Can be a dict or a NodeGrid Pydantic model.\n                    If not provided, defaults to vertical layout with JSON schema fields.\n        style: Style configuration dict with 'minWidth', 'maxWidth', 'shadow', etc.\n        _default_values_override: Internal parameter to override default values extraction\n\n    Example:\n        &gt;&gt;&gt; from pynodewidget.grid_layouts import create_three_column_grid\n        &gt;&gt;&gt; from pynodewidget.models import BaseHandle, TextField\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; widget.add_node_type_from_schema(\n        ...     json_schema={\"type\": \"object\", \"properties\": {...}},\n        ...     type_name=\"processor\",\n        ...     label=\"Data Processor\",\n        ...     icon=\"\u2699\ufe0f\",\n        ...     grid_layout=create_three_column_grid(\n        ...         left_components=[BaseHandle(id=\"in1\", label=\"Input\", handle_type=\"input\")],\n        ...         center_components=[TextField(id=\"name\", label=\"Name\")],\n        ...         right_components=[BaseHandle(id=\"out1\", label=\"Output\", handle_type=\"output\")]\n        ...     )\n        ... )\n    \"\"\"\n    from .grid_layouts import create_vertical_stack_grid, json_schema_to_components\n    from .models import NodeDefinition, NodeTemplate, NodeGrid\n\n    # Initialize default values from schema or override\n    if _default_values_override is not None:\n        default_values = _default_values_override\n    else:\n        default_values = {}\n        if json_schema and \"properties\" in json_schema:\n            for key, prop in json_schema[\"properties\"].items():\n                if \"default\" in prop:\n                    default_values[key] = prop[\"default\"]\n\n    # Use vertical stack grid with JSON schema fields as default if none provided\n    if grid_layout is None:\n        field_components = json_schema_to_components(json_schema, default_values)\n        grid_layout = create_vertical_stack_grid(middle_components=field_components)\n\n    # Convert NodeGrid model to dict if needed\n    if isinstance(grid_layout, NodeGrid):\n        grid_layout = grid_layout.model_dump()\n\n    # Validate that all component IDs are unique\n    try:\n        _validate_unique_component_ids(grid_layout)\n    except ValueError as e:\n        raise ValueError(f\"Invalid grid layout for node type '{type_name}': {e}\")\n\n    # Build NodeDefinition (visual structure only)\n    definition_dict = {\n        \"grid\": grid_layout\n    }\n\n    # Add optional style configuration\n    if style is not None:\n        definition_dict[\"style\"] = style\n\n    # Validate using Pydantic models\n    try:\n        definition = NodeDefinition(**definition_dict)\n        template_dict = {\n            \"type\": type_name,\n            \"label\": label,\n            \"description\": description,\n            \"icon\": icon,\n            \"definition\": definition.model_dump(),\n            \"defaultValues\": default_values\n        }\n        template = NodeTemplate(**template_dict)\n\n        # Add validated template\n        self.node_templates = self.node_templates + [template.model_dump()]\n    except Exception as e:\n        raise ValueError(f\"Failed to create valid node template: {e}\")\n\n    return self\n</code></pre>"},{"location":"api/python/widget/#overview","title":"Overview","text":"<p><code>NodeFlowWidget</code> is the entry point for creating node-based UIs in Jupyter. It manages:</p> <ul> <li>Node types: Registry of available node classes</li> <li>Graph state: Nodes, edges, and their positions</li> <li>Values: Current parameter values for all nodes</li> <li>Viewport: Canvas position and zoom level</li> </ul>"},{"location":"api/python/widget/#basic-usage","title":"Basic Usage","text":""},{"location":"api/python/widget/#creating-a-widget","title":"Creating a Widget","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\n# Empty widget\nflow = NodeFlowWidget()\n\n# With registered node types\nflow = NodeFlowWidget(nodes=[MyNode1, MyNode2])\n\n# Custom height\nflow = NodeFlowWidget(height=\"800px\")\n</code></pre>"},{"location":"api/python/widget/#registering-node-types","title":"Registering Node Types","text":"<pre><code># Register during initialization\nflow = NodeFlowWidget(nodes=[ProcessorNode, SourceNode])\n\n# Register after creation\nflow.register_node_type(SinkNode)\n\n# Register with custom type name\nflow.register_node_type(MyNode, type_name=\"custom_processor\")\n</code></pre>"},{"location":"api/python/widget/#working-with-values","title":"Working with Values","text":""},{"location":"api/python/widget/#getting-values","title":"Getting Values","text":"<pre><code># Get all values for a node\nvalues = flow.get_node_values(\"node-1\")\n# Returns: {\"threshold\": 0.5, \"enabled\": True}\n\n# Get single value with default\nthreshold = flow.get_node_value(\"node-1\", \"threshold\", default=0.5)\n</code></pre>"},{"location":"api/python/widget/#setting-values","title":"Setting Values","text":"<pre><code># Update single value\nflow.update_node_value(\"node-1\", \"threshold\", 0.8)\n\n# Update multiple values\nflow.set_node_values(\"node-1\", {\n    \"threshold\": 0.8,\n    \"enabled\": False,\n    \"mode\": \"advanced\"\n})\n</code></pre>"},{"location":"api/python/widget/#value-synchronization","title":"Value Synchronization","text":"<p>The <code>node_values</code> trait uses <code>ObservableDict</code> for automatic synchronization:</p> <pre><code># This triggers an update to the JavaScript UI\nflow.node_values[\"node-1\"][\"threshold\"] = 0.8\n\n# Changes in the UI automatically update this dict\nprint(flow.node_values[\"node-1\"][\"threshold\"])\n</code></pre>"},{"location":"api/python/widget/#managing-graph-structure","title":"Managing Graph Structure","text":""},{"location":"api/python/widget/#accessing-nodes-and-edges","title":"Accessing Nodes and Edges","text":"<pre><code># Get all nodes\nnodes = flow.nodes\n# [{\"id\": \"node-1\", \"type\": \"ProcessorNode\", \"position\": {...}, ...}]\n\n# Get all edges\nedges = flow.edges\n# [{\"id\": \"e1-2\", \"source\": \"node-1\", \"target\": \"node-2\", ...}]\n\n# Get specific node data\nnode_data = flow.get_node_data(\"node-1\")\n</code></pre>"},{"location":"api/python/widget/#modifying-graph","title":"Modifying Graph","text":"<pre><code># Add a node programmatically\nflow.nodes = [\n    *flow.nodes,\n    {\n        \"id\": \"new-node\",\n        \"type\": \"ProcessorNode\",\n        \"position\": {\"x\": 100, \"y\": 100},\n        \"data\": {}\n    }\n]\n\n# Add an edge\nflow.edges = [\n    *flow.edges,\n    {\n        \"id\": \"e-new\",\n        \"source\": \"node-1\",\n        \"target\": \"new-node\",\n        \"sourceHandle\": \"out\",\n        \"targetHandle\": \"in\"\n    }\n]\n\n# Clear everything\nflow.clear()\n</code></pre>"},{"location":"api/python/widget/#import-and-export","title":"Import and Export","text":""},{"location":"api/python/widget/#export-to-file","title":"Export to File","text":"<pre><code># Export complete workflow\nflow.export_json(\"workflow.json\")\n\n# Export returns the filename\nfilename = flow.export_json(\"my_workflow.json\")\nprint(f\"Saved to {filename}\")\n</code></pre> <p>The exported JSON contains:</p> <pre><code>{\n  \"nodes\": [...],\n  \"edges\": [...],\n  \"viewport\": {\"x\": 0, \"y\": 0, \"zoom\": 1},\n  \"node_templates\": [...]\n}\n</code></pre>"},{"location":"api/python/widget/#import-from-file","title":"Import from File","text":"<pre><code># Load workflow\nflow.load_json(\"workflow.json\")\n\n# Method chaining\nflow.clear().load_json(\"workflow.json\")\n</code></pre> <p>Node Types Must Be Registered</p> <p>Before loading a workflow, ensure all node types used in the workflow are registered, or they won't render correctly.</p>"},{"location":"api/python/widget/#export-as-dictionary","title":"Export as Dictionary","text":"<pre><code># Get flow data as dict\nflow_data = flow.get_flow_data()\n# Returns: {\"nodes\": [...], \"edges\": [...]}\n\n# Full export including templates and viewport\nimport json\nfull_export = {\n    \"nodes\": flow.nodes,\n    \"edges\": flow.edges,\n    \"node_templates\": flow.node_templates,\n    \"viewport\": flow.viewport,\n    \"node_values\": dict(flow.node_values)\n}\n</code></pre>"},{"location":"api/python/widget/#traits-synchronized-attributes","title":"Traits (Synchronized Attributes)","text":"<p>These attributes automatically sync between Python and JavaScript:</p>"},{"location":"api/python/widget/#nodes-listdict","title":"<code>nodes: List[Dict]</code>","text":"<p>List of node objects in the graph.</p> <pre><code>flow.nodes = [\n    {\n        \"id\": \"node-1\",\n        \"type\": \"ProcessorNode\",\n        \"position\": {\"x\": 100, \"y\": 50},\n        \"data\": {...}\n    }\n]\n</code></pre>"},{"location":"api/python/widget/#edges-listdict","title":"<code>edges: List[Dict]</code>","text":"<p>List of edge objects connecting nodes.</p> <pre><code>flow.edges = [\n    {\n        \"id\": \"e1-2\",\n        \"source\": \"node-1\",\n        \"target\": \"node-2\",\n        \"sourceHandle\": \"out\",\n        \"targetHandle\": \"in\"\n    }\n]\n</code></pre>"},{"location":"api/python/widget/#node_templates-listdict","title":"<code>node_templates: List[Dict]</code>","text":"<p>Registered node type definitions. Populated by <code>register_node_type()</code>.</p>"},{"location":"api/python/widget/#node_values-observabledict","title":"<code>node_values: ObservableDict</code>","text":"<p>Current parameter values for all nodes, keyed by node ID.</p> <pre><code>flow.node_values = {\n    \"node-1\": {\"threshold\": 0.5, \"enabled\": True},\n    \"node-2\": {\"count\": 10}\n}\n</code></pre>"},{"location":"api/python/widget/#viewport-dict","title":"<code>viewport: Dict</code>","text":"<p>Current viewport position and zoom.</p> <pre><code>flow.viewport = {\"x\": 100, \"y\": 50, \"zoom\": 1.5}\n</code></pre>"},{"location":"api/python/widget/#height-str","title":"<code>height: str</code>","text":"<p>Widget height (CSS value).</p> <pre><code>flow.height = \"800px\"\nflow.height = \"100vh\"\n</code></pre>"},{"location":"api/python/widget/#legacy-methods","title":"Legacy Methods","text":"<p>These methods are provided for backward compatibility:</p>"},{"location":"api/python/widget/#add_node_type_from_schema","title":"<code>add_node_type_from_schema()</code>","text":"<p>Register a node type from a raw JSON schema.</p> <pre><code>flow.add_node_type_from_schema(\n    json_schema={\"type\": \"object\", \"properties\": {...}},\n    type_name=\"processor\",\n    label=\"Processor\",\n    icon=\"\u2699\ufe0f\",\n    inputs=[{\"id\": \"in\", \"label\": \"Input\"}],\n    outputs=[{\"id\": \"out\", \"label\": \"Output\"}]\n)\n</code></pre> <p>Prefer register_node_type()</p> <p>For new code, use <code>register_node_type()</code> with a <code>JsonSchemaNodeWidget</code> subclass instead.</p>"},{"location":"api/python/widget/#add_node_type_from_pydantic","title":"<code>add_node_type_from_pydantic()</code>","text":"<p>Register a node type from a Pydantic model.</p> <pre><code>from pydantic import BaseModel\n\nclass ProcessorParams(BaseModel):\n    threshold: float = 0.5\n\nflow.add_node_type_from_pydantic(\n    model_class=ProcessorParams,\n    type_name=\"processor\",\n    label=\"Processor\",\n    icon=\"\u2699\ufe0f\"\n)\n</code></pre>"},{"location":"api/python/widget/#examples","title":"Examples","text":""},{"location":"api/python/widget/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import NodeFlowWidget, JsonSchemaNodeWidget\n\n# Define parameters\nclass FilterParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0, le=1)\n    enabled: bool = True\n\n# Define node\nclass FilterNode(JsonSchemaNodeWidget):\n    label = \"Filter\"\n    parameters = FilterParams\n    icon = \"\ud83d\udd0d\"\n    inputs = [{\"id\": \"in\", \"label\": \"Data\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Filtered\"}]\n\n    def execute(self, inputs):\n        config = self.get_values()\n        if not config[\"enabled\"]:\n            return {\"out\": inputs[\"in\"]}\n\n        data = inputs[\"in\"]\n        threshold = config[\"threshold\"]\n        return {\"out\": [x for x in data if x &gt;= threshold]}\n\n# Create widget\nflow = NodeFlowWidget(nodes=[FilterNode], height=\"600px\")\n\n# Later: Update values from Python\nflow.update_node_value(\"filter-1\", \"threshold\", 0.8)\n\n# Execute workflow (custom logic)\ndef run_workflow(flow):\n    # Your execution logic here\n    pass\n\n# Export for later use\nflow.export_json(\"filter_workflow.json\")\n</code></pre>"},{"location":"api/python/widget/#multiple-node-types","title":"Multiple Node Types","text":"<pre><code>class SourceNode(JsonSchemaNodeWidget):\n    label = \"Data Source\"\n    parameters = SourceParams\n    outputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n\nclass SinkNode(JsonSchemaNodeWidget):\n    label = \"Data Sink\"\n    parameters = SinkParams\n    inputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n\n# Create comprehensive workflow\nflow = NodeFlowWidget(\n    nodes=[SourceNode, ProcessorNode, SinkNode],\n    height=\"800px\"\n)\n</code></pre>"},{"location":"api/python/widget/#programmatic-graph-construction","title":"Programmatic Graph Construction","text":"<pre><code># Create widget\nflow = NodeFlowWidget(nodes=[MyNode])\n\n# Add nodes programmatically\nflow.nodes = [\n    {\n        \"id\": \"source\",\n        \"type\": \"my_node\",\n        \"position\": {\"x\": 0, \"y\": 0},\n        \"data\": {}\n    },\n    {\n        \"id\": \"processor\",\n        \"type\": \"my_node\",\n        \"position\": {\"x\": 200, \"y\": 0},\n        \"data\": {}\n    }\n]\n\n# Connect them\nflow.edges = [\n    {\n        \"id\": \"e1\",\n        \"source\": \"source\",\n        \"target\": \"processor\",\n        \"sourceHandle\": \"out\",\n        \"targetHandle\": \"in\"\n    }\n]\n\n# Set initial values\nflow.set_node_values(\"processor\", {\"threshold\": 0.7})\n</code></pre>"},{"location":"api/python/widget/#see-also","title":"See Also","text":"<ul> <li>JsonSchemaNodeWidget: Create custom nodes</li> <li>ObservableDict: Auto-syncing dictionary</li> <li>Protocols: Extension protocols</li> </ul>"},{"location":"contributing/building/","title":"Building the Documentation","text":"<p>This guide covers building and previewing the PyNodeWidget documentation locally.</p>"},{"location":"contributing/building/#prerequisites","title":"Prerequisites","text":"<p>Install the documentation dependencies:</p> <pre><code># Using pip\npip install -e \".[docs]\"\n\n# Or install directly\npip install mkdocs mkdocs-material mkdocstrings[python] pymdown-extensions\n</code></pre>"},{"location":"contributing/building/#building-locally","title":"Building Locally","text":""},{"location":"contributing/building/#serve-with-live-reload","title":"Serve with Live Reload","text":"<p>The fastest way to preview documentation during development:</p> <pre><code>mkdocs serve\n</code></pre> <p>This will:</p> <ol> <li>Build the documentation</li> <li>Start a local server at <code>http://127.0.0.1:8000</code></li> <li>Watch for changes and rebuild automatically</li> </ol>"},{"location":"contributing/building/#build-static-site","title":"Build Static Site","text":"<p>Generate the static HTML files:</p> <pre><code>mkdocs build\n</code></pre> <p>Output will be in the <code>site/</code> directory.</p>"},{"location":"contributing/building/#clean-build","title":"Clean Build","text":"<p>Remove the build directory:</p> <pre><code>rm -rf site/\nmkdocs build\n</code></pre>"},{"location":"contributing/building/#project-structure","title":"Project Structure","text":"<pre><code>pynodeflow/\n\u251c\u2500\u2500 mkdocs.yml              # MkDocs configuration\n\u251c\u2500\u2500 docs/                   # Documentation source\n\u2502   \u251c\u2500\u2500 index.md           # Homepage\n\u2502   \u251c\u2500\u2500 getting-started/   # Getting started guides\n\u2502   \u251c\u2500\u2500 guides/            # User guides\n\u2502   \u251c\u2500\u2500 api/               # API reference\n\u2502   \u2502   \u251c\u2500\u2500 python/        # Python API docs\n\u2502   \u2502   \u2514\u2500\u2500 javascript/    # JavaScript API docs\n\u2502   \u251c\u2500\u2500 examples/          # Example documentation\n\u2502   \u251c\u2500\u2500 advanced/          # Advanced topics\n\u2502   \u2514\u2500\u2500 contributing/      # Contributing guides\n\u2514\u2500\u2500 site/                   # Generated output (gitignored)\n</code></pre>"},{"location":"contributing/building/#configuration","title":"Configuration","text":"<p>The documentation is configured in <code>mkdocs.yml</code>:</p> <pre><code>site_name: PyNodeWidget Documentation\ntheme:\n  name: material\n  features:\n    - navigation.tabs\n    - navigation.sections\n    - content.code.copy\n    - search.suggest\n\nplugins:\n  - search\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: google\n            show_source: true\n</code></pre>"},{"location":"contributing/building/#writing-documentation","title":"Writing Documentation","text":""},{"location":"contributing/building/#markdown-files","title":"Markdown Files","text":"<p>Documentation is written in Markdown with extensions:</p> <pre><code># Heading\n\nRegular markdown content.\n\n## Code Blocks\n\n\\`\\`\\`python\nfrom pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\\`\\`\\`\n\n## Admonitions\n\n!!! note \"Note Title\"\n    This is a note.\n\n!!! warning\n    This is a warning.\n\n!!! tip\n    This is a tip.\n</code></pre>"},{"location":"contributing/building/#api-documentation","title":"API Documentation","text":"<p>API docs use mkdocstrings to generate from docstrings:</p> <pre><code># NodeFlowWidget\n\n::: pynodewidget.widget.NodeFlowWidget\n    options:\n      show_source: true\n      members:\n        - __init__\n        - register_node_type\n</code></pre>"},{"location":"contributing/building/#cross-references","title":"Cross-References","text":"<p>Link to other pages:</p> <pre><code>See [NodeFlowWidget](../api/python/widget.md) for details.\n</code></pre>"},{"location":"contributing/building/#extensions-enabled","title":"Extensions Enabled","text":""},{"location":"contributing/building/#code-highlighting","title":"Code Highlighting","text":"<p>Syntax highlighting for many languages:</p> <pre><code>```python\n# Python code\n```\n\n```typescript\n// TypeScript code\n```\n\n```bash\n# Shell commands\n```\n</code></pre>"},{"location":"contributing/building/#tabs","title":"Tabs","text":"<p>Group related content:</p> <pre><code>=== \"Python\"\n    ```python\n    from pynodewidget import NodeFlowWidget\n    ```\n\n=== \"JavaScript\"\n    ```typescript\n    import { fieldRegistry } from 'pynodewidget';\n    ```\n</code></pre>"},{"location":"contributing/building/#admonitions","title":"Admonitions","text":"<pre><code>!!! note\n    Information note\n\n!!! warning\n    Warning message\n\n!!! danger\n    Critical warning\n\n!!! tip\n    Helpful tip\n\n!!! example\n    Example usage\n</code></pre>"},{"location":"contributing/building/#diagrams","title":"Diagrams","text":"<p>Mermaid diagrams:</p> <pre><code>```mermaid\ngraph LR\n    A[Python] --&gt; B[AnyWidget]\n    B --&gt; C[JavaScript]\n```\n</code></pre>"},{"location":"contributing/building/#deploying","title":"Deploying","text":""},{"location":"contributing/building/#github-pages","title":"GitHub Pages","text":"<p>Deploy to GitHub Pages:</p> <pre><code>mkdocs gh-deploy\n</code></pre> <p>This will:</p> <ol> <li>Build the documentation</li> <li>Push to the <code>gh-pages</code> branch</li> <li>Make it available at <code>https://username.github.io/pynodeflow/</code></li> </ol>"},{"location":"contributing/building/#manual-deployment","title":"Manual Deployment","text":"<p>Build and deploy manually:</p> <pre><code># Build\nmkdocs build\n\n# Deploy to your hosting\nrsync -av site/ user@server:/var/www/docs/\n</code></pre>"},{"location":"contributing/building/#continuous-integration","title":"Continuous Integration","text":""},{"location":"contributing/building/#github-actions","title":"GitHub Actions","text":"<p>Create <code>.github/workflows/docs.yml</code>:</p> <pre><code>name: Deploy Documentation\n\non:\n  push:\n    branches: [main]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.12'\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[docs]\"\n\n      - name: Deploy docs\n        run: mkdocs gh-deploy --force\n</code></pre>"},{"location":"contributing/building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/building/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 8000 is busy:</p> <pre><code>mkdocs serve -a 127.0.0.1:8001\n</code></pre>"},{"location":"contributing/building/#module-not-found","title":"Module Not Found","text":"<p>Ensure PyNodeWidget is installed:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"contributing/building/#build-warnings","title":"Build Warnings","text":"<p>Check for broken links:</p> <pre><code>mkdocs build --strict\n</code></pre> <p>This treats warnings as errors.</p>"},{"location":"contributing/building/#theme-issues","title":"Theme Issues","text":"<p>If the Material theme doesn't load:</p> <pre><code>pip install --upgrade mkdocs-material\n</code></pre>"},{"location":"contributing/building/#tips","title":"Tips","text":""},{"location":"contributing/building/#live-preview","title":"Live Preview","text":"<p>Keep <code>mkdocs serve</code> running while editing for instant preview of changes.</p>"},{"location":"contributing/building/#search","title":"Search","text":"<p>The search plugin indexes all content. Test it after building.</p>"},{"location":"contributing/building/#mobile-preview","title":"Mobile Preview","text":"<p>Material theme is responsive. Test on mobile:</p> <pre><code>mkdocs serve -a 0.0.0.0:8000\n</code></pre> <p>Then access from mobile device on same network.</p>"},{"location":"contributing/building/#performance","title":"Performance","text":"<p>For large documentation:</p> <pre><code># Build with minification\nmkdocs build --clean\n\n# Serve without live reload\nmkdocs serve --no-livereload\n</code></pre>"},{"location":"contributing/building/#next-steps","title":"Next Steps","text":"<ul> <li>Contributing Guide: Contribute to docs</li> <li>Documentation Standards: Style guide</li> </ul>"},{"location":"contributing/development/","title":"Development Setup","text":"<p>This guide covers setting up a development environment for contributing to PyNodeWidget.</p>"},{"location":"contributing/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+: Core runtime</li> <li>uv: Fast Python package manager (recommended)</li> <li>Bun: JavaScript bundler for building frontend assets</li> <li>Git: Version control</li> </ul>"},{"location":"contributing/development/#initial-setup","title":"Initial Setup","text":""},{"location":"contributing/development/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/HenningScheufler/pynodewidget.git\ncd pynodewidget\n</code></pre>"},{"location":"contributing/development/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Using <code>uv</code> (recommended):</p> <pre><code># Install Python dependencies\nuv sync\n\n# Install development dependencies\nuv pip install -e \".[dev,docs]\"\n\n# Install documentation dependencies separately if needed\nuv pip install mkdocs mkdocs-material 'mkdocstrings[python]' pymdown-extensions\n</code></pre> <p>Using <code>pip</code>:</p> <pre><code>pip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"contributing/development/#3-build-javascript-assets","title":"3. Build JavaScript Assets","text":"<pre><code>cd js\nbun install\nbun run build\ncd ..\n</code></pre>"},{"location":"contributing/development/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/development/#javascript-development","title":"JavaScript Development","text":"<p>For frontend development with hot reload:</p> <pre><code>cd js\nbun run dev\n</code></pre> <p>This starts Vite in development mode with hot module replacement.</p>"},{"location":"contributing/development/#building-javascript","title":"Building JavaScript","text":"<pre><code>cd js\nbun run build\n</code></pre> <p>Built assets are automatically copied to <code>src/pynodewidget/static/</code>.</p>"},{"location":"contributing/development/#python-development","title":"Python Development","text":"<p>The package is installed in editable mode, so changes to Python files are immediately available:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\n# Your changes are live\nflow = NodeFlowWidget()\n</code></pre>"},{"location":"contributing/development/#testing-your-changes","title":"Testing Your Changes","text":"<p>In a Jupyter notebook:</p> <pre><code>from pynodewidget import NodeFlowWidget, JsonSchemaNodeWidget\n\n# Test your changes\nflow = NodeFlowWidget()\nflow\n</code></pre>"},{"location":"contributing/development/#documentation","title":"Documentation","text":""},{"location":"contributing/development/#serving-documentation-locally","title":"Serving Documentation Locally","text":"<p>With taskipy (recommended):</p> <pre><code># Start live documentation server\ntask docs-serve\n</code></pre> <p>Or directly:</p> <pre><code>mkdocs serve\n</code></pre> <p>Visit http://127.0.0.1:8000 to view the documentation. Changes to markdown files are reflected automatically.</p>"},{"location":"contributing/development/#building-documentation","title":"Building Documentation","text":"<p>With taskipy:</p> <pre><code># Build static documentation\ntask docs-build\n\n# Clean build directory\ntask docs-clean\n</code></pre> <p>Or directly:</p> <pre><code>mkdocs build\nrm -rf site/  # clean\n</code></pre>"},{"location":"contributing/development/#testing-documentation-build","title":"Testing Documentation Build","text":"<p>Ensure documentation builds without errors:</p> <pre><code>mkdocs build --strict\n</code></pre> <p>The <code>--strict</code> flag treats warnings as errors.</p>"},{"location":"contributing/development/#deploying-documentation","title":"Deploying Documentation","text":"<p>With taskipy:</p> <pre><code># Deploy to GitHub Pages\ntask docs-deploy\n</code></pre> <p>Or directly:</p> <pre><code>mkdocs gh-deploy --force\n</code></pre>"},{"location":"contributing/development/#available-tasks","title":"Available Tasks","text":"<p>PyNodeWidget uses taskipy for common development tasks:</p> <pre><code># Testing\ntask test            # Run all tests (Python + JavaScript)\ntask test-py         # Run Python tests with pytest\ntask test-js         # Run JavaScript tests with Vitest\n\n# Documentation\ntask docs-serve      # Start documentation server with live reload\ntask docs-build      # Build static documentation site\n\n# View all tasks\ntask --list\n</code></pre> <p>Tasks are defined in <code>pyproject.toml</code> under <code>[tool.taskipy.tasks]</code>:</p> <pre><code>[tool.taskipy.tasks]\ndocs-serve = \"mkdocs serve\"\ndocs-build = \"mkdocs build\"\ntest-py = \"pytest\"\ntest-js = \"bun --cwd=js run test\"\ntest = \"task test-py &amp;&amp; task test-js\"\n</code></pre>"},{"location":"contributing/development/#project-structure","title":"Project Structure","text":"<pre><code>pynodeflow/\n\u251c\u2500\u2500 src/pynodewidget/          # Python package\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 widget.py            # Main widget\n\u2502   \u251c\u2500\u2500 json_schema_node.py  # Node base class\n\u2502   \u251c\u2500\u2500 node_builder.py      # Configuration helpers\n\u2502   \u251c\u2500\u2500 observable_dict.py   # Auto-sync dictionary\n\u2502   \u251c\u2500\u2500 protocols.py         # Extension protocols\n\u2502   \u2514\u2500\u2500 static/              # Built JavaScript assets\n\u251c\u2500\u2500 js/                      # JavaScript/TypeScript source\n\u2502   \u251c\u2500\u2500 src/                 # React components\n\u2502   \u251c\u2500\u2500 dev/                 # Development app\n\u2502   \u251c\u2500\u2500 tests/               # JavaScript tests\n\u2502   \u2514\u2500\u2500 package.json\n\u251c\u2500\u2500 docs/                    # Documentation source\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 getting-started/\n\u2502   \u251c\u2500\u2500 guides/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 examples/\n\u251c\u2500\u2500 tests/                   # Python tests\n\u251c\u2500\u2500 examples/                # Example notebooks and scripts\n\u251c\u2500\u2500 pyproject.toml          # Python package config\n\u251c\u2500\u2500 mkdocs.yml              # Documentation config\n\u2514\u2500\u2500 hatch_build.py          # Custom build hook\n</code></pre>"},{"location":"contributing/development/#running-tests","title":"Running Tests","text":"<p>PyNodeWidget has comprehensive test suites for both Python and JavaScript. Use taskipy for convenient task running.</p>"},{"location":"contributing/development/#all-tests","title":"All Tests","text":"<p>Run both Python and JavaScript tests:</p> <pre><code>task test\n</code></pre> <p>This executes <code>test-py</code> followed by <code>test-js</code>.</p>"},{"location":"contributing/development/#python-tests","title":"Python Tests","text":"<p>Run Python tests with pytest:</p> <pre><code>task test-py\n</code></pre> <p>or use pytest directly</p>"},{"location":"contributing/development/#javascript-tests","title":"JavaScript Tests","text":"<p>Run JavaScript/TypeScript tests with Vitest:</p> <pre><code># Using taskipy (recommended)\ntask test-js\n\n# Or directly\ncd js\nbun run test\n</code></pre>"},{"location":"contributing/development/#code-style","title":"Code Style","text":""},{"location":"contributing/development/#python","title":"Python","text":"<p>We follow PEP 8 with some modifications. Format code with:</p> <pre><code># If using black\nblack src/ tests/\n\n# If using ruff\nruff format src/ tests/\n</code></pre>"},{"location":"contributing/development/#javascripttypescript","title":"JavaScript/TypeScript","text":"<p>Format with Prettier:</p> <pre><code>cd js\nbun run format\n</code></pre> <p>Lint with ESLint:</p> <pre><code>cd js\nbun run lint\n</code></pre>"},{"location":"contributing/development/#building-the-package","title":"Building the Package","text":""},{"location":"contributing/development/#development-build","title":"Development Build","text":"<pre><code># Install in editable mode\nuv pip install -e .\n</code></pre>"},{"location":"contributing/development/#production-build","title":"Production Build","text":"<pre><code># Build JavaScript first\ncd js &amp;&amp; bun run build &amp;&amp; cd ..\n\n# Build Python package\nuv build\n\n# Or with hatchling\npython -m build\n</code></pre> <p>The build process:</p> <ol> <li>Runs <code>hatch_build.py</code> custom hook</li> <li>Builds JavaScript assets if needed</li> <li>Copies built assets to <code>src/pynodewidget/static/</code></li> <li>Creates wheel and sdist</li> </ol>"},{"location":"contributing/development/#tips","title":"Tips","text":""},{"location":"contributing/development/#fast-iteration","title":"Fast Iteration","text":"<p>For rapid development:</p> <ol> <li>Keep <code>mkdocs serve</code> running for documentation</li> <li>Use <code>bun run dev</code> for JavaScript hot reload</li> <li>Use Jupyter's <code>%autoreload</code> for Python:</li> </ol> <pre><code>%load_ext autoreload\n%autoreload 2\n\nfrom pynodewidget import NodeFlowWidget\n</code></pre>"},{"location":"contributing/development/#debugging","title":"Debugging","text":"<p>Enable verbose logging:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre> <p>Inspect widget state:</p> <pre><code>flow = NodeFlowWidget()\nprint(flow.nodes)\nprint(flow.edges)\nprint(flow.node_values)\n</code></pre>"},{"location":"contributing/development/#clean-slate","title":"Clean Slate","text":"<p>Start fresh:</p> <pre><code># Clean Python\nrm -rf src/pynodewidget/__pycache__\nrm -rf src/pynodewidget/static/*\n\n# Clean JavaScript\ncd js\nrm -rf node_modules dist\nbun install\nbun run build\ncd ..\n\n# Reinstall\nuv pip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"contributing/development/#common-issues","title":"Common Issues","text":""},{"location":"contributing/development/#widget-not-updating","title":"Widget Not Updating","text":"<p>If the widget doesn't reflect your changes:</p> <ol> <li>Rebuild JavaScript: <code>cd js &amp;&amp; bun run build</code></li> <li>Restart Jupyter kernel</li> <li>Check <code>src/pynodewidget/static/</code> contains latest files</li> </ol>"},{"location":"contributing/development/#import-errors","title":"Import Errors","text":"<p>Ensure package is installed in editable mode:</p> <pre><code>uv pip install -e .\n</code></pre>"},{"location":"contributing/development/#javascript-build-fails","title":"JavaScript Build Fails","text":"<p>Check Bun is installed and up to date:</p> <pre><code>bun --version\nbun upgrade\n</code></pre>"},{"location":"contributing/development/#documentation-not-building","title":"Documentation Not Building","text":"<p>Ensure all dependencies are installed:</p> <pre><code>uv pip install mkdocs mkdocs-material 'mkdocstrings[python]' pymdown-extensions\n</code></pre>"},{"location":"contributing/development/#next-steps","title":"Next Steps","text":"<ul> <li>Running Tests: Learn about the test suite</li> <li>Building Documentation: Documentation development</li> <li>Contributing Guide: How to contribute</li> </ul>"},{"location":"developer/","title":"Developer Guide","text":"<p>Audience</p> <p>This guide is for JavaScript/TypeScript developers who want to:</p> <ul> <li>Understand PyNodeWidget's frontend architecture</li> <li>Contribute to the JavaScript codebase</li> <li>Create custom field types, handles, or components</li> <li>Extend the library with plugins</li> </ul> <p>For Python users: See the User Guide instead.</p> <p>Prerequisites</p> <p>Familiarity with:</p> <ul> <li>React 18+ - Component model, hooks, state management</li> <li>TypeScript - Type system, interfaces, generics</li> <li>ReactFlow - Node graph library fundamentals</li> <li>Valibot - Schema validation library</li> </ul>"},{"location":"developer/#overview","title":"Overview","text":"<p>PyNodeWidget renders interactive node graphs using a three-layer grid system. Python sends JSON schemas, JavaScript renders using React components, and user interactions sync back via AnyWidget.</p>"},{"location":"developer/#core-architecture","title":"Core Architecture","text":"<pre><code>graph LR\n    A[Python JSON] --&gt;|AnyWidget| B[NodeGrid]\n    B --&gt; C[GridRenderer]\n    C --&gt; D[ComponentFactory]\n    D --&gt; E[React Components]\n    E --&gt;|User Input| F[Python]\n\n    style B fill:#e1f5ff\n    style D fill:#fff4e1</code></pre> <p>Key Concepts:</p> <ul> <li>NodeGrid: Defines rows, columns, and cells</li> <li>GridCell: Contains layout and components</li> <li>ComponentType: Discriminated union of all component types</li> <li>NodeTemplate: Immutable blueprint (shared)</li> <li>NodeInstance: Mutable runtime data (per-node)</li> </ul>"},{"location":"developer/#documentation-structure","title":"Documentation Structure","text":""},{"location":"developer/#architecture","title":"Architecture","text":"<p>Start here to understand the system.</p> <ul> <li>Data flow (Python \u2194 JavaScript)</li> <li>Three-layer grid system</li> <li>Core data structures</li> <li>Value synchronization</li> <li>Extension points</li> </ul> <p>Time: 15 minutes</p>"},{"location":"developer/#extension-guide","title":"Extension Guide","text":"<p>Copy-paste recipes for common tasks.</p> <ul> <li>Adding custom field types</li> <li>Adding custom handle types</li> <li>Creating services</li> <li>Building custom hooks</li> <li>Testing extensions</li> </ul> <p>Time: 5-10 minutes per recipe</p>"},{"location":"developer/#javascript-development","title":"JavaScript Development","text":"<p>Setup and build commands.</p> <ul> <li>Environment setup</li> <li>Development workflow</li> <li>Testing</li> <li>Build system</li> <li>Common tasks</li> </ul> <p>Time: 5 minutes</p>"},{"location":"developer/#hooks-reference","title":"Hooks Reference","text":"<p>Available React hooks.</p> <ul> <li>useSetNodeValues</li> <li>useSetNodesDict</li> <li>useAutoLayout</li> <li>useContextMenu</li> <li>useExport</li> </ul> <p>Time: 2 minutes</p>"},{"location":"developer/#quick-start","title":"Quick Start","text":""},{"location":"developer/#1-understand-the-architecture","title":"1. Understand the Architecture","text":"<p>Read Architecture to understand: - How the three-layer grid works - Core data structures (the Essential 5) - Value synchronization patterns</p>"},{"location":"developer/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"<pre><code>cd js\nbun install\nbun run dev\n</code></pre> <p>See JavaScript Development for details.</p>"},{"location":"developer/#3-try-an-extension","title":"3. Try an Extension","text":"<p>Follow a recipe in the Extension Guide: - Add a color picker field - Create a multi-handle component - Build a validation service</p>"},{"location":"developer/#4-explore-the-codebase","title":"4. Explore the Codebase","text":"<p>Key Files: - <code>src/components/ComponentFactory.tsx</code> - Core rendering - <code>src/components/GridRenderer.tsx</code> - Three-layer system - <code>src/utils/NodeComponentBuilder.tsx</code> - Schema \u2192 Component - <code>src/types/schema.ts</code> - TypeScript types</p>"},{"location":"developer/#when-to-use-this-guide","title":"When to Use This Guide","text":"If you want to... Start here... Understand how it works Architecture Add a custom field Extension Guide \u2192 Custom Field Types Add a custom handle Extension Guide \u2192 Custom Handle Types Set up development JavaScript Development Use a hook Hooks Reference Debug Python \u2194 JS sync Architecture \u2192 Value Synchronization Contribute code JavaScript Development + Extension Guide"},{"location":"developer/#development-vs-user-documentation","title":"Development vs. User Documentation","text":"<p>Choose the Right Guide</p> <ul> <li>New to PyNodeWidget? Start with the User Guide (Python-only)</li> <li>Building nodes in Python? See Creating Custom Nodes</li> <li>Need to extend the JavaScript side? You're in the right place!</li> </ul>"},{"location":"developer/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: Report bugs or request features</li> <li>Architecture questions: Read Architecture first</li> <li>How-to questions: Check Extension Guide recipes</li> <li>Code examples: See <code>js/dev/DevApp.tsx</code> and <code>examples/</code></li> </ul>"},{"location":"developer/#contributing","title":"Contributing","text":"<p>We welcome contributions! Before starting:</p> <ol> <li>Read Architecture to understand the system</li> <li>Set up your environment: JavaScript Development</li> <li>Follow patterns in Extension Guide</li> <li>Add tests (see Testing section in JavaScript Development)</li> <li>Submit a PR</li> </ol> <p>Code Style: - TypeScript with strict mode - Valibot for schemas - Tailwind CSS for styling - Vitest for testing</p> <p>The User Guide is pure Python\u2014no JavaScript knowledge required. The Developer Guide dives into React, TypeScript, bundlers, and the internal APIs.</p>"},{"location":"developer/#quick-reference","title":"Quick Reference","text":""},{"location":"developer/#key-technologies","title":"Key Technologies","text":"<ul> <li>React 18: Frontend framework</li> <li>ReactFlow 12: Node graph visualization</li> <li>TypeScript 5: Type-safe JavaScript</li> <li>Zustand 4: Lightweight state management</li> <li>Bun 1.1+: Fast JavaScript runtime and bundler</li> <li>Vite 5: Development server and build tool</li> <li>AnyWidget 0.9+: Jupyter widget bridge</li> </ul>"},{"location":"developer/#project-structure","title":"Project Structure","text":"<pre><code>js/\n\u251c\u2500\u2500 src/                  # Main source code\n    \u2502   \u251c\u2500\u2500 NodeComponentBuilder.tsx # Node component generator\n\u2502   \u251c\u2500\u2500 NodePanel.tsx            # Node editor panel\n\u2502   \u251c\u2500\u2500 components/              # React components\n\u2502   \u2502   \u251c\u2500\u2500 fields/              # Field type components\n\u2502   \u2502   \u251c\u2500\u2500 handles/             # Handle components\n\u2502   \u2502   \u2514\u2500\u2500 layouts/             # Layout components\n\u2502   \u251c\u2500\u2500 hooks/                   # React hooks\n\u2502   \u251c\u2500\u2500 stores/                  # Zustand state stores\n\u2502   \u251c\u2500\u2500 services/                # Business logic\n\u2502   \u251c\u2500\u2500 types/                   # TypeScript types\n\u2502   \u2514\u2500\u2500 utils/                   # Helper functions\n\u251c\u2500\u2500 dev/                  # Development app\n\u251c\u2500\u2500 tests/                # Vitest unit tests\n\u2514\u2500\u2500 package.json          # Dependencies and scripts\n</code></pre>"},{"location":"developer/#build-targets","title":"Build Targets","text":"<p>PyNodeWidget builds three separate JavaScript bundles:</p> <ol> <li>AnyWidget Bundle (<code>static/json_schema_node_widget.js</code>) - For Jupyter notebooks</li> <li>Standalone Node Editor (<code>static/json_schema_node.js</code>) - For web apps</li> <li>Development Server (<code>dev/app.html</code>) - For local testing</li> </ol>"},{"location":"developer/#contributing_1","title":"Contributing","text":"<p>Found a bug or want to add a feature? See the Contributing Guide for:</p> <ul> <li>Setting up the development environment</li> <li>Running tests (pytest for Python, vitest for JavaScript)</li> <li>Code style guidelines (ruff for Python, prettier/eslint for JavaScript)</li> <li>Pull request process</li> </ul>"},{"location":"developer/#next-steps","title":"Next Steps","text":"<ol> <li>Read the Architecture Overview to understand the system design</li> <li>Set up your dev environment with the JavaScript Development guide</li> <li>Explore the codebase in <code>js/src/</code> with the TypeScript types reference</li> <li>Run the dev server (<code>bun run dev</code>) to see live updates</li> </ol> <p>Work in Progress</p> <p>The API reference sections (Field Registry, Layout System, etc.) are being written. Check back soon or contribute to the documentation!</p>"},{"location":"developer/architecture/","title":"JavaScript Architecture","text":"<p>Focus: Frontend rendering system, data structures, and extension points.</p> <p>For Python API documentation, see the User Guide.</p>"},{"location":"developer/architecture/#data-flow-overview","title":"Data Flow Overview","text":"<pre><code>%%{init: {'theme':'base', 'themeVariables': {'fontSize':'14px'}, 'flowchart':{'nodeSpacing':40, 'rankSpacing':60}}}%%\ngraph LR\n    A[Python JSON] --&gt;|AnyWidget| B[model.get]\n    B --&gt; C[NodeGrid]\n    C --&gt; D[GridRenderer]\n    D --&gt; E[ComponentFactory]\n    E --&gt; F[React Components]\n    F --&gt;|User Input| G[model.set]\n    G --&gt;|AnyWidget| H[Python]\n\n    style C fill:#e1f5ff\n    style E fill:#fff4e1</code></pre> <p>Key Points: - Python sends JSON schemas defining node structure - JavaScript renders using a three-layer grid system - User interactions sync back via AnyWidget - No direct Python code execution in JavaScript</p>"},{"location":"developer/architecture/#three-layer-grid-system","title":"Three-Layer Grid System","text":"<p>The core rendering architecture consists of three independent layers:</p> <pre><code>%%{init: {'theme':'base', 'themeVariables': {'fontSize':'13px'}, 'flowchart':{'nodeSpacing':30, 'rankSpacing':50}}}%%\nflowchart TB\n    subgraph Layer1[Layer 1 - CSS Grid]\n        A[NodeGrid] --&gt; B[rows array]\n        A --&gt; C[columns array]\n        A --&gt; D[cells array]\n    end\n\n    subgraph Layer2[Layer 2 - Cell Layout]\n        D --&gt; E[GridCell]\n        E --&gt; F[coordinates]\n        E --&gt; G[layout type]\n        E --&gt; H[components]\n    end\n\n    subgraph Layer3[Layer 3 - Components]\n        H --&gt; I[TextField]\n        H --&gt; J[NumberField]\n        H --&gt; K[BaseHandle]\n        H --&gt; L[HeaderComponent]\n    end\n\n    style Layer1 fill:#e3f2fd\n    style Layer2 fill:#f3e5f5\n    style Layer3 fill:#e8f5e9</code></pre>"},{"location":"developer/architecture/#layer-1-nodegridrenderer","title":"Layer 1: NodeGridRenderer","text":"<p>Positions cells using CSS Grid.</p> <p>Input: <code>NodeGrid { rows, columns, cells }</code> Output: Positioned grid cells</p> <pre><code>&lt;div style={{\n  display: \"grid\",\n  gridTemplateRows: \"auto 1fr auto\",\n  gridTemplateColumns: \"1fr 1fr\"\n}}&gt;\n  {cells.map(cell =&gt; &lt;GridCell /&gt;)}\n&lt;/div&gt;\n</code></pre>"},{"location":"developer/architecture/#layer-2-gridcellrenderer","title":"Layer 2: GridCellRenderer","text":"<p>Arranges components within each cell using flexbox or nested grid.</p> <p>Input: <code>GridCell { coordinates, layout, components }</code> Output: Laid-out components</p> <pre><code>&lt;div style={{\n  gridRow: `${row} / span ${rowSpan}`,\n  display: layout.type === \"flex\" ? \"flex\" : \"grid\"\n}}&gt;\n  {components.map(c =&gt; &lt;ComponentFactory /&gt;)}\n&lt;/div&gt;\n</code></pre>"},{"location":"developer/architecture/#layer-3-componentfactory","title":"Layer 3: ComponentFactory","text":"<p>Renders individual components based on discriminated union type.</p> <p>Input: <code>ComponentType</code> (union of all component types) Output: React component</p> <pre><code>switch (component.type) {\n  case \"text-field\": return &lt;TextField {...component} /&gt;\n  case \"base-handle\": return &lt;BaseHandle {...component} /&gt;\n  // ...\n}\n</code></pre>"},{"location":"developer/architecture/#component-rendering-pipeline","title":"Component Rendering Pipeline","text":"<pre><code>sequenceDiagram\n    participant P as Python\n    participant M as Model\n    participant NCB as NodeComponentBuilder\n    participant NGR as NodeGridRenderer\n    participant GCR as GridCellRenderer\n    participant CF as ComponentFactory\n    participant R as React\n\n    P-&gt;&gt;M: Send NodeGrid JSON\n    M-&gt;&gt;NCB: buildComponent(grid)\n    NCB-&gt;&gt;NGR: Render grid\n    NGR-&gt;&gt;GCR: Render each cell\n    GCR-&gt;&gt;CF: Render each component\n    CF-&gt;&gt;R: &lt;TextField /&gt; etc\n    R--&gt;&gt;M: User changes value\n    M--&gt;&gt;P: Sync back</code></pre>"},{"location":"developer/architecture/#core-data-structures","title":"Core Data Structures","text":""},{"location":"developer/architecture/#nodegrid-layer-1","title":"NodeGrid (Layer 1)","text":"<p>Defines the overall grid structure.</p> <pre><code>interface NodeGrid {\n  rows: string[];        // e.g., [\"auto\", \"1fr\", \"auto\"]\n  columns: string[];     // e.g., [\"200px\", \"1fr\"]\n  cells: GridCell[];     // Array of cells\n  gap?: string;          // Gap between cells\n}\n</code></pre>"},{"location":"developer/architecture/#gridcell-layer-2","title":"GridCell (Layer 2)","text":"<p>Defines a single cell in the grid.</p> <pre><code>interface GridCell {\n  id: string;\n  coordinates: {\n    row: number;         // Starting row (1-indexed)\n    col: number;         // Starting column (1-indexed)\n    row_span?: number;   // Rows to span\n    col_span?: number;   // Columns to span\n  };\n  layout: CellLayout;    // How to arrange components\n  components: ComponentType[];\n}\n\ninterface CellLayout {\n  type: \"flex\" | \"grid\";\n  direction?: \"row\" | \"column\";\n  gap?: string;\n  // ... flex/grid specific props\n}\n</code></pre>"},{"location":"developer/architecture/#componenttype-layer-3","title":"ComponentType (Layer 3)","text":"<p>Discriminated union of all component types.</p> <pre><code>type ComponentType =\n  | { type: \"text\", id: string, label: string, value?: string }\n  | { type: \"number\", id: string, label: string, value?: number, min?: number, max?: number }\n  | { type: \"bool\", id: string, label: string, value?: boolean }\n  | { type: \"select\", id: string, label: string, value?: string, options: string[] }\n  | { type: \"base-handle\", id: string, handle_type: \"input\" | \"output\", label: string }\n  | { type: \"labeled-handle\", id: string, handle_type: \"input\" | \"output\", label: string }\n  | { type: \"button-handle\", id: string, handle_type: \"input\" | \"output\", label: string }\n  | { type: \"header\", id: string, title: string, icon?: string }\n  | { type: \"grid-layout\", id: string, ...grid: NodeGrid }  // Recursive!\n  | ...\n</code></pre> <p>Key Feature: Type safety via Valibot discriminated unions. Invalid component configurations are caught at runtime and development time.</p>"},{"location":"developer/architecture/#template-vs-instance","title":"Template vs Instance","text":"<pre><code>graph LR\n    subgraph Template[NodeTemplate - Blueprint]\n        T1[type: 'processor']\n        T2[definition: NodeGrid]\n        T3[defaultValues]\n    end\n\n    subgraph Instance1[NodeInstance - Building 1]\n        I1[id: 'proc-1']\n        I2[type: 'processor']\n        I3[values: specific]\n    end\n\n    subgraph Instance2[NodeInstance - Building 2]\n        I4[id: 'proc-2']\n        I5[type: 'processor']\n        I6[values: different]\n    end\n\n    Template -.references.-&gt; Instance1\n    Template -.references.-&gt; Instance2\n\n    style Template fill:#e1f5ff\n    style Instance1 fill:#fff4e1\n    style Instance2 fill:#fff4e1</code></pre> <p>NodeTemplate: Defines structure (immutable, shared) <pre><code>interface NodeTemplate {\n  type: string;                    // Unique type ID\n  label: string;                   // Display name\n  definition: {\n    grid: NodeGrid;                // Visual structure\n    style?: NodeStyleConfig;       // Optional styling\n  };\n  defaultValues: Record&lt;string, any&gt;;\n}\n</code></pre></p> <p>NodeInstance: Runtime data (mutable, per-node) <pre><code>interface NodeInstance {\n  id: string;                      // Unique instance ID\n  type: string;                    // References NodeTemplate.type\n  position: { x: number, y: number };\n  values: Record&lt;string, PrimitiveFieldValue&gt;;\n}\n</code></pre></p>"},{"location":"developer/architecture/#value-synchronization","title":"Value Synchronization","text":"<p>How user input flows from React to Python:</p> <pre><code>sequenceDiagram\n    participant U as User Input\n    participant F as Field Component\n    participant C as Context\n    participant M as Model\n    participant P as Python\n\n    U-&gt;&gt;F: onChange\n    F-&gt;&gt;C: useSetNodeValues\n    C-&gt;&gt;C: Update React state\n    C-&gt;&gt;M: model.set(\"node_values\")\n    M-&gt;&gt;P: Sync via AnyWidget\n    P--&gt;&gt;M: Update (if needed)\n    M--&gt;&gt;C: model.on(\"change\")\n    C--&gt;&gt;F: Re-render</code></pre> <p>Key Pattern: <pre><code>const setValue = useSetNodeValues();\n\n// In field component\nonChange={(e) =&gt; setValue(prev =&gt; ({\n  ...prev,\n  [nodeId]: { \n    ...prev[nodeId], \n    [fieldId]: e.target.value \n  }\n}))}\n</code></pre></p>"},{"location":"developer/architecture/#services","title":"Services","text":"<p>Separate business logic from components.</p>"},{"location":"developer/architecture/#nodelayoutservicets","title":"nodeLayoutService.ts","text":"<p>Handle management and layout operations.</p> <pre><code>export class NodeLayoutService {\n  static updateHandleType(nodes, nodeId, handleId, handleType): Node[]\n  static updateNodeLayout(nodes, nodeId, layoutType): Node[]\n}\n</code></pre>"},{"location":"developer/architecture/#nodedataservicets","title":"nodeDataService.ts","text":"<p>Node data transformations.</p> <pre><code>export class NodeDataService {\n  // Data manipulation methods\n}\n</code></pre> <p>Extension Point: Add custom services by exporting from <code>src/services/</code>.</p>"},{"location":"developer/architecture/#anywidget-communication-patterns","title":"AnyWidget Communication Patterns","text":"<p>Brief overview of Python \u2194 JavaScript interaction.</p>"},{"location":"developer/architecture/#python-javascript","title":"Python \u2192 JavaScript","text":"<pre><code># Python updates trait\nwidget.node_values = {\"node-1\": {\"threshold\": 0.8}}\n</code></pre> <pre><code>// JavaScript receives update\nmodel.on(\"change:node_values\", () =&gt; {\n  const values = model.get(\"node_values\");\n  // Update UI\n});\n</code></pre>"},{"location":"developer/architecture/#javascript-python","title":"JavaScript \u2192 Python","text":"<pre><code>// JavaScript updates model\nmodel.set(\"node_values\", updatedValues);\nmodel.save_changes();\n</code></pre> <pre><code># Python observes change\n@observe(\"node_values\")\ndef _on_values_change(self, change):\n    print(change[\"new\"])\n</code></pre> <p>Key Point: All communication is via JSON-serializable data. No function calls across the boundary.</p>"},{"location":"developer/architecture/#extension-points","title":"Extension Points","text":"<pre><code>graph TD\n    A[Extension Points] --&gt; B[ComponentType]\n    A --&gt; C[Services]\n    A --&gt; D[Hooks]\n\n    B --&gt; B1[1. Define Valibot Schema]\n    B --&gt; B2[2. Create React Component]\n    B --&gt; B3[3. Register in ComponentFactory]\n\n    C --&gt; C1[Export from services/]\n\n    D --&gt; D1[Follow useModelState pattern]\n\n    style A fill:#fff176\n    style B fill:#81c784\n    style C fill:#64b5f6\n    style D fill:#ba68c1</code></pre>"},{"location":"developer/architecture/#adding-components","title":"Adding Components","text":"<ol> <li>Define schema in component file using Valibot</li> <li>Create React component implementing the interface</li> <li>Register in <code>ComponentFactory.tsx</code>:</li> <li>Add schema to <code>ComponentTypeSchema</code> variant</li> <li>Add render case to switch statement</li> </ol> <p>See Extension Guide for detailed recipes.</p>"},{"location":"developer/architecture/#adding-services","title":"Adding Services","text":"<p>Export functions from <code>src/services/yourService.ts</code>, then export from <code>src/index.tsx</code>.</p>"},{"location":"developer/architecture/#custom-hooks","title":"Custom Hooks","text":"<p>Follow the <code>useModelState</code> pattern from <code>@anywidget/react</code> to access model state.</p>"},{"location":"developer/architecture/#component-reference-table","title":"Component Reference Table","text":"Type Purpose Key Props <code>text</code> Text input <code>id, label, value, placeholder</code> <code>number</code> Number input <code>id, label, value, min, max</code> <code>bool</code> Checkbox <code>id, label, value</code> <code>select</code> Dropdown <code>id, label, value, options</code> <code>base-handle</code> Minimal dot handle <code>id, handle_type, label, dataType</code> <code>labeled-handle</code> Handle with text label <code>id, handle_type, label, dataType</code> <code>button-handle</code> Button-styled handle <code>id, handle_type, label, dataType</code> <code>header</code> Node header <code>id, title, icon, show_minimize, show_delete</code> <code>footer</code> Node footer <code>id, text</code> <code>button</code> Button <code>id, label, variant</code> <code>divider</code> Horizontal line <code>id</code> <code>spacer</code> Empty space <code>id, size</code> <code>grid-layout</code> Nested grid <code>id, rows, columns, cells</code> <p>Full schemas: See <code>src/components/ComponentFactory.tsx</code> and individual component files.</p>"},{"location":"developer/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Extension Guide - Copy-paste recipes for adding custom components</li> <li>JavaScript Development - Setup and build commands</li> <li>Hooks Reference - Available React hooks The architecture uses Valibot discriminated unions instead of registries. Components are validated at runtime using schemas defined in each component file.</li> </ul> <p>Example component integration: <pre><code>// 1. Define schema in component file\nexport const TextFieldSchema = v.object({\n  id: v.string(),\n  type: v.literal(\"text\"),\n  label: v.string(),\n  value: v.optional(v.string()),\n  placeholder: v.optional(v.string())\n});\n\n// 2. Add to ComponentFactory discriminated union\nexport const ComponentTypeSchema = v.variant(\"type\", [\n  TextFieldSchema,\n  NumberFieldSchema,\n  // ... other schemas\n]);\n\n// 3. Handle in ComponentFactory switch\nswitch (component.type) {\n  case \"text\":\n    return &lt;StringField component={component} onValueChange={onValueChange} /&gt;;\n  // ...\n}\n</code></pre></p>"},{"location":"developer/architecture/#state-flow","title":"State Flow","text":""},{"location":"developer/architecture/#python-javascript-read","title":"Python \u2192 JavaScript (Read)","text":"<pre><code>sequenceDiagram\n    participant Python\n    participant Traitlet\n    participant AnyWidget\n    participant JSModel as JS Model\n    participant React\n\n    Python-&gt;&gt;Traitlet: flow.nodes = [...]\n    Traitlet-&gt;&gt;Traitlet: Trigger change notification\n    Traitlet-&gt;&gt;AnyWidget: Serialize to JSON\n    AnyWidget-&gt;&gt;JSModel: Send update message\n    JSModel-&gt;&gt;JSModel: model.trigger(\"change:nodes\")\n    JSModel-&gt;&gt;React: useEffect callback\n    React-&gt;&gt;React: Update state and re-render</code></pre>"},{"location":"developer/architecture/#javascript-python-write","title":"JavaScript \u2192 Python (Write)","text":"<pre><code>sequenceDiagram\n    participant UI as User Interaction\n    participant React\n    participant JSModel as JS Model\n    participant AnyWidget\n    participant Traitlet\n    participant Python\n\n    UI-&gt;&gt;React: onChange event\n    React-&gt;&gt;JSModel: model.set(\"node_values\", {...})\n    JSModel-&gt;&gt;JSModel: model.save_changes()\n    JSModel-&gt;&gt;AnyWidget: Send update message\n    AnyWidget-&gt;&gt;Traitlet: Deserialize from JSON\n    Traitlet-&gt;&gt;Traitlet: Trigger change notification\n    Traitlet-&gt;&gt;Python: flow.node_values updated</code></pre>"},{"location":"developer/architecture/#build-process","title":"Build Process","text":""},{"location":"developer/architecture/#javascript-build-js","title":"JavaScript Build (<code>js/</code>)","text":"<pre><code># Development build with watch\nbun run dev\n\n# Production build\nbun run build\n</code></pre> <p>Build Tools: - Bun: Runtime and bundler - Vite: Build tool and dev server - TypeScript: Type checking</p> <p>Output: - <code>js/dist/index.js</code> - Main widget bundle - <code>js/dist/index.css</code> - Styles - <code>js/dist/json_schema_node_entry.js</code> - Standalone node widget - <code>js/dist/json_schema_node_entry.css</code> - Node widget styles</p>"},{"location":"developer/architecture/#python-package-build","title":"Python Package Build","text":"<pre><code>uv build\n</code></pre> <p>Build Hook (<code>hatch_build.py</code>):</p> <pre><code>class CustomBuildHook:\n    def initialize(self, version, build_data):\n        # Build JavaScript if needed\n        if not js_assets_exist():\n            subprocess.run([\"bun\", \"run\", \"build\"], cwd=\"js\")\n\n        # Copy to static/\n        shutil.copy(\"js/dist/index.js\", \"src/pynodewidget/static/\")\n        shutil.copy(\"js/dist/index.css\", \"src/pynodewidget/static/\")\n</code></pre>"},{"location":"developer/architecture/#value-synchronization-details","title":"Value Synchronization Details","text":""},{"location":"developer/architecture/#the-node_values-challenge","title":"The node_values Challenge","text":"<p>Challenge: Python dicts don't trigger observers on nested mutations.</p> <pre><code># This doesn't trigger sync:\nflow.node_values[\"node-1\"][\"threshold\"] = 0.8\n</code></pre> <p>Solution: <code>ObservableDict</code></p> <pre><code>class ObservableDict(MutableMapping):\n    \"\"\"Dict that triggers callback on any mutation.\"\"\"\n\n    def __setitem__(self, key, value):\n        self._data[key] = value\n        self._callback()  # Triggers Traitlet notification\n</code></pre>"},{"location":"developer/architecture/#observabledicttrait","title":"ObservableDictTrait","text":"<p>Custom Traitlet that wraps values in <code>ObservableDict</code>:</p> <pre><code>class ObservableDictTrait(t.Dict):\n    def validate(self, obj, value):\n        if not isinstance(value, ObservableDict):\n            # Wrap in ObservableDict with callback\n            obs_dict = ObservableDict(value, callback=lambda: self._notify_trait(obj))\n            return obs_dict\n        return value\n</code></pre>"},{"location":"developer/architecture/#efficient-updates","title":"Efficient Updates","text":"<p>To minimize sync overhead:</p> <ol> <li> <p>Batch updates when possible: <pre><code>flow.set_node_values(\"node-1\", {\n    \"threshold\": 0.8,\n    \"mode\": \"advanced\",\n    \"enabled\": True\n})\n</code></pre></p> </li> <li> <p>Use update_node_value for single changes: <pre><code>flow.update_node_value(\"node-1\", \"threshold\", 0.8)\n</code></pre></p> </li> </ol>"},{"location":"developer/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"developer/architecture/#python-side","title":"Python Side","text":"<ul> <li>Trait serialization can be expensive for large graphs</li> <li>ObservableDict adds overhead for every mutation</li> <li>Import/export is fast (direct JSON)</li> </ul>"},{"location":"developer/architecture/#javascript-side","title":"JavaScript Side","text":"<ul> <li>ReactFlow handles virtualization automatically</li> <li>React Context provides efficient state updates via <code>useModelState</code> hook</li> <li>React.memo used for expensive components</li> </ul>"},{"location":"developer/architecture/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Minimize sync frequency: Batch updates when possible</li> <li>Use get_flow_data() for bulk reads (doesn't trigger sync)</li> <li>Disable auto-layout for very large graphs</li> <li>Limit number of visible nodes (&lt;100 for best performance)</li> </ol>"},{"location":"developer/architecture/#debugging","title":"Debugging","text":""},{"location":"developer/architecture/#python-side_1","title":"Python Side","text":"<pre><code># Enable logging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Inspect widget state\nprint(flow.nodes)\nprint(flow.edges)\nprint(dict(flow.node_values))\n</code></pre>"},{"location":"developer/architecture/#javascript-side_1","title":"JavaScript Side","text":"<pre><code>// Enable debug mode in browser console\nlocalStorage.setItem(\"debug\", \"pynodeflow:*\");\n\n// Inspect model\nconsole.log(model.get(\"nodes\"));\nconsole.log(model.get(\"node_values\"));\n</code></pre>"},{"location":"developer/architecture/#common-issues","title":"Common Issues","text":"<p>Changes not syncing: - Check if trait is marked <code>.tag(sync=True)</code> - Ensure <code>model.save_changes()</code> is called in JavaScript - Verify <code>ObservableDict</code> is being used for nested values</p> <p>UI not updating: - Check React component subscriptions to model - Verify state updates trigger re-renders - Look for stale closures in useEffect</p>"},{"location":"developer/architecture/#next-steps_1","title":"Next Steps","text":"<ul> <li>JavaScript Development: Contributing to the JavaScript codebase</li> <li>Building from Source: Build process details</li> <li>Testing: Testing both Python and JavaScript</li> </ul>"},{"location":"developer/components/","title":"Component Library","text":"<p>Core React components for building node-based UIs.</p>"},{"location":"developer/components/#nodefactory","title":"NodeFactory","text":"<p>Registry for node type components.</p> <pre><code>import { nodeFactory } from 'pynodewidget';\n\n// Register a node type\nnodeFactory.register(\"custom\", CustomNodeComponent);\n\n// Check if registered\nif (nodeFactory.has(\"custom\")) {\n  const Component = nodeFactory.get(\"custom\");\n}\n\n// Get all node types for ReactFlow\nconst nodeTypes = nodeFactory.getAll();\n\n&lt;ReactFlow nodeTypes={nodeTypes} /&gt;\n</code></pre> <p>Methods: - <code>register(type, component, options?)</code> - Register node component - <code>registerCustom(type, component)</code> - Register custom (non-parameters) node - <code>registerParameters(type, component)</code> - Register parameters-based node - <code>get(type)</code> - Get component for type - <code>has(type)</code> - Check if type exists - <code>getAll()</code> - Get all as <code>Record&lt;string, Component&gt;</code></p>"},{"location":"developer/components/#nodecomponentbuilder","title":"NodeComponentBuilder","text":"<p>Builds optimized React components from schema.</p> <pre><code>import { NodeComponentBuilder } from 'pynodewidget';\n\n// Build component from schema\nconst schema = {\n  label: \"Processor\",\n  layoutType: \"horizontal\",\n  handleType: \"button\",\n  header: { show: true, icon: \"\u2699\ufe0f\" }\n};\n\nconst component = NodeComponentBuilder.buildComponent(schema);\nnodeFactory.register(\"processor\", component);\n</code></pre> <p>Features: - Pre-computes static configuration at build time - Resolves layout/handle components once - Returns memoized components for performance - Validates schema structure with clear errors</p>"},{"location":"developer/components/#nodepanel","title":"NodePanel","text":"<p>Sidebar with draggable node types.</p> <pre><code>import { NodePanel } from 'pynodewidget';\n\n&lt;NodePanel\n  nodeTypes={[\n    { type: \"input\", label: \"Input\", icon: \"\ud83d\udce5\" },\n    { type: \"process\", label: \"Process\", icon: \"\u2699\ufe0f\" },\n    { type: \"output\", label: \"Output\", icon: \"\ud83d\udce4\" }\n  ]}\n  onNodeDragStart={handleDragStart}\n/&gt;\n</code></pre>"},{"location":"developer/components/#flowcanvas","title":"FlowCanvas","text":"<p>Main ReactFlow canvas wrapper with common features.</p> <pre><code>import { FlowCanvas } from 'pynodewidget';\n\n&lt;FlowCanvas\n  nodes={nodes}\n  edges={edges}\n  onNodesChange={onNodesChange}\n  onEdgesChange={onEdgesChange}\n  onConnect={onConnect}\n  nodeTypes={nodeTypes}\n/&gt;\n</code></pre> <p>Includes: minimap, controls, background, connection line.</p>"},{"location":"developer/components/#flowtoolbar","title":"FlowToolbar","text":"<p>Action buttons for common operations.</p> <pre><code>import { FlowToolbar } from 'pynodewidget';\n\n&lt;FlowToolbar\n  onAutoLayout={() =&gt; onLayout(\"TB\")}\n  onExport={exportToJSON}\n  onClear={() =&gt; {\n    setNodes([]);\n    setEdges([]);\n  }}\n/&gt;\n</code></pre>"},{"location":"developer/components/#nodeform","title":"NodeForm","text":"<p>Renders field inputs from JSON schema.</p> <pre><code>import { NodeForm } from 'pynodewidget';\n\n&lt;NodeForm\n  nodeId={node.id}\n  parameters={node.data.parameters}\n  values={values}\n  onValueChange={(field, value) =&gt; updateValue(node.id, field, value)}\n/&gt;\n</code></pre> <p>Uses <code>FieldFactory</code> internally to render appropriate field types.</p>"},{"location":"developer/components/#basehandle-buttonhandle-labeledhandle","title":"BaseHandle, ButtonHandle, LabeledHandle","text":"<p>Handle components from the Handle System.</p> <pre><code>import { BaseHandle, ButtonHandle, LabeledHandle } from 'pynodewidget';\n\n&lt;BaseHandle type=\"target\" position=\"left\" id=\"in\" /&gt;\n&lt;ButtonHandle type=\"source\" position=\"right\" id=\"out\" /&gt;\n&lt;LabeledHandle type=\"target\" position=\"left\" id=\"data\" label=\"Data\" /&gt;\n</code></pre>"},{"location":"developer/components/#contextmenu","title":"ContextMenu","text":"<p>Right-click menu component.</p> <pre><code>import { ContextMenu } from 'pynodewidget';\n\n&lt;ContextMenu\n  x={contextMenu.x}\n  y={contextMenu.y}\n  onDelete={handleDelete}\n  onDuplicate={handleDuplicate}\n  onClose={handleClose}\n/&gt;\n</code></pre>"},{"location":"developer/components/#see-also","title":"See Also","text":"<ul> <li>Hooks API - React hooks</li> <li>State Management - Zustand stores</li> <li>TypeScript Types - Type definitions</li> </ul>"},{"location":"developer/extending/","title":"Extension Guide","text":"<p>Copy-paste recipes for extending PyNodeWidget with custom components, services, and hooks.</p>"},{"location":"developer/extending/#adding-a-custom-field-type","title":"Adding a Custom Field Type","text":"<pre><code>graph LR\n    A[1. Define Schema] --&gt; B[2. Create Component]\n    B --&gt; C[3. Register in Factory]\n    C --&gt; D[4. Use in Grid]\n\n    style A fill:#e3f2fd\n    style B fill:#f3e5f5\n    style C fill:#e8f5e9\n    style D fill:#fff3e0</code></pre>"},{"location":"developer/extending/#step-1-define-valibot-schema","title":"Step 1: Define Valibot Schema","text":"<p>Create <code>src/components/fields/ColorField.tsx</code>:</p> <pre><code>import * as v from \"valibot\";\nimport type { PrimitiveFieldValue } from \"../../types/schema\";\n\nexport const ColorFieldSchema = v.object({\n  id: v.string(),\n  type: v.literal(\"color\"),\n  label: v.string(),\n  value: v.optional(v.string()),\n});\n\nexport type ColorField = v.InferOutput&lt;typeof ColorFieldSchema&gt;;\n</code></pre>"},{"location":"developer/extending/#step-2-create-react-component","title":"Step 2: Create React Component","text":"<pre><code>interface ColorFieldProps {\n  id: string;\n  label: string;\n  value?: string;\n  nodeId: string;\n}\n\nexport function ColorField({ id, label, value, nodeId }: ColorFieldProps) {\n  const setValue = useSetNodeValues();\n\n  return (\n    &lt;div className=\"space-y-1\"&gt;\n      &lt;label className=\"text-sm font-medium\"&gt;{label}&lt;/label&gt;\n      &lt;input\n        type=\"color\"\n        value={value || \"#000000\"}\n        onChange={(e) =&gt; setValue(prev =&gt; ({\n          ...prev,\n          [nodeId]: {\n            ...prev[nodeId],\n            [id]: e.target.value\n          }\n        }))}\n        onMouseDown={(e) =&gt; e.stopPropagation()} // Prevent node dragging\n        className=\"w-full h-10 rounded cursor-pointer\"\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"developer/extending/#step-3-register-in-componentfactory","title":"Step 3: Register in ComponentFactory","text":"<p>Edit <code>src/components/ComponentFactory.tsx</code>:</p> <pre><code>// 1. Import at top\nimport { ColorField, ColorFieldSchema } from \"./fields/ColorField\";\n\n// 2. Add to ComponentTypeSchema variant\nconst BaseComponentTypeSchema = v.variant(\"type\", [\n  BaseHandleSchema,\n  // ... existing schemas\n  ColorFieldSchema,  // Add here\n]);\n\n// 3. Add render case in ComponentFactory\nexport function ComponentFactory({ component, nodeId, onValueChange }: Props) {\n  switch (component.type) {\n    // ... existing cases\n    case \"color\":\n      return &lt;ColorField {...component} nodeId={nodeId} /&gt;;\n\n    default:\n      const _exhaustiveCheck: never = component;\n      console.warn(`Unknown component type: ${(component as ComponentType).type}`);\n      return null;\n  }\n}\n</code></pre>"},{"location":"developer/extending/#step-4-use-in-python","title":"Step 4: Use in Python","text":"<pre><code>from pynodewidget import NodeFlowWidget\nfrom pydantic import BaseModel\n\ngrid = {\n    \"rows\": [\"auto\"],\n    \"columns\": [\"1fr\"],\n    \"cells\": [{\n        \"id\": \"cell-1\",\n        \"coordinates\": {\"row\": 1, \"col\": 1},\n        \"layout\": {\"type\": \"flex\", \"direction\": \"column\"},\n        \"components\": [\n            {\n                \"type\": \"color\",\n                \"id\": \"bg_color\",\n                \"label\": \"Background Color\",\n                \"value\": \"#ff5733\"\n            }\n        ]\n    }]\n}\n\nflow = NodeFlowWidget()\n# Use grid in node template\n</code></pre>"},{"location":"developer/extending/#adding-a-custom-handle-type","title":"Adding a Custom Handle Type","text":""},{"location":"developer/extending/#step-1-define-schema","title":"Step 1: Define Schema","text":"<p>Create <code>src/components/handles/MultiHandle.tsx</code>:</p> <pre><code>import * as v from \"valibot\";\n\nexport const MultiHandleSchema = v.object({\n  id: v.string(),\n  type: v.literal(\"multi-handle\"),\n  handle_type: v.union([v.literal(\"input\"), v.literal(\"output\")]),\n  count: v.number(), // Number of connection points\n  labels: v.optional(v.array(v.string())),\n});\n\nexport type MultiHandle = v.InferOutput&lt;typeof MultiHandleSchema&gt;;\n</code></pre>"},{"location":"developer/extending/#step-2-create-component","title":"Step 2: Create Component","text":"<pre><code>import { Handle, Position } from \"@xyflow/react\";\n\ninterface MultiHandleProps {\n  id: string;\n  handle_type: \"input\" | \"output\";\n  count: number;\n  labels?: string[];\n}\n\nexport function MultiHandle({ \n  id, \n  handle_type, \n  count, \n  labels = []\n}: MultiHandleProps) {\n  const type = handle_type === \"input\" ? \"target\" : \"source\";\n  const position = handle_type === \"input\" ? Position.Left : Position.Right;\n\n  return (\n    &lt;div className=\"flex flex-col gap-2\"&gt;\n      {Array.from({ length: count }).map((_, i) =&gt; (\n        &lt;div key={i} className=\"flex items-center gap-2\"&gt;\n          {handle_type === \"input\" &amp;&amp; (\n            &lt;Handle\n              type=\"target\"\n              position={position}\n              id={`${id}-${i}`}\n              className=\"!w-3 !h-3 !bg-blue-500\"\n            /&gt;\n          )}\n          {labels[i] &amp;&amp; (\n            &lt;span className=\"text-xs\"&gt;{labels[i]}&lt;/span&gt;\n          )}\n          {handle_type === \"output\" &amp;&amp; (\n            &lt;Handle\n              type=\"source\"\n              position={position}\n              id={`${id}-${i}`}\n              className=\"!w-3 !h-3 !bg-green-500\"\n            /&gt;\n          )}\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"developer/extending/#step-3-register","title":"Step 3: Register","text":"<p>Add to <code>ComponentFactory.tsx</code> following the same pattern as custom fields.</p>"},{"location":"developer/extending/#adding-a-custom-service","title":"Adding a Custom Service","text":""},{"location":"developer/extending/#step-1-create-service-file","title":"Step 1: Create Service File","text":"<p>Create <code>src/services/validationService.ts</code>:</p> <pre><code>import type { Node } from \"@xyflow/react\";\nimport type { NodeValues } from \"../types/schema\";\n\nexport class ValidationService {\n  /**\n   * Validate all node values against constraints\n   */\n  static validateNodes(\n    nodes: Node[],\n    values: NodeValues\n  ): Record&lt;string, string[]&gt; {\n    const errors: Record&lt;string, string[]&gt; = {};\n\n    nodes.forEach(node =&gt; {\n      const nodeErrors: string[] = [];\n      const nodeValues = values[node.id] || {};\n\n      // Example: Check required fields\n      const requiredFields = this.getRequiredFields(node);\n      requiredFields.forEach(field =&gt; {\n        if (!nodeValues[field]) {\n          nodeErrors.push(`${field} is required`);\n        }\n      });\n\n      if (nodeErrors.length &gt; 0) {\n        errors[node.id] = nodeErrors;\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Extract required fields from node definition\n   */\n  private static getRequiredFields(node: Node): string[] {\n    // Implementation based on node.data structure\n    return [];\n  }\n}\n</code></pre>"},{"location":"developer/extending/#step-2-export-from-index","title":"Step 2: Export from Index","text":"<p>Edit <code>src/index.tsx</code>:</p> <pre><code>// Add to exports\nexport { ValidationService } from \"./services/validationService\";\n</code></pre>"},{"location":"developer/extending/#step-3-use-in-components","title":"Step 3: Use in Components","text":"<pre><code>import { ValidationService } from \"pynodewidget\";\n\nfunction MyComponent() {\n  const nodes = useNodes();\n  const values = useNodeValues();\n\n  const errors = ValidationService.validateNodes(nodes, values);\n\n  // Use errors for UI feedback\n}\n</code></pre>"},{"location":"developer/extending/#creating-a-custom-hook","title":"Creating a Custom Hook","text":""},{"location":"developer/extending/#basic-pattern","title":"Basic Pattern","text":"<pre><code>// src/hooks/useNodeValidation.ts\nimport { useNodes } from \"@xyflow/react\";\nimport { useNodeValues } from \"../index\";\nimport { ValidationService } from \"../services/validationService\";\n\nexport function useNodeValidation() {\n  const nodes = useNodes();\n  const values = useNodeValues();\n\n  const errors = React.useMemo(() =&gt; {\n    return ValidationService.validateNodes(nodes, values);\n  }, [nodes, values]);\n\n  const isValid = React.useMemo(() =&gt; {\n    return Object.keys(errors).length === 0;\n  }, [errors]);\n\n  return { errors, isValid };\n}\n</code></pre>"},{"location":"developer/extending/#using-model-state","title":"Using Model State","text":"<pre><code>import { useModelState } from \"@anywidget/react\";\n\nexport function useCustomModelData() {\n  const [data] = useModelState&lt;CustomType&gt;(\"custom_trait\");\n\n  // Transform or enhance data\n  const processedData = React.useMemo(() =&gt; {\n    return transformData(data);\n  }, [data]);\n\n  return processedData;\n}\n</code></pre>"},{"location":"developer/extending/#extension-flow-diagram","title":"Extension Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant D as Developer\n    participant S as Valibot Schema\n    participant C as React Component\n    participant F as ComponentFactory\n    participant G as Grid System\n\n    D-&gt;&gt;S: Define ColorFieldSchema\n    D-&gt;&gt;C: Implement ColorField\n    D-&gt;&gt;F: Add to variant()\n    D-&gt;&gt;F: Add to switch case\n    Note over D,F: Build time: Type checking\n    G-&gt;&gt;F: Render \"color-field\"\n    F-&gt;&gt;C: &lt;ColorField /&gt;\n    C--&gt;&gt;G: Rendered component</code></pre>"},{"location":"developer/extending/#best-practices","title":"Best Practices","text":""},{"location":"developer/extending/#type-safety","title":"Type Safety","text":"<p>\u2705 Do: Use Valibot schemas for type safety <pre><code>const MySchema = v.object({\n  type: v.literal(\"my-type\"),\n  // ... fields\n});\n</code></pre></p> <p>\u274c Don't: Use plain objects without validation <pre><code>const component = { type: \"my-type\" }; // No type checking!\n</code></pre></p>"},{"location":"developer/extending/#value-updates","title":"Value Updates","text":"<p>\u2705 Do: Use functional updates <pre><code>setValue(prev =&gt; ({ ...prev, [nodeId]: { ...prev[nodeId], [id]: value } }))\n</code></pre></p> <p>\u274c Don't: Mutate state directly <pre><code>values[nodeId][id] = value; // Doesn't trigger re-render!\n</code></pre></p>"},{"location":"developer/extending/#event-handling","title":"Event Handling","text":"<p>\u2705 Do: Stop propagation for interactive elements <pre><code>&lt;input onMouseDown={(e) =&gt; e.stopPropagation()} /&gt;\n</code></pre></p> <p>\u274c Don't: Let events bubble to ReactFlow <pre><code>&lt;input /&gt; // Will cause node dragging issues\n</code></pre></p>"},{"location":"developer/extending/#performance","title":"Performance","text":"<p>\u2705 Do: Memoize expensive computations <pre><code>const computed = React.useMemo(() =&gt; expensiveOp(data), [data]);\n</code></pre></p> <p>\u274c Don't: Compute on every render <pre><code>const computed = expensiveOp(data); // Runs every render!\n</code></pre></p>"},{"location":"developer/extending/#testing-extensions","title":"Testing Extensions","text":""},{"location":"developer/extending/#component-tests","title":"Component Tests","text":"<pre><code>import { render, screen } from \"@testing-library/react\";\nimport { ColorField } from \"./ColorField\";\n\ndescribe(\"ColorField\", () =&gt; {\n  it(\"renders with default value\", () =&gt; {\n    render(&lt;ColorField id=\"test\" label=\"Color\" nodeId=\"node-1\" /&gt;);\n    expect(screen.getByLabelText(\"Color\")).toBeInTheDocument();\n  });\n\n  it(\"calls onChange when color changes\", () =&gt; {\n    const setValue = vi.fn();\n    // ... test implementation\n  });\n});\n</code></pre>"},{"location":"developer/extending/#service-tests","title":"Service Tests","text":"<pre><code>import { ValidationService } from \"./validationService\";\n\ndescribe(\"ValidationService\", () =&gt; {\n  it(\"validates required fields\", () =&gt; {\n    const nodes = [/* test data */];\n    const values = {/* test data */};\n    const errors = ValidationService.validateNodes(nodes, values);\n    expect(errors).toEqual({/* expected errors */});\n  });\n});\n</code></pre>"},{"location":"developer/extending/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Understand the core system</li> <li>JavaScript Development - Setup and run tests</li> <li>Hooks Reference - Available hooks</li> </ul>"},{"location":"developer/handles/","title":"Handle System API","text":"<p>Customize the appearance and behavior of input/output connection points (handles) on nodes.</p>"},{"location":"developer/handles/#quick-start","title":"Quick Start","text":"<pre><code>import { registerHandle } from 'pynodewidget';\n\n// Register custom handle\nregisterHandle(\"icon\", ({ id, type, position }) =&gt; (\n  &lt;Handle\n    id={id}\n    type={type}\n    position={position}\n    style={{ background: \"#ff0\", width: \"16px\", height: \"16px\" }}\n  &gt;\n    \ud83d\udd0c\n  &lt;/Handle&gt;\n));\n</code></pre> <pre><code># Use in Python\nclass IconNode(JsonSchemaNodeWidget):\n    label = \"Icon Node\"\n    inputs = [{\"id\": \"in\", \"handle_type\": \"icon\"}]\n</code></pre>"},{"location":"developer/handles/#built-in-handle-types","title":"Built-in Handle Types","text":""},{"location":"developer/handles/#base-handle-default","title":"Base Handle (Default)","text":"<p>Simple circular connection point.</p> <pre><code>handle_type = \"base\"  # or omit for default\n</code></pre>"},{"location":"developer/handles/#button-handle","title":"Button Handle","text":"<p>Interactive button that can trigger actions.</p> <pre><code>handle_type = \"button\"\n</code></pre>"},{"location":"developer/handles/#labeled-handle","title":"Labeled Handle","text":"<p>Shows label text next to the handle.</p> <pre><code>inputs = [{\"id\": \"in\", \"label\": \"Input\", \"handle_type\": \"labeled\"}]\n</code></pre>"},{"location":"developer/handles/#api-reference","title":"API Reference","text":"<pre><code>import { registerHandle, getHandle, getAvailableHandles } from 'pynodewidget';\n\n// Register a handle component\nregisterHandle(type: string, component: React.ComponentType&lt;any&gt;): void\n\n// Get a handle component\ngetHandle(type?: HandleType): React.ComponentType&lt;any&gt;\n\n// List all handle types\ngetAvailableHandles(): string[]\n</code></pre>"},{"location":"developer/handles/#custom-handle-example","title":"Custom Handle Example","text":"<pre><code>import { registerHandle } from 'pynodewidget';\nimport { Handle } from '@xyflow/react';\n\nconst PulseHandle: React.FC&lt;any&gt; = (props) =&gt; (\n  &lt;Handle\n    {...props}\n    style={{\n      width: \"12px\",\n      height: \"12px\",\n      background: \"#4CAF50\",\n      animation: \"pulse 2s infinite\",\n    }}\n  /&gt;\n);\n\nregisterHandle(\"pulse\", PulseHandle);\n</code></pre> <p>CSS: <pre><code>@keyframes pulse {\n  0%, 100% { opacity: 1; transform: scale(1); }\n  50% { opacity: 0.5; transform: scale(1.2); }\n}\n</code></pre></p>"},{"location":"developer/handles/#python-integration","title":"Python Integration","text":""},{"location":"developer/handles/#per-handle-configuration","title":"Per-Handle Configuration","text":"<pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass StyledNode(JsonSchemaNodeWidget):\n    label = \"Styled\"\n    inputs = [\n        {\"id\": \"data\", \"label\": \"Data\", \"handle_type\": \"labeled\"},\n        {\"id\": \"trigger\", \"handle_type\": \"button\"}\n    ]\n    outputs = [\n        {\"id\": \"out\", \"handle_type\": \"pulse\"}\n    ]\n</code></pre>"},{"location":"developer/handles/#global-handle-type","title":"Global Handle Type","text":"<pre><code>class AllLabeledNode(JsonSchemaNodeWidget):\n    label = \"All Labeled\"\n    handle_type = \"labeled\"  # \u2705 Apply to all handles\n    inputs = [{\"id\": \"in1\"}, {\"id\": \"in2\"}]\n    outputs = [{\"id\": \"out\"}]\n</code></pre>"},{"location":"developer/handles/#see-also","title":"See Also","text":"<ul> <li>Layout System - Custom node layouts</li> <li>Field Registry - Custom field types</li> <li>Examples - Labeled handles example</li> </ul>"},{"location":"developer/hooks/","title":"Hooks Reference","text":"<p>Available React hooks for working with PyNodeWidget.</p>"},{"location":"developer/hooks/#hook-interactions","title":"Hook Interactions","text":"<pre><code>graph TB\n    subgraph Hooks\n        A[useSetNodeValues]\n        B[useSetNodesDict]\n        C[useAutoLayout]\n        D[useContextMenu]\n        E[useExport]\n    end\n\n    subgraph Contexts\n        F[SetNodeValuesContext]\n        G[SetNodesDictContext]\n        H[NodeDataContext]\n    end\n\n    subgraph Model\n        I[AnyWidget Model]\n    end\n\n    A --&gt; F\n    B --&gt; G\n    F --&gt; I\n    G --&gt; I\n    H --&gt; I\n    C --&gt; B\n    E --&gt; I\n\n    style Hooks fill:#e3f2fd\n    style Contexts fill:#f3e5f5\n    style Model fill:#fff3e0</code></pre>"},{"location":"developer/hooks/#usesetnodevalues","title":"useSetNodeValues","text":"<p>Update field values for nodes.</p> <p>Usage: <pre><code>const setValue = useSetNodeValues();\n\n// Update single field\nsetValue(prev =&gt; ({\n  ...prev,\n  [nodeId]: { ...prev[nodeId], [fieldId]: newValue }\n}));\n</code></pre></p>"},{"location":"developer/hooks/#usesetnodesdict","title":"useSetNodesDict","text":"<p>Update node structure.</p> <p>Usage: <pre><code>const setNodes = useSetNodesDict();\n\nsetNodes(prev =&gt; ({ ...prev, [nodeId]: updatedNode }));\n</code></pre></p>"},{"location":"developer/hooks/#useautolayout","title":"useAutoLayout","text":"<p>Auto-position nodes with Dagre.</p> <p>Usage: <pre><code>const { applyLayout } = useAutoLayout();\n\napplyLayout(nodes, edges, 'TB'); // 'TB', 'LR', 'BT', 'RL'\n</code></pre></p>"},{"location":"developer/hooks/#usecontextmenu","title":"useContextMenu","text":"<p>Right-click menus.</p> <p>Usage: <pre><code>const { openMenu } = useContextMenu();\n\nopenMenu({ id, type: 'node', x, y });\n</code></pre></p>"},{"location":"developer/hooks/#useexport","title":"useExport","text":"<p>Export to JSON/image.</p> <p>Usage: <pre><code>const { exportJSON, exportImage } = useExport();\n</code></pre></p>"},{"location":"developer/hooks/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Data flow</li> <li>Extension Guide - Custom components</li> </ul>"},{"location":"developer/javascript/","title":"JavaScript Development","text":"<p>Quick setup guide for JavaScript/TypeScript development.</p>"},{"location":"developer/javascript/#prerequisites","title":"Prerequisites","text":"<ul> <li>Bun (JavaScript runtime and package manager)</li> <li>Python 3.12+ (for integration testing)</li> </ul> <p>Install Bun: <pre><code>curl -fsSL https://bun.sh/install | bash\n</code></pre></p>"},{"location":"developer/javascript/#project-structure","title":"Project Structure","text":"<pre><code>js/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 components/        # React components\n\u2502   \u2502   \u251c\u2500\u2500 fields/        # Field types (TextField, NumberField, etc.)\n\u2502   \u2502   \u251c\u2500\u2500 handles/       # Handle types (BaseHandle, ButtonHandle, etc.)\n\u2502   \u2502   \u2514\u2500\u2500 layouts/       # Grid layouts\n\u2502   \u251c\u2500\u2500 hooks/            # Custom React hooks\n\u2502   \u251c\u2500\u2500 services/         # Business logic services\n\u2502   \u251c\u2500\u2500 contexts/         # React contexts\n\u2502   \u251c\u2500\u2500 types/            # TypeScript type definitions\n\u2502   \u251c\u2500\u2500 utils/            # Utility functions\n\u2502   \u2514\u2500\u2500 index.tsx         # Main entry point\n\u251c\u2500\u2500 dev/                  # Development app\n\u2502   \u251c\u2500\u2500 app.html          # Dev server HTML\n\u2502   \u251c\u2500\u2500 DevApp.tsx        # Standalone dev app\n\u2502   \u2514\u2500\u2500 mockModel.ts      # Mock AnyWidget model\n\u251c\u2500\u2500 tests/                # Test files (mirrors src/ structure)\n\u2514\u2500\u2500 package.json          # Dependencies and scripts\n</code></pre>"},{"location":"developer/javascript/#javascript-commands","title":"JavaScript Commands","text":"<p>All commands run from the <code>js/</code> directory:</p> <pre><code>cd js\n</code></pre>"},{"location":"developer/javascript/#development","title":"Development","text":"<pre><code># Install dependencies (first time)\nbun install\n\n# Start dev server with hot reload\nbun run dev\n\n# Opens http://localhost:5173/dev/app.html\n</code></pre>"},{"location":"developer/javascript/#testing","title":"Testing","text":"<pre><code># Run all tests once\nbun run test\n\n# Watch mode (re-run on file changes)\nbun run test:watch\n\n# Interactive UI\nbun run test:ui\n\n# With coverage report\nbun run test:coverage\n</code></pre>"},{"location":"developer/javascript/#building","title":"Building","text":"<pre><code># Build for production\nbun run build\n\n# Creates two bundles:\n# - dist/index.js       (main widget)\n# - dist/json_schema.js (JSON schema node widget)\n</code></pre>"},{"location":"developer/javascript/#python-commands","title":"Python Commands","text":"<p>Run from project root:</p> <pre><code># Install with dev dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"developer/javascript/#testing_1","title":"Testing","text":"<pre><code># Python tests only\ntask test-py\n\n# JavaScript tests only\ntask test-js\n\n# Both Python and JavaScript\ntask test\n\n# Python coverage\ntask test-py-cov\n\n# JavaScript coverage  \ntask test-js-cov\n\n# Install Playwright (for integration tests)\ntask playwright-install\n</code></pre>"},{"location":"developer/javascript/#documentation","title":"Documentation","text":"<pre><code># Serve docs locally with hot reload\ntask docs-serve\n\n# Build static docs\ntask docs-build\n</code></pre>"},{"location":"developer/javascript/#development-workflow","title":"Development Workflow","text":""},{"location":"developer/javascript/#1-start-dev-server","title":"1. Start Dev Server","text":"<pre><code>cd js\nbun run dev\n</code></pre> <p>This opens a standalone app with: - Mock AnyWidget model - Sample node types - Hot module reloading</p>"},{"location":"developer/javascript/#2-make-changes","title":"2. Make Changes","text":"<p>Edit files in <code>src/</code>. The browser auto-refreshes.</p>"},{"location":"developer/javascript/#3-add-tests","title":"3. Add Tests","text":"<p>Create test file next to component:</p> <pre><code>src/components/fields/ColorField.tsx\ntests/components/fields/ColorField.test.tsx\n</code></pre>"},{"location":"developer/javascript/#4-run-tests","title":"4. Run Tests","text":"<pre><code>bun run test:watch\n</code></pre>"},{"location":"developer/javascript/#5-build","title":"5. Build","text":"<pre><code>bun run build\n</code></pre>"},{"location":"developer/javascript/#6-test-in-python","title":"6. Test in Python","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n# Test your changes\n</code></pre>"},{"location":"developer/javascript/#common-tasks","title":"Common Tasks","text":""},{"location":"developer/javascript/#adding-a-new-component","title":"Adding a New Component","text":"<ol> <li>Create component file in <code>src/components/</code></li> <li>Define Valibot schema</li> <li>Implement React component</li> <li>Register in <code>ComponentFactory.tsx</code></li> <li>Add tests</li> <li>Export from <code>src/index.tsx</code> (if public API)</li> </ol> <p>See Extension Guide for detailed recipes.</p>"},{"location":"developer/javascript/#debugging","title":"Debugging","text":"<p>Dev Tools: - React DevTools browser extension - Console logs in components - Inspect model state: <code>model.get(\"property\")</code></p> <p>Common Issues:</p> Problem Solution Changes not reflected Check hot reload, refresh browser Type errors Run <code>bun run build</code> to see TypeScript errors Tests failing Check test file naming (<code>*.test.tsx</code>) Import errors Verify export in <code>index.tsx</code>"},{"location":"developer/javascript/#code-style","title":"Code Style","text":"<ul> <li>TypeScript for type safety</li> <li>Valibot for runtime validation</li> <li>Tailwind CSS for styling</li> <li>Vitest for testing</li> </ul>"},{"location":"developer/javascript/#build-system","title":"Build System","text":""},{"location":"developer/javascript/#vite-configuration","title":"Vite Configuration","text":"<p>Three entry points:</p> <ol> <li><code>vite.config.index.ts</code> - Main widget bundle</li> <li><code>vite.config.json_schema.ts</code> - JSON schema widget</li> <li><code>vite.config.ts</code> - Dev server</li> </ol>"},{"location":"developer/javascript/#output","title":"Output","text":"<pre><code>dist/\n\u251c\u2500\u2500 index.js           # Main widget (ESM)\n\u251c\u2500\u2500 json_schema.js     # JSON schema widget (ESM)\n\u2514\u2500\u2500 style.css          # Styles (inlined)\n</code></pre> <p>These are embedded in the Python package via <code>hatch_build.py</code>.</p>"},{"location":"developer/javascript/#testing-architecture","title":"Testing Architecture","text":"<pre><code>graph TB\n    A[Vitest] --&gt; B[Component Tests]\n    A --&gt; C[Service Tests]\n    A --&gt; D[Utils Tests]\n\n    B --&gt; E[@testing-library/react]\n    B --&gt; F[user-event]\n\n    C --&gt; G[Mock Data]\n\n    style A fill:#e3f2fd\n    style B fill:#f3e5f5\n    style C fill:#fff3e0\n    style D fill:#e8f5e9</code></pre>"},{"location":"developer/javascript/#test-example","title":"Test Example","text":"<pre><code>import { render, screen } from \"@testing-library/react\";\nimport { TextField } from \"./TextField\";\n\ndescribe(\"TextField\", () =&gt; {\n  it(\"renders with label\", () =&gt; {\n    render(&lt;TextField id=\"test\" label=\"Name\" nodeId=\"node-1\" /&gt;);\n    expect(screen.getByLabelText(\"Name\")).toBeInTheDocument();\n  });\n});\n</code></pre>"},{"location":"developer/javascript/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Understand the rendering system</li> <li>Extension Guide - Add custom components</li> <li>Hooks Reference - Available React hooks</li> </ul>"},{"location":"developer/layout/","title":"Layout System","text":"<p>PyNodeWidget uses a powerful three-layer grid system that provides flexible and precise control over node layouts. This architecture separates concerns cleanly: grid positioning, component arrangement, and individual component rendering.</p>"},{"location":"developer/layout/#overview","title":"Overview","text":"<p>The layout system consists of three distinct layers:</p> <ol> <li>Layer 1: NodeGrid - CSS Grid positioning of cells</li> <li>Layer 2: GridCell - Flexbox/Grid arrangement of components within cells</li> <li>Layer 3: Components - Individual UI elements (fields, handles, etc.)</li> </ol> <p>This separation enables:</p> <ul> <li>Precise control over component positioning</li> <li>Flexible layouts from simple to complex</li> <li>Cell spanning across multiple rows/columns</li> <li>Nested layouts for advanced use cases</li> <li>Responsive design with CSS Grid's fr units</li> </ul>"},{"location":"developer/layout/#layer-1-nodegrid-cell-positioning","title":"Layer 1: NodeGrid - Cell Positioning","text":"<p>The <code>NodeGrid</code> defines the overall structure using CSS Grid. It positions cells in a grid layout.</p>"},{"location":"developer/layout/#structure","title":"Structure","text":"<pre><code>from pynodewidget.models import NodeGrid\n\ngrid = NodeGrid(\n    rows=[\"auto\", \"1fr\", \"auto\"],      # Row heights\n    columns=[\"200px\", \"1fr\", \"200px\"], # Column widths\n    gap=\"8px\",                          # Gap between cells\n    cells=[...]                         # GridCell objects\n)\n</code></pre> <p>TypeScript: <pre><code>interface NodeGrid {\n  rows: string[];        // CSS Grid row definitions\n  columns: string[];     // CSS Grid column definitions\n  gap?: string;          // Gap between cells\n  cells: GridCell[];     // Array of positioned cells\n}\n</code></pre></p>"},{"location":"developer/layout/#grid-sizing","title":"Grid Sizing","text":"<p>Rows and columns use standard CSS Grid values:</p> <ul> <li><code>\"1fr\"</code> - Flexible fraction of available space</li> <li><code>\"200px\"</code> - Fixed pixel size</li> <li><code>\"auto\"</code> - Size to content</li> <li><code>\"minmax(100px, 1fr)\"</code> - Min/max constraints</li> <li><code>\"repeat(3, 1fr)\"</code> - Repeat pattern</li> </ul> <p>Example: <pre><code>grid = NodeGrid(\n    rows=[\"60px\", \"1fr\", \"40px\"],      # Fixed header/footer, flexible body\n    columns=[\"auto\", \"1fr\", \"auto\"],   # Flexible center, auto sides\n    gap=\"12px\",\n    cells=[...]\n)\n</code></pre></p>"},{"location":"developer/layout/#implementation","title":"Implementation","text":"<p>Frontend (React): <pre><code>// js/src/components/GridRenderer.tsx\nexport function NodeGridRenderer({ grid, nodeId, onValueChange }) {\n  const gridStyle: React.CSSProperties = {\n    display: \"grid\",\n    gridTemplateRows: grid.rows.join(\" \"),\n    gridTemplateColumns: grid.columns.join(\" \"),\n    gap: grid.gap || \"8px\",\n    width: \"100%\",\n    height: \"100%\",\n  };\n\n  return (\n    &lt;div className=\"node-grid\" style={gridStyle}&gt;\n      {grid.cells.map((cell) =&gt; (\n        &lt;div\n          key={cell.id}\n          className=\"grid-cell\"\n          style={{\n            gridRow: `${cell.coordinates.row} / span ${cell.coordinates.row_span || 1}`,\n            gridColumn: `${cell.coordinates.col} / span ${cell.coordinates.col_span || 1}`,\n          }}\n        &gt;\n          &lt;GridCellRenderer cell={cell} nodeId={nodeId} onValueChange={onValueChange} /&gt;\n        &lt;/div&gt;\n      ))}\n    &lt;/div&gt;\n  );\n}\n</code></pre></p>"},{"location":"developer/layout/#layer-2-gridcell-component-arrangement","title":"Layer 2: GridCell - Component Arrangement","text":"<p>Each <code>GridCell</code> defines its position in the grid and how components within it are arranged.</p>"},{"location":"developer/layout/#structure_1","title":"Structure","text":"<pre><code>from pynodewidget.models import GridCell, GridCoordinates, CellLayout\n\ncell = GridCell(\n    id=\"left-cell\",\n    coordinates=GridCoordinates(\n        row=1,           # Starting row (1-indexed)\n        col=1,           # Starting column (1-indexed)\n        row_span=2,      # Span 2 rows\n        col_span=1       # Span 1 column\n    ),\n    layout=CellLayout(\n        type=\"flex\",         # \"flex\" | \"grid\" | \"stack\"\n        direction=\"column\",  # \"row\" | \"column\"\n        align=\"stretch\",     # \"start\" | \"center\" | \"end\" | \"stretch\"\n        justify=\"start\",     # \"start\" | \"center\" | \"end\" | \"space-between\"\n        gap=\"8px\"\n    ),\n    components=[...]         # List of components\n)\n</code></pre> <p>TypeScript: <pre><code>interface GridCell {\n  id: string;\n  coordinates: GridCoordinates;\n  layout?: CellLayout;\n  components: ComponentType[];\n}\n\ninterface GridCoordinates {\n  row: number;         // Starting row (1-indexed)\n  col: number;         // Starting column (1-indexed)\n  row_span?: number;   // Rows to span\n  col_span?: number;   // Columns to span\n}\n\ninterface CellLayout {\n  type?: \"flex\" | \"grid\" | \"stack\";\n  direction?: \"row\" | \"column\";\n  align?: \"start\" | \"center\" | \"end\" | \"stretch\";\n  justify?: \"start\" | \"center\" | \"end\" | \"space-between\";\n  gap?: string;\n}\n</code></pre></p>"},{"location":"developer/layout/#cell-spanning","title":"Cell Spanning","text":"<p>Cells can span multiple rows and/or columns:</p> <pre><code># Span across 2 rows and 2 columns (featured content area)\nfeatured_cell = GridCell(\n    id=\"featured\",\n    coordinates=GridCoordinates(row=1, col=1, row_span=2, col_span=2),\n    layout=CellLayout(type=\"flex\", direction=\"column\"),\n    components=[HeaderComponent(...)]\n)\n\n# Header spanning full width\nheader_cell = GridCell(\n    id=\"header\",\n    coordinates=GridCoordinates(row=1, col=1, col_span=3),\n    layout=CellLayout(type=\"flex\", direction=\"row\"),\n    components=[HeaderComponent(...)]\n)\n</code></pre>"},{"location":"developer/layout/#layout-types","title":"Layout Types","text":""},{"location":"developer/layout/#flex-layout-default","title":"Flex Layout (Default)","text":"<p>Uses CSS Flexbox for one-dimensional layouts:</p> <pre><code>CellLayout(\n    type=\"flex\",\n    direction=\"column\",   # Stack vertically\n    align=\"stretch\",      # Stretch to fill width\n    justify=\"start\",      # Align to top\n    gap=\"12px\"           # Space between components\n)\n</code></pre>"},{"location":"developer/layout/#grid-layout","title":"Grid Layout","text":"<p>Uses CSS Grid for two-dimensional layouts:</p> <pre><code>CellLayout(\n    type=\"grid\",\n    gap=\"8px\",\n    align=\"center\",\n    justify=\"start\"\n)\n</code></pre>"},{"location":"developer/layout/#stack-layout","title":"Stack Layout","text":"<p>Vertical stacking (shorthand for flex column):</p> <pre><code>CellLayout(\n    type=\"stack\",\n    gap=\"8px\"\n)\n</code></pre>"},{"location":"developer/layout/#implementation_1","title":"Implementation","text":"<p>Frontend (React): <pre><code>// js/src/components/layouts/GridCellComponent.tsx\nexport function GridCellComponent({ cell, nodeId, onValueChange }) {\n  const layout = cell.layout || { type: \"flex\", direction: \"column\" };\n  const cellStyle = getCellStyle(cell);\n  const layoutStyle = getLayoutStyle(layout);\n\n  return (\n    &lt;div className=\"nested-grid-cell\" style={cellStyle}&gt;\n      &lt;div className=\"nested-grid-cell-content\" style={layoutStyle}&gt;\n        {cell.components.map((component) =&gt; (\n          &lt;ComponentFactory\n            key={component.id}\n            component={component}\n            nodeId={nodeId}\n            onValueChange={onValueChange}\n          /&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction getCellStyle(cell: GridCell): React.CSSProperties {\n  const rowSpan = cell.coordinates.row_span || 1;\n  const colSpan = cell.coordinates.col_span || 1;\n\n  return {\n    gridRow: `${cell.coordinates.row} / span ${rowSpan}`,\n    gridColumn: `${cell.coordinates.col} / span ${colSpan}`,\n  };\n}\n\nfunction getLayoutStyle(layout?: CellLayout): React.CSSProperties {\n  if (!layout || layout.type === \"flex\" || !layout.type) {\n    return {\n      display: \"flex\",\n      flexDirection: layout?.direction || \"column\",\n      alignItems: layout?.align || \"start\",\n      justifyContent: layout?.justify || \"start\",\n      gap: layout?.gap || \"4px\",\n      height: \"100%\",\n      width: \"100%\",\n    };\n  }\n\n  if (layout.type === \"grid\") {\n    return {\n      display: \"grid\",\n      gap: layout.gap || \"4px\",\n      alignItems: layout.align || \"start\",\n      justifyContent: layout.justify || \"start\",\n      height: \"100%\",\n      width: \"100%\",\n    };\n  }\n\n  if (layout.type === \"stack\") {\n    return {\n      display: \"flex\",\n      flexDirection: \"column\",\n      gap: layout.gap || \"4px\",\n      height: \"100%\",\n      width: \"100%\",\n    };\n  }\n\n  return {};\n}\n</code></pre></p>"},{"location":"developer/layout/#layer-3-components","title":"Layer 3: Components","text":"<p>Individual UI components render within cells. See Component Library for details.</p> <p>Components automatically fill their container when spanning:</p> <pre><code># HeaderComponent with background color - fills entire cell\nHeaderComponent(\n    id=\"header\",\n    label=\"Node Title\",\n    bgColor=\"#3b82f6\",\n    textColor=\"#ffffff\"\n)\n\n# FooterComponent spanning full width\nFooterComponent(\n    id=\"footer\",\n    text=\"Status: Active\",\n    bgColor=\"#f3f4f6\"\n)\n</code></pre> <p>Implementation note: Components must set <code>width: 100%</code> and <code>height: 100%</code> to properly fill spanning cells:</p> <pre><code>// js/src/components/HeaderComponent.tsx\nexport function HeaderComponent({ component }) {\n  return (\n    &lt;div \n      className=\"component-header px-3 py-2 font-semibold flex items-center gap-2\"\n      style={{\n        width: '100%',\n        height: '100%',\n        backgroundColor: component.bgColor,\n        color: component.textColor,\n      }}\n    &gt;\n      {component.icon &amp;&amp; &lt;span&gt;{component.icon}&lt;/span&gt;}\n      &lt;span&gt;{component.label}&lt;/span&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"developer/layout/#common-layout-patterns","title":"Common Layout Patterns","text":""},{"location":"developer/layout/#three-column-layout","title":"Three-Column Layout","text":"<p>Classic layout with inputs, parameters, and outputs:</p> <pre><code>from pynodewidget.grid_layouts import create_three_column_grid\nfrom pynodewidget.models import ButtonHandle, NumberField, TextField\n\ngrid = create_three_column_grid(\n    left_components=[\n        ButtonHandle(id=\"input1\", handle_type=\"input\", label=\"Input 1\"),\n        ButtonHandle(id=\"input2\", handle_type=\"input\", label=\"Input 2\"),\n    ],\n    center_components=[\n        TextField(id=\"name\", value=\"Processor\"),\n        NumberField(id=\"value\", value=50, min=0, max=100),\n    ],\n    right_components=[\n        ButtonHandle(id=\"output\", handle_type=\"output\", label=\"Output\"),\n    ],\n    column_widths=[\"auto\", \"1fr\", \"auto\"]\n)\n</code></pre> <p>Result: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Input1 \u2502 Name: [...]  \u2502 Output \u2502\n\u2502 Input2 \u2502 Value: [50]  \u2502        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"developer/layout/#header-body-layout","title":"Header-Body Layout","text":"<p>Header spanning full width with content below:</p> <pre><code>from pynodewidget.grid_layouts import create_header_body_grid\nfrom pynodewidget.models import HeaderComponent, TextField, NumberField\n\ngrid = create_header_body_grid(\n    header_components=[\n        HeaderComponent(id=\"header\", label=\"Processor Node\", icon=\"\u2699\ufe0f\"),\n    ],\n    body_components=[\n        TextField(id=\"name\", value=\"Node\"),\n        NumberField(id=\"count\", value=1),\n    ]\n)\n</code></pre> <p>Result: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 \u2699\ufe0f Processor Node        \u2502 \u2190 Header spans full width\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Name: [Node]             \u2502\n\u2502 Count: [1]               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"developer/layout/#sidebar-layout","title":"Sidebar Layout","text":"<p>Fixed sidebar spanning multiple rows:</p> <pre><code>grid = NodeGrid(\n    rows=[\"60px\", \"1fr\", \"60px\"],\n    columns=[\"200px\", \"1fr\"],\n    gap=\"8px\",\n    cells=[\n        # Sidebar spanning all 3 rows\n        GridCell(\n            id=\"sidebar\",\n            coordinates=GridCoordinates(row=1, col=1, row_span=3),\n            layout=CellLayout(type=\"flex\", direction=\"column\"),\n            components=[...]\n        ),\n        # Header\n        GridCell(\n            id=\"header\",\n            coordinates=GridCoordinates(row=1, col=2),\n            components=[HeaderComponent(...)]\n        ),\n        # Content\n        GridCell(\n            id=\"content\",\n            coordinates=GridCoordinates(row=2, col=2),\n            components=[...]\n        ),\n        # Footer\n        GridCell(\n            id=\"footer\",\n            coordinates=GridCoordinates(row=3, col=2),\n            components=[FooterComponent(...)]\n        ),\n    ]\n)\n</code></pre> <p>Result: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \u2502   Header     \u2502\n\u2502 Sidebar \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         \u2502   Content    \u2502\n\u2502 (spans  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 3 rows) \u2502   Footer     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"developer/layout/#dashboard-with-featured-content","title":"Dashboard with Featured Content","text":"<p>Featured area spanning 2x2 grid:</p> <pre><code>grid = NodeGrid(\n    rows=[\"80px\", \"80px\", \"80px\"],\n    columns=[\"1fr\", \"1fr\", \"1fr\"],\n    gap=\"8px\",\n    cells=[\n        # Featured content spanning 2 rows \u00d7 2 columns\n        GridCell(\n            id=\"featured\",\n            coordinates=GridCoordinates(row=1, col=1, row_span=2, col_span=2),\n            components=[HeaderComponent(id=\"feat\", label=\"Featured\", bgColor=\"#8b5cf6\")]\n        ),\n        # Widgets in top-right\n        GridCell(id=\"w1\", coordinates=GridCoordinates(row=1, col=3), components=[...]),\n        GridCell(id=\"w2\", coordinates=GridCoordinates(row=2, col=3), components=[...]),\n        # Bottom row info\n        GridCell(id=\"i1\", coordinates=GridCoordinates(row=3, col=1), components=[...]),\n        GridCell(id=\"i2\", coordinates=GridCoordinates(row=3, col=2), components=[...]),\n        GridCell(id=\"i3\", coordinates=GridCoordinates(row=3, col=3), components=[...]),\n    ]\n)\n</code></pre> <p>Result: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502 Widget1 \u2502\n\u2502   Featured        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   (2\u00d72 span)      \u2502 Widget2 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Info1\u2502 Info2\u2502 Info3         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"developer/layout/#python-helper-functions","title":"Python Helper Functions","text":""},{"location":"developer/layout/#gridbuilder-api-recommended","title":"GridBuilder API (Recommended)","text":"<p>New in v2.0: The <code>GridBuilder</code> class provides a fluent, chainable API that reduces layout code by 60-70%:</p> <pre><code>from pynodewidget import GridBuilder, PRESETS\n\n# Using presets (easiest)\ngrid = (\n    GridBuilder()\n    .preset(PRESETS.three_column)\n    .slot(\"header\", HeaderComponent(id=\"header\", label=\"Title\"))\n    .slot(\"center\", TextField(id=\"content\", label=\"Content\"))\n    .build()\n)\n\n# Custom grids (full control)\ngrid = (\n    GridBuilder()\n    .rows([\"60px\", \"1fr\", \"40px\"])\n    .cols([\"200px\", \"1fr\"])\n    .gap(\"0.5rem\")\n    .cell(row=1, col=1, col_span=2, components=[\n        HeaderComponent(id=\"header\", label=\"Title\")\n    ])\n    .cell(row=2, col=1, components=[\n        TextField(id=\"sidebar\", label=\"Sidebar\")\n    ])\n    .cell(row=2, col=2, components=[\n        TextField(id=\"content\", label=\"Content\")\n    ])\n    .build()\n)\n\n# Row/column helpers (linear layouts)\ngrid = GridBuilder().row(\n    TextField(id=\"field1\", label=\"Field 1\"),\n    TextField(id=\"field2\", label=\"Field 2\"),\n    TextField(id=\"field3\", label=\"Field 3\")\n).build()\n</code></pre> <p>Benefits: - \u2705 Chainable, readable API - \u2705 Preset templates for common layouts - \u2705 No manual cell ID generation - \u2705 Type-safe with Pydantic validation - \u2705 60-70% less code</p> <p>Available presets: - <code>PRESETS.three_column</code> - Three-column layout with optional header/footer - <code>PRESETS.simple_node</code> - Minimal node with header and centered handles</p> <p>See the Grid Layouts User Guide for complete documentation.</p>"},{"location":"developer/layout/#legacy-helper-functions","title":"Legacy Helper Functions","text":"<p>The original helper functions are still available for backward compatibility:</p> <pre><code>from pynodewidget.grid_layouts import (\n    create_three_column_grid,\n    create_vertical_stack_grid,\n    create_header_body_grid,\n    create_sidebar_grid,\n    create_custom_grid,\n)\n\n# Three-column layout\ngrid = create_three_column_grid(\n    left_components=[...],\n    center_components=[...],\n    right_components=[...],\n    column_widths=[\"auto\", \"1fr\", \"auto\"],\n    gap=\"8px\"\n)\n\n# Vertical stack\ngrid = create_vertical_stack_grid(\n    components=[...],\n    gap=\"12px\"\n)\n\n# Custom grid\ngrid = create_custom_grid(\n    rows=[\"60px\", \"1fr\", \"40px\"],\n    columns=[\"200px\", \"1fr\", \"200px\"],\n    cells=[...],\n    gap=\"8px\"\n)\n</code></pre> <p>Note: Consider migrating to <code>GridBuilder</code> for more maintainable code.</p>"},{"location":"developer/layout/#css-styling-for-spanning","title":"CSS Styling for Spanning","text":"<p>For components to properly fill spanning cells, the CSS cascade requires explicit sizing at each level:</p>"},{"location":"developer/layout/#level-1-grid-cell-css-grid-auto-sizes","title":"Level 1: Grid Cell (CSS Grid auto-sizes)","text":"<pre><code>.nested-grid-cell {\n  /* CSS Grid automatically sizes based on gridRow/gridColumn */\n  grid-row: 1 / span 2;\n  grid-column: 1 / span 2;\n}\n</code></pre>"},{"location":"developer/layout/#level-2-cell-content-wrapper-must-fill-cell","title":"Level 2: Cell Content Wrapper (Must fill cell)","text":"<pre><code>.nested-grid-cell-content {\n  display: flex;\n  width: 100%;   /* Fill cell width */\n  height: 100%;  /* Fill cell height */\n}\n</code></pre>"},{"location":"developer/layout/#level-3-component-must-fill-wrapper","title":"Level 3: Component (Must fill wrapper)","text":"<pre><code>.component-header {\n  width: 100%;   /* Fill wrapper width */\n  height: 100%;  /* Fill wrapper height */\n  background-color: var(--bg-color);\n}\n</code></pre> <p>Without this three-level sizing chain, components will only wrap their content rather than filling the spanning area.</p>"},{"location":"developer/layout/#testing-grid-layouts","title":"Testing Grid Layouts","text":"<p>The repository includes comprehensive test suites:</p> <p>Visual Testing: <pre><code>cd js &amp;&amp; bun run dev\n# Open http://localhost:3000 and click \"Grid Spanning\" tab\n</code></pre></p> <p>Unit Tests: <pre><code>cd js &amp;&amp; bun run test\n# Tests in: js/tests/layouts/\n</code></pre></p> <p>Test Files: - <code>GridLayoutComponent.test.tsx</code> - Basic grid rendering - <code>GridLayoutSpanning.test.tsx</code> - Cell spanning behavior - <code>GridLayoutPatterns.test.tsx</code> - Common layout patterns</p>"},{"location":"developer/layout/#advanced-nested-grids","title":"Advanced: Nested Grids","text":"<p>You can nest grids within cells for complex layouts:</p> <pre><code># Inner grid as a component\ninner_grid = GridLayoutComponent(\n    id=\"inner-grid\",\n    type=\"grid-layout\",\n    rows=[\"1fr\", \"1fr\"],\n    columns=[\"1fr\", \"1fr\"],\n    gap=\"4px\",\n    cells=[...]\n)\n\n# Outer grid containing the inner grid\nouter_grid = NodeGrid(\n    rows=[\"auto\", \"1fr\"],\n    columns=[\"1fr\"],\n    gap=\"8px\",\n    cells=[\n        GridCell(\n            id=\"header-cell\",\n            coordinates=GridCoordinates(row=1, col=1),\n            components=[HeaderComponent(...)]\n        ),\n        GridCell(\n            id=\"content-cell\",\n            coordinates=GridCoordinates(row=2, col=1),\n            components=[inner_grid]  # Nested grid here\n        ),\n    ]\n)\n</code></pre>"},{"location":"developer/layout/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Grid vs Flex: Use CSS Grid for two-dimensional layouts, Flexbox for one-dimensional</li> <li>Auto-sizing: <code>auto</code> rows/columns measure content - use sparingly for better performance</li> <li>Fixed sizes: Use <code>px</code> or <code>fr</code> units when possible to avoid layout recalculation</li> <li>Gap sizing: Gap is applied between all cells - factor this into total dimensions</li> </ul>"},{"location":"developer/layout/#related-documentation","title":"Related Documentation","text":"<ul> <li>Component Library - Available components for cells</li> <li>Architecture - Overall system design</li> <li>JavaScript Development - Frontend implementation details</li> <li>User Guide: Custom Nodes - Creating nodes with custom layouts</li> </ul>"},{"location":"developer/layout/#api-reference","title":"API Reference","text":""},{"location":"developer/layout/#python-models","title":"Python Models","text":"<pre><code>from pynodewidget.models import (\n    NodeGrid,      # Top-level grid\n    GridCell,      # Cell in grid\n    GridCoordinates,  # Cell position\n    CellLayout,    # Layout within cell\n)\n</code></pre>"},{"location":"developer/layout/#typescript-types","title":"TypeScript Types","text":"<pre><code>import type {\n  NodeGrid,\n  GridCell,\n  GridCoordinates,\n  CellLayout,\n} from \"@/types/schema\";\n</code></pre>"},{"location":"developer/layout/#helper-functions","title":"Helper Functions","text":"<pre><code>from pynodewidget.grid_layouts import (\n    create_three_column_grid,\n    create_vertical_stack_grid,\n    create_header_body_grid,\n    create_sidebar_grid,\n    create_custom_grid,\n)\n</code></pre>"},{"location":"developer/state/","title":"State Management","text":"<p>PyNodeWidget uses Zustand for lightweight state management, separating dynamic values from structural node data.</p>"},{"location":"developer/state/#value-store","title":"Value Store","text":"<p>Manages node field values separately from ReactFlow state for better performance.</p> <pre><code>import { useValueStore } from 'pynodewidget';\n\nconst updateValue = useValueStore((state) =&gt; state.updateValue);\nconst values = useValueStore((state) =&gt; state.values);\n\n// Update a single field\nupdateValue(nodeId, \"count\", 42);\n\n// Update multiple fields\nconst updateNodeValues = useValueStore((state) =&gt; state.updateNodeValues);\nupdateNodeValues(nodeId, { count: 42, name: \"Test\" });\n\n// Get all values for a node\nconst getNodeValues = useValueStore((state) =&gt; state.getNodeValues);\nconst nodeValues = getNodeValues(nodeId);\n</code></pre>"},{"location":"developer/state/#store-api","title":"Store API","text":""},{"location":"developer/state/#state","title":"State","text":"<pre><code>interface ValueStoreState {\n  values: NodeValues;  // { [nodeId]: { [field]: value } }\n}\n</code></pre>"},{"location":"developer/state/#actions","title":"Actions","text":"<pre><code>// Update single field\nupdateValue(nodeId: string, fieldName: string, value: any): void\n\n// Update multiple fields\nupdateNodeValues(nodeId: string, values: Record&lt;string, any&gt;): void\n\n// Get node values\ngetNodeValues(nodeId: string): Record&lt;string, any&gt; | undefined\n\n// Initialize from nodes\ninitializeFromNodes(nodes: Node[]): void\n\n// Sync back to nodes\nsyncToNodes(nodes: Node[]): Node[]\n\n// Clear all values\nclear(): void\n</code></pre>"},{"location":"developer/state/#why-separate-value-store","title":"Why Separate Value Store?","text":"<p>Problem: Updating node data in ReactFlow triggers re-renders of the entire node, including layout and static elements.</p> <p>Solution: Store dynamic values (field inputs, progress, etc.) separately. Only field components re-render on value changes.</p> <pre><code>graph LR\n    A[User Input] --&gt;|Update| B[Value Store]\n    B --&gt;|Notify| C[Field Component]\n    C --&gt;|Re-render| C\n    D[Node Structure] -.-&gt;|No re-render| D</code></pre>"},{"location":"developer/state/#integration-pattern","title":"Integration Pattern","text":"<pre><code>// In field component\nconst updateValue = useValueStore((state) =&gt; state.updateValue);\nconst value = useValueStore((state) =&gt; \n  state.values[nodeId]?.[fieldName]\n);\n\n&lt;input\n  value={value}\n  onChange={(e) =&gt; updateValue(nodeId, fieldName, e.target.value)}\n/&gt;\n</code></pre>"},{"location":"developer/state/#python-sync","title":"Python Sync","text":"<p>Values sync to Python via AnyWidget:</p> <pre><code>// When value changes\nupdateValue(nodeId, field, newValue);\n\n// Widget model syncs automatically\nmodel.set(\"node_values\", useValueStore.getState().values);\nmodel.save_changes();\n</code></pre> <p>Python receives updates:</p> <pre><code>widget.observe(_on_value_change, names=[\"node_values\"])\n\ndef _on_value_change(change):\n    node_values = change[\"new\"]\n    # Process updated values\n</code></pre>"},{"location":"developer/state/#best-practices","title":"Best Practices","text":"<ol> <li>Use for dynamic data - User inputs, progress, temporary state</li> <li>Don't use for structure - Node position, connections, schema</li> <li>Batch updates - Use <code>updateNodeValues</code> for multiple fields</li> <li>Initialize on mount - Call <code>initializeFromNodes</code> when loading</li> <li>Sync on export - Call <code>syncToNodes</code> before saving</li> </ol>"},{"location":"developer/state/#see-also","title":"See Also","text":"<ul> <li>Architecture - Python \u2194 JavaScript communication</li> <li>Hooks API - React hooks</li> <li>Field Registry - Custom fields</li> </ul>"},{"location":"developer/types/","title":"TypeScript Types","text":"<p>Core type definitions for PyNodeWidget's TypeScript API.</p>"},{"location":"developer/types/#field-types","title":"Field Types","text":"<pre><code>// Field value types\ntype FieldValue = string | number | boolean | null;\n\n// Field renderer interface\ninterface FieldRendererProps {\n  value: FieldValue;\n  property: JsonSchemaProperty;\n  onChange: (value: FieldValue) =&gt; void;\n  label?: string;\n}\n\ntype FieldRenderer = (props: FieldRendererProps) =&gt; JSX.Element;\n</code></pre>"},{"location":"developer/types/#schema-types","title":"Schema Types","text":"<pre><code>// JSON Schema property definition\ninterface JsonSchemaProperty {\n  type: string;                      // \"string\", \"number\", \"color\", etc.\n  title?: string;                    // Display label\n  default?: any;                     // Default value\n  description?: string;              // Help text\n  enum?: Array&lt;string | number&gt;;     // Enum options\n  minimum?: number;                  // Min value (numbers)\n  maximum?: number;                  // Max value (numbers)\n  multipleOf?: number;               // Step value\n}\n\n// Full JSON Schema\ninterface JsonSchema {\n  type: \"object\";\n  properties: Record&lt;string, JsonSchemaProperty&gt;;\n  required?: string[];\n}\n</code></pre>"},{"location":"developer/types/#node-types","title":"Node Types","text":"<pre><code>// Handle configuration\ninterface HandleConfig {\n  id: string;\n  label?: string;\n  handle_type?: HandleType;\n}\n\ntype HandleType = \"base\" | \"button\" | \"labeled\";\n\n// Node data structure\ninterface NodeData {\n  label: string;\n  icon?: string;\n  type_name: string;\n  parameters?: JsonSchema;\n  values?: Record&lt;string, any&gt;;\n  inputs?: HandleConfig[];\n  outputs?: HandleConfig[];\n  layout?: string;\n  handle_type?: HandleType;\n}\n</code></pre>"},{"location":"developer/types/#layout-types","title":"Layout Types","text":"<pre><code>interface LayoutProps {\n  inputs?: HandleConfig[];\n  outputs?: HandleConfig[];\n  children?: React.ReactNode;\n  handleType?: HandleType;\n  inputHandleType?: HandleType;\n  outputHandleType?: HandleType;\n}\n\ntype LayoutComponent = React.ComponentType&lt;LayoutProps&gt;;\n</code></pre>"},{"location":"developer/types/#context-menu-types","title":"Context Menu Types","text":"<pre><code>interface ContextMenuState {\n  id: string;\n  type: \"node\" | \"edge\";\n  x: number;\n  y: number;\n}\n</code></pre>"},{"location":"developer/types/#store-types","title":"Store Types","text":"<pre><code>// Value store\ninterface NodeValues {\n  [nodeId: string]: {\n    [fieldName: string]: any;\n  };\n}\n\ninterface ValueStoreState {\n  values: NodeValues;\n  updateValue: (nodeId: string, fieldName: string, value: any) =&gt; void;\n  updateNodeValues: (nodeId: string, values: Record&lt;string, any&gt;) =&gt; void;\n  getNodeValues: (nodeId: string) =&gt; Record&lt;string, any&gt; | undefined;\n  initializeFromNodes: (nodes: Node[]) =&gt; void;\n  syncToNodes: (nodes: Node[]) =&gt; Node[];\n  clear: () =&gt; void;\n}\n</code></pre>"},{"location":"developer/types/#reactflow-integration","title":"ReactFlow Integration","text":"<p>PyNodeWidget extends ReactFlow's types:</p> <pre><code>import type { Node, Edge, NodeProps } from '@xyflow/react';\n\n// PyNodeWidget node extends ReactFlow Node\ntype PyNodeWidgetNode = Node&lt;NodeData&gt;;\n\n// Custom node component\ntype NodeComponent = React.ComponentType&lt;NodeProps&lt;NodeData&gt;&gt;;\n</code></pre>"},{"location":"developer/types/#import-paths","title":"Import Paths","text":"<pre><code>// From main package\nimport type { FieldRenderer, FieldRendererProps } from 'pynodeflow';\nimport type { LayoutComponent, LayoutProps } from 'pynodeflow';\nimport type { HandleType } from 'pynodeflow';\n\n// From ReactFlow\nimport type { Node, Edge, NodeProps } from '@xyflow/react';\n</code></pre>"},{"location":"developer/types/#see-also","title":"See Also","text":"<ul> <li>Field Registry - Using FieldRenderer</li> <li>Layout System - Using LayoutComponent</li> <li>State Management - Store types</li> <li>Component Library - Component props</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Working examples demonstrating PyNodeWidget features. All examples are runnable Python scripts in the <code>examples/</code> directory.</p>"},{"location":"examples/#quick-reference","title":"Quick Reference","text":"Example Features File Node Classes Pydantic models, class-based nodes <code>node_class_example.py</code> Custom Fields Color pickers, date selectors, custom inputs <code>custom_fields_example.py</code> Labeled Handles Named inputs/outputs, multiple handles <code>labeled_handles_example.py</code> Widget Registration Bulk node registration, workflow setup <code>widget_registration_example.py</code> Icons Emoji icons, visual node types <code>icon_example.py</code> Demo Workflows Complete workflows in Jupyter/Marimo <code>pynodewidget_demo.py</code>, <code>*.ipynb</code>"},{"location":"examples/#node-class-example","title":"Node Class Example","text":"<p>File: <code>node_class_example.py</code></p> <p>Demonstrates the modern class-based API using Pydantic models:</p> <pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget\n\nclass ProcessorParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0.0, le=1.0)\n    mode: str = Field(default=\"auto\")\n\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    icon = \"\u2699\ufe0f\"\n    inputs = [{\"id\": \"in\"}]\n    outputs = [{\"id\": \"out\"}]\n</code></pre> <p>Key concepts: Pydantic validation, type hints, automatic JSON schema generation.</p>"},{"location":"examples/#custom-fields-example","title":"Custom Fields Example","text":"<p>File: <code>custom_fields_example.py</code></p> <p>Shows how to register custom field types (color pickers, date selectors, textareas):</p> <pre><code>class StyledBoxParams(BaseModel):\n    background: str = Field(default=\"#3498db\", json_schema_extra={\"type\": \"color\"})\n    border: str = Field(default=\"#ffffff\", json_schema_extra={\"type\": \"color\"})\n    opacity: int = Field(default=100, json_schema_extra={\"type\": \"slider\"})\n</code></pre> <p>JavaScript: <pre><code>import { fieldRegistry } from 'pynodewidget';\n\nfieldRegistry.register(\"color\", ({ value, onChange }) =&gt; (\n  &lt;input type=\"color\" value={value} onChange={(e) =&gt; onChange(e.target.value)} /&gt;\n));\n</code></pre></p> <p>Key concepts: Field registry, custom renderers, <code>json_schema_extra</code> override.</p>"},{"location":"examples/#labeled-handles-example","title":"Labeled Handles Example","text":"<p>File: <code>labeled_handles_example.py</code></p> <p>Multiple named inputs/outputs with labels:</p> <pre><code>widget.add_node_type_from_schema(\n    json_schema={...},\n    type_name=\"join\",\n    label=\"Join\",\n    icon=\"\ud83d\udd17\",\n    inputs=[\n        {\"id\": \"left\", \"label\": \"Left Data\"},\n        {\"id\": \"right\", \"label\": \"Right Data\"}\n    ],\n    outputs=[\n        {\"id\": \"merged\", \"label\": \"Merged Data\"},\n        {\"id\": \"stats\", \"label\": \"Statistics\"}\n    ]\n)\n</code></pre> <p>Key concepts: Multiple handles, labeled connections, data flow.</p>"},{"location":"examples/#widget-registration-example","title":"Widget Registration Example","text":"<p>File: <code>widget_registration_example.py</code></p> <p>Bulk registration of multiple node classes:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\nwidget = NodeFlowWidget(\n    nodes=[\n        DataSourceNode,\n        FilterNode,\n        AggregateNode,\n        VisualizationNode\n    ],\n    height=\"700px\"\n)\n</code></pre> <p>Key concepts: Batch registration, workflow setup, node reuse.</p>"},{"location":"examples/#icon-example","title":"Icon Example","text":"<p>File: <code>icon_example.py</code></p> <p>Using emoji and Unicode icons for visual node types:</p> <pre><code>widget.add_node_type_from_schema(\n    json_schema={...},\n    type_name=\"data_source\",\n    label=\"Data Source\",\n    icon=\"\ud83d\udcc1\",  # Folder emoji\n    ...\n)\n</code></pre> <p>Common icons: \ud83d\udcc1 (files), \u2699\ufe0f (processing), \ud83d\udcca (visualization), \ud83d\udd17 (join), \ud83d\udce4 (output)</p>"},{"location":"examples/#demo-workflows","title":"Demo Workflows","text":""},{"location":"examples/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>File: <code>pynodewidget_demo.ipynb</code></p> <p>Interactive workflow in Jupyter with live updates.</p>"},{"location":"examples/#marimo","title":"Marimo","text":"<p>File: <code>pynodewidget_demo_marimo.py</code></p> <p>Reactive workflow in Marimo with automatic execution.</p> <p>Key concepts: Jupyter integration, reactive programming, AnyWidget communication.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<pre><code># Run any example\npython examples/node_class_example.py\n\n# Or in Jupyter\njupyter notebook examples/pynodewidget_demo.ipynb\n\n# Or in Marimo\nmarimo edit examples/pynodewidget_demo_marimo.py\n</code></pre>"},{"location":"examples/#custom-fields","title":"Custom Fields","text":"<p>Custom fields require JavaScript registration. See Field Registry for setup.</p>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>Most examples follow this pattern:</p> <ol> <li>Define Parameters - Pydantic models with Field validators</li> <li>Define Nodes - Classes extending <code>JsonSchemaNodeWidget</code></li> <li>Create Widget - <code>NodeFlowWidget(nodes=[...])</code></li> <li>Display - Show in Jupyter/Marimo</li> </ol>"},{"location":"examples/#complete-example","title":"Complete Example","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import NodeFlowWidget, JsonSchemaNodeWidget\n\n# 1. Define parameters\nclass InputParams(BaseModel):\n    value: float = Field(default=1.0, description=\"Input value\")\n\nclass ProcessParams(BaseModel):\n    multiplier: float = Field(default=2.0, ge=0, description=\"Multiplier\")\n\n# 2. Define nodes\nclass InputNode(JsonSchemaNodeWidget):\n    label = \"Input\"\n    parameters = InputParams\n    icon = \"\ud83d\udce5\"\n    outputs = [{\"id\": \"out\"}]\n\nclass ProcessNode(JsonSchemaNodeWidget):\n    label = \"Process\"\n    parameters = ProcessParams\n    icon = \"\u2699\ufe0f\"\n    inputs = [{\"id\": \"in\"}]\n    outputs = [{\"id\": \"out\"}]\n\n# 3. Create widget\nwidget = NodeFlowWidget(\n    nodes=[InputNode, ProcessNode],\n    height=\"600px\"\n)\n\n# 4. Display (in Jupyter)\nwidget\n</code></pre>"},{"location":"examples/#see-also","title":"See Also","text":"<ul> <li>Custom Nodes Guide - Creating custom nodes</li> <li>Field Registry - Custom field types</li> <li>Handle System - Custom handles</li> <li>GitHub Examples - Full source code</li> </ul>"},{"location":"getting-started/concepts/","title":"Core Concepts","text":"<p>Understanding these fundamental concepts will help you build powerful node-based workflows with PyNodeWidget.</p>"},{"location":"getting-started/concepts/#architecture-overview","title":"Architecture Overview","text":"<p>PyNodeWidget bridges Python and JavaScript using AnyWidget:</p> <pre><code>graph LR\n    A[Python Models] --&gt; B[JsonSchemaNodeWidget]\n    B --&gt; C[NodeFlowWidget]\n    C --&gt; D[AnyWidget Comm]\n    D --&gt; E[React UI]\n    E --&gt; D\n    D --&gt; C\n\n    style A fill:#e3f2fd\n    style B fill:#e3f2fd\n    style C fill:#e3f2fd\n    style D fill:#fff9c4\n    style E fill:#f3e5f5</code></pre> <p>All changes sync bidirectionally - Python updates reflect in the UI, and UI changes update Python.</p>"},{"location":"getting-started/concepts/#nodes","title":"Nodes","text":"<p>Nodes are the building blocks of your workflow. Each node represents a processing unit with:</p> <ul> <li>Parameters: Configurable values (defined with Pydantic)</li> <li>Inputs: Connection points for incoming data</li> <li>Outputs: Connection points for outgoing data</li> <li>Logic: Optional <code>execute()</code> method for processing</li> </ul>"},{"location":"getting-started/concepts/#node-anatomy","title":"Node Anatomy","text":"<pre><code>class MyNode(JsonSchemaNodeWidget):\n    # Visual properties\n    label = \"My Node\"           # Display name\n    icon = \"\u2699\ufe0f\"                 # Emoji icon\n    category = \"processing\"     # Grouping category\n\n    # Parameters (the form)\n    parameters = MyParamsModel\n\n    # Connections\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n\n    # Processing logic\n    def execute(self, inputs):\n        return {\"out\": processed_data}\n</code></pre>"},{"location":"getting-started/concepts/#node-types","title":"Node Types","text":"<p>PyNodeWidget supports different node patterns:</p>"},{"location":"getting-started/concepts/#data-source-nodes","title":"Data Source Nodes","text":"<p>No inputs, one or more outputs. Generate or load data.</p> <pre><code>class SourceNode(JsonSchemaNodeWidget):\n    outputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n    inputs = []  # No inputs\n</code></pre>"},{"location":"getting-started/concepts/#processing-nodes","title":"Processing Nodes","text":"<p>One or more inputs and outputs. Transform data.</p> <pre><code>class ProcessorNode(JsonSchemaNodeWidget):\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n</code></pre>"},{"location":"getting-started/concepts/#sink-nodes","title":"Sink Nodes","text":"<p>One or more inputs, no outputs. Save or display results.</p> <pre><code>class SinkNode(JsonSchemaNodeWidget):\n    inputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n    outputs = []  # No outputs\n</code></pre>"},{"location":"getting-started/concepts/#handles","title":"Handles","text":"<p>Handles are the connection points on nodes where edges attach.</p>"},{"location":"getting-started/concepts/#handle-configuration","title":"Handle Configuration","text":"<pre><code>inputs = [\n    {\n        \"id\": \"data_in\",      # Unique identifier\n        \"label\": \"Data\",      # Display label\n        \"type\": \"default\"     # Optional: ReactFlow handle type\n    }\n]\n\noutputs = [\n    {\n        \"id\": \"result\",\n        \"label\": \"Result\",\n        \"type\": \"default\"\n    }\n]\n</code></pre>"},{"location":"getting-started/concepts/#handle-types","title":"Handle Types","text":"<p>PyNodeWidget supports three handle types:</p>"},{"location":"getting-started/concepts/#base-handle-default","title":"Base Handle (default)","text":"<p>Standard ReactFlow handle - small dot.</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    handleType = \"base\"  # or omit for default\n</code></pre>"},{"location":"getting-started/concepts/#button-handle","title":"Button Handle","text":"<p>Larger, interactive button-style handle.</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    handleType = \"button\"\n</code></pre>"},{"location":"getting-started/concepts/#labeled-handle","title":"Labeled Handle","text":"<p>Handle with visible label on the canvas.</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    handleType = \"labeled\"\n</code></pre> <p>You can mix types:</p> <pre><code>class MixedNode(JsonSchemaNodeWidget):\n    inputHandleType = \"labeled\"\n    outputHandleType = \"button\"\n</code></pre>"},{"location":"getting-started/concepts/#parameters-and-values","title":"Parameters and Values","text":""},{"location":"getting-started/concepts/#defining-parameters","title":"Defining Parameters","text":"<p>Parameters use Pydantic models for type safety and validation:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass NodeParams(BaseModel):\n    # String with constraints\n    name: str = Field(\n        default=\"default\",\n        min_length=1,\n        max_length=50,\n        description=\"Node name\"\n    )\n\n    # Number with range\n    threshold: float = Field(\n        default=0.5,\n        ge=0,  # Greater than or equal\n        le=1,  # Less than or equal\n        description=\"Threshold value\"\n    )\n\n    # Boolean\n    enabled: bool = Field(\n        default=True,\n        description=\"Enable processing\"\n    )\n\n    # Enum (becomes dropdown)\n    mode: str = Field(\n        default=\"auto\",\n        pattern=\"^(auto|manual|advanced)$\",\n        description=\"Processing mode\"\n    )\n</code></pre> <p>The UI automatically generates appropriate inputs:</p> <ul> <li><code>str</code> \u2192 Text input</li> <li><code>int</code>, <code>float</code> \u2192 Number input</li> <li><code>bool</code> \u2192 Checkbox</li> <li>Enum/pattern \u2192 Dropdown select</li> </ul>"},{"location":"getting-started/concepts/#accessing-values","title":"Accessing Values","text":"<p>In Python, access node values through the widget:</p> <pre><code># Get all values for a node\nvalues = flow.get_node_values(\"node-1\")\nprint(values[\"threshold\"])\n\n# Update a single value\nflow.update_node_value(\"node-1\", \"threshold\", 0.8)\n\n# Get single value\nvalue = flow.get_node_value(\"node-1\", \"threshold\")\n\n# Update multiple values\nflow.set_node_values(\"node-1\", {\n    \"threshold\": 0.8,\n    \"enabled\": False\n})\n</code></pre> <p>In the node's <code>execute()</code> method:</p> <pre><code>def execute(self, inputs):\n    config = self.get_values()\n    threshold = config[\"threshold\"]\n    enabled = config[\"enabled\"]\n    # Use values...\n</code></pre>"},{"location":"getting-started/concepts/#edges","title":"Edges","text":"<p>Edges connect node handles and represent data flow.</p>"},{"location":"getting-started/concepts/#edge-structure","title":"Edge Structure","text":"<pre><code>{\n    \"id\": \"e1-2\",              # Unique edge ID\n    \"source\": \"node-1\",        # Source node ID\n    \"target\": \"node-2\",        # Target node ID\n    \"sourceHandle\": \"out\",     # Source handle ID\n    \"targetHandle\": \"in\"       # Target handle ID\n}\n</code></pre>"},{"location":"getting-started/concepts/#managing-edges","title":"Managing Edges","text":"<pre><code># Access edges\nedges = flow.edges\n\n# Add edge programmatically\nflow.edges = [\n    *flow.edges,\n    {\n        \"id\": \"new-edge\",\n        \"source\": \"node-1\",\n        \"target\": \"node-2\",\n        \"sourceHandle\": \"out\",\n        \"targetHandle\": \"in\"\n    }\n]\n\n# Clear all edges\nflow.edges = []\n</code></pre> <p>Users can also create edges in the UI by dragging from one handle to another.</p>"},{"location":"getting-started/concepts/#layouts","title":"Layouts","text":"<p>Layouts control how node content is arranged. PyNodeWidget provides three built-in layouts:</p>"},{"location":"getting-started/concepts/#horizontal-layout-default","title":"Horizontal Layout (default)","text":"<p>Inputs on the left, outputs on the right, form in the center.</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    layoutType = \"horizontal\"  # default\n</code></pre>"},{"location":"getting-started/concepts/#vertical-layout","title":"Vertical Layout","text":"<p>Inputs on top, outputs on bottom, form in the center.</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    layoutType = \"vertical\"\n</code></pre>"},{"location":"getting-started/concepts/#compact-layout","title":"Compact Layout","text":"<p>Minimal spacing, smaller appearance.</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    layoutType = \"compact\"\n</code></pre>"},{"location":"getting-started/concepts/#workflows","title":"Workflows","text":"<p>A workflow is the complete graph of nodes and edges representing your data pipeline.</p>"},{"location":"getting-started/concepts/#workflow-state","title":"Workflow State","text":"<p>The workflow consists of:</p> <pre><code>{\n    \"nodes\": [...],          # Array of node objects\n    \"edges\": [...],          # Array of edge objects\n    \"node_types\": {...},     # Registered node type definitions\n    \"node_values\": {...},    # Current parameter values\n    \"viewport\": {            # Canvas view state\n        \"x\": 0,\n        \"y\": 0,\n        \"zoom\": 1\n    }\n}\n</code></pre>"},{"location":"getting-started/concepts/#export-and-import","title":"Export and Import","text":"<p>Save workflows as JSON:</p> <pre><code># Export complete workflow\nworkflow = flow.export_flow()\n\n# Save to file\nimport json\nwith open(\"workflow.json\", \"w\") as f:\n    json.dump(workflow, f)\n\n# Load from file\nwith open(\"workflow.json\", \"r\") as f:\n    workflow = json.load(f)\n\n# Import workflow\nflow.import_flow(workflow)\n</code></pre> <p>This preserves:</p> <ul> <li>Node positions</li> <li>Connections</li> <li>Parameter values</li> <li>Node types (must be registered first)</li> </ul>"},{"location":"getting-started/concepts/#observable-state","title":"Observable State","text":"<p>PyNodeWidget uses ObservableDict for automatic synchronization:</p> <pre><code>from pynodewidget import ObservableDict\n\n# Dict that triggers callbacks on change\ndata = ObservableDict(callback=on_change)\n\ndata[\"key\"] = \"value\"  # Triggers callback\ndata.update({\"a\": 1})  # Also triggers callback\n</code></pre> <p>The <code>node_values</code> trait uses this internally, so any change to node values automatically syncs to the JavaScript UI.</p>"},{"location":"getting-started/concepts/#execution-model","title":"Execution Model","text":"<p>PyNodeWidget provides the structure for workflows, but execution semantics are up to you:</p> <pre><code>def execute_workflow(flow):\n    \"\"\"Example: Execute nodes in topological order.\"\"\"\n\n    # Get workflow state\n    nodes = flow.nodes\n    edges = flow.edges\n\n    # Build execution order (e.g., with networkx)\n    order = topological_sort(nodes, edges)\n\n    # Execute each node\n    results = {}\n    for node_id in order:\n        node = find_node(node_id)\n\n        # Gather inputs from connected nodes\n        inputs = {}\n        for edge in edges:\n            if edge[\"target\"] == node_id:\n                source_output = results[edge[\"source\"]][edge[\"sourceHandle\"]]\n                inputs[edge[\"targetHandle\"]] = source_output\n\n        # Execute node\n        outputs = node.execute(inputs)\n        results[node_id] = outputs\n\n    return results\n</code></pre> <p>This gives you flexibility to implement:</p> <ul> <li>Synchronous execution</li> <li>Async/parallel execution</li> <li>Lazy evaluation</li> <li>Dataflow engines</li> <li>Custom scheduling</li> </ul>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<p>Now that you understand the core concepts:</p> <ul> <li>Create Custom Nodes: Build advanced node types</li> <li>Explore Layouts: Style and arrange nodes</li> <li>Handle Types: Choose the right connection style</li> <li>API Reference: Dive into the complete API</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>PyNodeWidget requires Python 3.12 or higher and runs in Jupyter notebooks.</p>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install pynodewidget\n</code></pre> <p>Or using <code>uv</code>:</p> <pre><code>uv pip install pynodewidget\n</code></pre>"},{"location":"getting-started/installation/#install-with-documentation-dependencies","title":"Install with Documentation Dependencies","text":"<p>If you want to build the documentation locally:</p> <pre><code>pip install pynodewidget[docs]\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>To contribute or develop PyNodeWidget, you'll need additional tools:</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+: Core runtime</li> <li>Bun: JavaScript bundler (required for building JS assets)</li> <li>uv (optional): Fast Python package manager</li> </ul>"},{"location":"getting-started/installation/#clone-and-install","title":"Clone and Install","text":"<pre><code># Clone the repository\ngit clone https://github.com/HenningScheufler/pynodewidget.git\ncd pynodewidget\n\n# Install Python dependencies\nuv sync\n\n# Or with pip\npip install -e \".[dev,docs]\"\n\n# Build JavaScript assets\ncd js\nbun install\nbun run build\ncd ..\n</code></pre>"},{"location":"getting-started/installation/#development-workflow","title":"Development Workflow","text":"<p>The JavaScript frontend needs to be rebuilt when you make changes:</p> <pre><code># Development mode with hot reload\ncd js\nbun run dev\n\n# Production build\nbun run build\n</code></pre> <p>The built assets are automatically copied to <code>src/pynodewidget/static/</code> during the Python package build.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Test your installation in a Jupyter notebook:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\n# Create a simple widget\nwidget = NodeFlowWidget()\nwidget\n</code></pre> <p>You should see an empty node canvas with a toolbar.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>PyNodeWidget has the following core dependencies (automatically installed):</p> <ul> <li>anywidget &gt;= 0.9.0: Jupyter widget framework</li> <li>pydantic &gt;= 2.12.4: Data validation and schemas</li> <li>traitlets &gt;= 5.14.0: Observable attributes</li> </ul>"},{"location":"getting-started/installation/#jupyter-environments","title":"Jupyter Environments","text":"<p>PyNodeWidget works in:</p> <ul> <li>JupyterLab 4.0+</li> <li>Jupyter Notebook 7.0+</li> <li>VS Code Jupyter extension</li> <li>Google Colab (with some limitations)</li> <li>Marimo notebooks</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#widget-not-displaying","title":"Widget not displaying","text":"<p>If the widget doesn't appear, try:</p> <pre><code># Enable widget extensions in JupyterLab\njupyter labextension enable anywidget\n</code></pre>"},{"location":"getting-started/installation/#javascript-build-errors","title":"JavaScript build errors","text":"<p>Ensure Bun is installed correctly:</p> <pre><code>bun --version\n</code></pre> <p>If you see bundling errors, try cleaning the build:</p> <pre><code>cd js\nrm -rf node_modules dist\nbun install\nbun run build\n</code></pre>"},{"location":"getting-started/installation/#import-errors","title":"Import errors","text":"<p>Make sure you're using Python 3.12+:</p> <pre><code>python --version\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide: Create your first node workflow</li> <li>Core Concepts: Understand the key components</li> <li>API Reference: Explore the full API</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with PyNodeWidget in minutes. This guide walks you through creating your first interactive node-based workflow.</p>"},{"location":"getting-started/quickstart/#basic-widget","title":"Basic Widget","text":"<p>The simplest way to use PyNodeWidget is to create an empty canvas:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\n# Create widget\nflow = NodeFlowWidget()\n\n# Display in Jupyter\nflow\n</code></pre> <p>This creates an interactive canvas where you can add nodes manually using the UI.</p>"},{"location":"getting-started/quickstart/#creating-a-custom-node","title":"Creating a Custom Node","text":"<p>The real power comes from defining custom node types with Python:</p> <pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget, NodeFlowWidget\n\n# 1. Define parameters with Pydantic\nclass FilterParams(BaseModel):\n    threshold: float = Field(\n        default=0.5,\n        ge=0,\n        le=1,\n        description=\"Minimum value to pass through\"\n    )\n    enabled: bool = Field(\n        default=True,\n        description=\"Enable filtering\"\n    )\n\n# 2. Create node class\nclass FilterNode(JsonSchemaNodeWidget):\n    label = \"Filter\"\n    parameters = FilterParams\n    icon = \"\ud83d\udd0d\"\n    category = \"processing\"\n\n    # Define inputs and outputs\n    inputs = [\n        {\"id\": \"data_in\", \"label\": \"Input\"}\n    ]\n    outputs = [\n        {\"id\": \"data_out\", \"label\": \"Output\"}\n    ]\n\n    def execute(self, inputs):\n        \"\"\"Process data through the filter.\"\"\"\n        config = self.get_values()\n\n        if not config[\"enabled\"]:\n            return {\"data_out\": inputs.get(\"data_in\")}\n\n        # Filter logic\n        data = inputs.get(\"data_in\", [])\n        threshold = config[\"threshold\"]\n        filtered = [x for x in data if x &gt;= threshold]\n\n        return {\"data_out\": filtered}\n\n# 3. Create widget with node\nflow = NodeFlowWidget(nodes=[FilterNode])\nflow\n</code></pre> <p>When you display this widget:</p> <ol> <li>The \"Filter\" node appears in the left sidebar</li> <li>You can drag it onto the canvas</li> <li>The form shows threshold and enabled fields</li> <li>Changes sync automatically to Python</li> </ol>"},{"location":"getting-started/quickstart/#accessing-node-values","title":"Accessing Node Values","text":"<p>Read values from Python:</p> <pre><code># Get values for a specific node\nvalues = flow.get_node_values(\"node-id\")\nprint(values[\"threshold\"])  # 0.5\nprint(values[\"enabled\"])    # True\n\n# Update values from Python\nflow.update_node_value(\"node-id\", \"threshold\", 0.8)\n</code></pre>"},{"location":"getting-started/quickstart/#multiple-node-types","title":"Multiple Node Types","text":"<p>Register multiple node types for a complete workflow:</p> <pre><code>from pydantic import BaseModel, Field\n\n# Source node\nclass SourceParams(BaseModel):\n    count: int = Field(default=10, ge=1, le=100)\n\nclass SourceNode(JsonSchemaNodeWidget):\n    label = \"Data Source\"\n    parameters = SourceParams\n    icon = \"\ud83d\udce5\"\n    outputs = [{\"id\": \"out\", \"label\": \"Data\"}]\n\n    def execute(self, inputs):\n        count = self.get_values()[\"count\"]\n        data = list(range(count))\n        return {\"out\": data}\n\n# Sink node\nclass SinkParams(BaseModel):\n    format: str = Field(default=\"json\")\n\nclass SinkNode(JsonSchemaNodeWidget):\n    label = \"Data Sink\"\n    parameters = SinkParams\n    icon = \"\ud83d\udce4\"\n    inputs = [{\"id\": \"in\", \"label\": \"Data\"}]\n\n    def execute(self, inputs):\n        data = inputs.get(\"in\")\n        format_type = self.get_values()[\"format\"]\n        print(f\"Saving {len(data)} items as {format_type}\")\n        return {}\n\n# Create workflow\nflow = NodeFlowWidget(\n    nodes=[SourceNode, FilterNode, SinkNode],\n    height=\"600px\"\n)\nflow\n</code></pre> <p>Now you can:</p> <ol> <li>Drag all three node types onto the canvas</li> <li>Connect them: Source \u2192 Filter \u2192 Sink</li> <li>Adjust parameters in each node's form</li> <li>Execute the workflow</li> </ol>"},{"location":"getting-started/quickstart/#working-with-connections","title":"Working with Connections","text":"<p>Access the graph structure:</p> <pre><code># Get all edges\nprint(flow.edges)\n# [{'id': 'e1', 'source': 'node-1', 'target': 'node-2', ...}]\n\n# Get all nodes\nprint(flow.nodes)\n# [{'id': 'node-1', 'type': 'FilterNode', 'position': {...}, ...}]\n\n# Export workflow\nworkflow_json = flow.export_flow()\n\n# Import workflow\nflow.import_flow(workflow_json)\n</code></pre>"},{"location":"getting-started/quickstart/#styling-your-nodes","title":"Styling Your Nodes","text":"<p>Customize node appearance:</p> <pre><code>from pynodeflow.node_builder import with_style\n\nclass StyledNode(JsonSchemaNodeWidget):\n    label = \"Styled Node\"\n    parameters = FilterParams\n\n    # Add custom styling\n    style = {\n        \"minWidth\": \"300px\",\n        \"borderRadius\": \"8px\",\n        \"shadow\": \"lg\"\n    }\n\n    header = {\n        \"show\": True,\n        \"icon\": \"\u2728\",\n        \"bgColor\": \"bg-gradient-to-r from-purple-500 to-pink-500\",\n        \"textColor\": \"text-white\"\n    }\n</code></pre>"},{"location":"getting-started/quickstart/#conditional-fields","title":"Conditional Fields","text":"<p>Show/hide fields based on other field values:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass AdvancedParams(BaseModel):\n    mode: str = Field(default=\"simple\")\n    # Only shown when mode == \"advanced\"\n    threshold: float = Field(default=0.5, ge=0, le=1)\n    iterations: int = Field(default=10, ge=1)\n\nclass AdvancedNode(JsonSchemaNodeWidget):\n    label = \"Advanced Processor\"\n    parameters = AdvancedParams\n\n    # Configure field visibility\n    fieldConfigs = {\n        \"threshold\": {\n            \"showWhen\": {\n                \"field\": \"mode\",\n                \"operator\": \"equals\",\n                \"value\": \"advanced\"\n            }\n        },\n        \"iterations\": {\n            \"showWhen\": {\n                \"field\": \"mode\",\n                \"operator\": \"equals\",\n                \"value\": \"advanced\"\n            }\n        }\n    }\n</code></pre>"},{"location":"getting-started/quickstart/#auto-layout","title":"Auto-Layout","text":"<p>Let PyNodeWidget arrange your nodes automatically:</p> <pre><code># After adding nodes and connections\n# Click the \"Auto Layout\" button in the toolbar\n# Or programmatically (when feature is available)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've created your first nodes, explore:</p> <ul> <li>Core Concepts: Understand nodes, handles, and workflows</li> <li>Custom Nodes Guide: Advanced node creation techniques</li> <li>Custom Fields: Create specialized input types</li> <li>API Reference: Complete NodeFlowWidget documentation</li> </ul>"},{"location":"guides/","title":"User Guide","text":"<p>PyNodeWidget enables you to build node-based workflows entirely from Python. Define nodes with Pydantic models, and the UI is automatically generated.</p>"},{"location":"guides/#core-topics","title":"Core Topics","text":"<ul> <li> <p>:material-node: Creating Custom Nodes</p> <p>Create custom node types using Pydantic models with parameters, inputs, outputs, and execution logic.</p> </li> <li> <p> Styling Nodes</p> <p>Customize node appearance with headers, footers, colors, and layouts from Python.</p> </li> <li> <p> Grid Layouts</p> <p>Build complex node layouts efficiently with GridBuilder API and preset templates.</p> </li> <li> <p> Conditional Fields</p> <p>Show or hide fields dynamically based on other field values.</p> </li> <li> <p> Handle Types</p> <p>Configure connection point styles: base, button, or labeled handles.</p> </li> <li> <p> Working with Values</p> <p>Read and update node values from Python with automatic UI sync.</p> </li> <li> <p> Import/Export Workflows</p> <p>Save and load workflows as JSON for sharing and version control.</p> </li> </ul>"},{"location":"guides/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget, NodeFlowWidget\n\n# Define parameters with Pydantic\nclass FilterParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0, le=1)\n    enabled: bool = True\n\n# Create node class\nclass FilterNode(JsonSchemaNodeWidget):\n    label = \"Data Filter\"\n    parameters = FilterParams\n    icon = \"\ud83d\udd0d\"\n\n    inputs = [{\"id\": \"data_in\", \"label\": \"Data\"}]\n    outputs = [{\"id\": \"filtered\", \"label\": \"Filtered\"}]\n\n    def execute(self, inputs):\n        config = self.get_values()\n        if not config[\"enabled\"]:\n            return {\"filtered\": inputs[\"data_in\"]}\n        data = inputs[\"data_in\"]\n        return {\"filtered\": [x for x in data if x &gt;= config[\"threshold\"]]}\n\n# Create and display widget\nflow = NodeFlowWidget(nodes=[FilterNode])\nflow\n</code></pre>"},{"location":"guides/#architecture","title":"Architecture","text":"<p>PyNodeWidget uses AnyWidget to bridge Python and JavaScript:</p> <ul> <li>Python side: Define nodes, manage state, handle execution</li> <li>JavaScript side: Renders UI using ReactFlow (automatically managed)</li> <li>Bidirectional sync: Changes in Python update the UI, and vice versa</li> </ul> <pre><code># Python \u2192 UI\nflow.update_node_value(\"node-1\", \"threshold\", 0.8)\n\n# UI \u2192 Python (automatic)\nvalues = flow.get_node_values(\"node-1\")  # Shows user's changes\n</code></pre> <p>For architecture details, see Developer Documentation.</p>"},{"location":"guides/#key-concepts","title":"Key Concepts","text":""},{"location":"guides/#pydantic-models-define-ui","title":"Pydantic Models Define UI","text":"<p>UI is automatically generated from Pydantic models:</p> <pre><code>from pydantic import BaseModel, Field\nfrom typing import Literal\n\nclass Params(BaseModel):\n    name: str = Field(default=\"\", description=\"Name\")\n    threshold: float = Field(default=0.5, ge=0, le=1)  # Slider\n    enabled: bool = True  # Checkbox\n    mode: Literal[\"auto\", \"manual\"] = \"auto\"  # Dropdown\n</code></pre>"},{"location":"guides/#type-safe-configuration","title":"Type-Safe Configuration","text":"<p>Use Python dictionaries and Pydantic for configuration:</p> <pre><code>class MyNode(JsonSchemaNodeWidget):\n    label = \"My Node\"\n    parameters = MyParams\n    icon = \"\u2699\ufe0f\"\n    color = \"blue\"\n    layout_type = \"horizontal\"\n</code></pre>"},{"location":"guides/#automatic-sync","title":"Automatic Sync","text":"<p>ObservableDict enables automatic synchronization between Python and JavaScript without manual intervention.</p>"},{"location":"guides/#next-steps","title":"Next Steps","text":"<p>Start with Creating Custom Nodes to build your first node, then explore other guides as needed.</p>"},{"location":"guides/conditional-fields/","title":"Conditional Fields","text":"<p>Show or hide fields dynamically based on other field values.</p>"},{"location":"guides/conditional-fields/#overview","title":"Overview","text":"<p>Conditional fields allow you to create adaptive UIs where certain configuration options only appear when relevant. This reduces clutter and guides users through complex configurations.</p> <p>Use cases: - Show advanced options only when \"Advanced Mode\" is enabled - Display authentication fields only when authentication type is selected - Show file format options based on selected file type - Reveal connection settings only when custom endpoint is chosen</p>"},{"location":"guides/conditional-fields/#basic-conditional-fields","title":"Basic Conditional Fields","text":""},{"location":"guides/conditional-fields/#using-node_builder","title":"Using node_builder","text":"<p>The simplest approach uses <code>create_conditional_field()</code>:</p> <pre><code>from pynodeflow.node_builder import create_conditional_field\n\n# Show \"api_key\" field only when \"use_auth\" is True\nfield_config = create_conditional_field(\n    trigger_field=\"use_auth\",\n    trigger_value=True,\n    operator=\"equals\"\n)\n\n# Result: {\"showWhen\": {\"field\": \"use_auth\", \"operator\": \"equals\", \"value\": True}}\n</code></pre>"},{"location":"guides/conditional-fields/#in-node-configuration","title":"In Node Configuration","text":"<p>Apply to node templates:</p> <pre><code>from pynodewidget import NodeFlowWidget\nfrom pynodeflow.node_builder import create_form_node, create_conditional_field\n\n# Create base node\nconfig = create_form_node(\n    type_name=\"api-client\",\n    label=\"API Client\",\n    fields={\n        \"use_auth\": {\"type\": \"boolean\", \"default\": False, \"title\": \"Use Authentication\"},\n        \"api_key\": {\"type\": \"string\", \"default\": \"\", \"title\": \"API Key\"}\n    }\n)\n\n# Add conditional visibility\nconfig[\"field_configs\"] = {\n    \"api_key\": create_conditional_field(\"use_auth\", True)\n}\n\n# Register node\nflow = NodeFlowWidget()\nflow.add_node_type_from_schema(\n    json_schema=config.get(\"parameters\", {}),\n    type_name=\"api-client\",\n    label=\"API Client\"\n)\n</code></pre>"},{"location":"guides/conditional-fields/#multiple-conditional-fields","title":"Multiple Conditional Fields","text":"<p>Use <code>make_fields_conditional()</code> to set up multiple fields at once:</p> <pre><code>from pynodeflow.node_builder import make_fields_conditional\n\n# Show multiple fields when mode is \"advanced\"\nfield_configs = make_fields_conditional(\n    trigger_field=\"mode\",\n    trigger_value=\"advanced\",\n    dependent_fields=[\"timeout\", \"retry_count\", \"max_connections\"],\n    operator=\"equals\"\n)\n\n# Result: All three fields get the same showWhen condition\n</code></pre>"},{"location":"guides/conditional-fields/#complete-example","title":"Complete Example","text":"<pre><code>from pynodewidget import NodeFlowWidget\nfrom pynodeflow.node_builder import create_form_node, make_fields_conditional\n\nconfig = create_form_node(\n    type_name=\"processor\",\n    label=\"Data Processor\",\n    fields={\n        \"mode\": {\n            \"type\": \"string\",\n            \"enum\": [\"simple\", \"advanced\"],\n            \"default\": \"simple\",\n            \"title\": \"Processing Mode\"\n        },\n        # Simple mode fields (always visible)\n        \"input_file\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Input File\"},\n\n        # Advanced mode fields (conditional)\n        \"chunk_size\": {\"type\": \"integer\", \"default\": 1000, \"title\": \"Chunk Size\"},\n        \"parallel\": {\"type\": \"boolean\", \"default\": False, \"title\": \"Parallel Processing\"},\n        \"cache_results\": {\"type\": \"boolean\", \"default\": True, \"title\": \"Cache Results\"}\n    }\n)\n\n# Hide advanced fields until mode is \"advanced\"\nconfig[\"field_configs\"] = make_fields_conditional(\n    trigger_field=\"mode\",\n    trigger_value=\"advanced\",\n    dependent_fields=[\"chunk_size\", \"parallel\", \"cache_results\"]\n)\n</code></pre>"},{"location":"guides/conditional-fields/#condition-operators","title":"Condition Operators","text":"<p>Available comparison operators:</p>"},{"location":"guides/conditional-fields/#equals","title":"equals","text":"<p>Field value equals trigger value:</p> <pre><code>create_conditional_field(\"mode\", \"advanced\", operator=\"equals\")\n# Shows field when: mode == \"advanced\"\n</code></pre>"},{"location":"guides/conditional-fields/#notequals","title":"notEquals","text":"<p>Field value does not equal trigger value:</p> <pre><code>create_conditional_field(\"status\", \"disabled\", operator=\"notEquals\")\n# Shows field when: status != \"disabled\"\n</code></pre>"},{"location":"guides/conditional-fields/#greaterthan","title":"greaterThan","text":"<p>Field value is greater than trigger value:</p> <pre><code>create_conditional_field(\"count\", 10, operator=\"greaterThan\")\n# Shows field when: count &gt; 10\n</code></pre>"},{"location":"guides/conditional-fields/#lessthan","title":"lessThan","text":"<p>Field value is less than trigger value:</p> <pre><code>create_conditional_field(\"threshold\", 0.5, operator=\"lessThan\")\n# Shows field when: threshold &lt; 0.5\n</code></pre>"},{"location":"guides/conditional-fields/#contains","title":"contains","text":"<p>Field value (string or list) contains trigger value:</p> <pre><code>create_conditional_field(\"tags\", \"experimental\", operator=\"contains\")\n# Shows field when: \"experimental\" in tags\n</code></pre>"},{"location":"guides/conditional-fields/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/conditional-fields/#authentication-fields","title":"Authentication Fields","text":"<p>Show credentials based on auth type:</p> <pre><code>from pynodeflow.node_builder import create_form_node\n\nconfig = create_form_node(\n    type_name=\"auth-client\",\n    label=\"Authenticated Client\",\n    fields={\n        \"auth_type\": {\n            \"type\": \"string\",\n            \"enum\": [\"none\", \"api_key\", \"oauth\", \"basic\"],\n            \"default\": \"none\",\n            \"title\": \"Authentication Type\"\n        },\n        # API Key auth\n        \"api_key\": {\"type\": \"string\", \"default\": \"\", \"title\": \"API Key\"},\n\n        # OAuth auth\n        \"client_id\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Client ID\"},\n        \"client_secret\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Client Secret\"},\n\n        # Basic auth\n        \"username\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Username\"},\n        \"password\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Password\"}\n    }\n)\n\n# Show relevant fields based on auth type\nconfig[\"field_configs\"] = {\n    \"api_key\": create_conditional_field(\"auth_type\", \"api_key\"),\n    \"client_id\": create_conditional_field(\"auth_type\", \"oauth\"),\n    \"client_secret\": create_conditional_field(\"auth_type\", \"oauth\"),\n    \"username\": create_conditional_field(\"auth_type\", \"basic\"),\n    \"password\": create_conditional_field(\"auth_type\", \"basic\")\n}\n</code></pre>"},{"location":"guides/conditional-fields/#file-format-options","title":"File Format Options","text":"<p>Show format-specific options:</p> <pre><code>config = create_form_node(\n    type_name=\"file-loader\",\n    label=\"File Loader\",\n    fields={\n        \"format\": {\n            \"type\": \"string\",\n            \"enum\": [\"csv\", \"json\", \"parquet\", \"excel\"],\n            \"default\": \"csv\",\n            \"title\": \"File Format\"\n        },\n        # CSV options\n        \"delimiter\": {\"type\": \"string\", \"default\": \",\", \"title\": \"Delimiter\"},\n        \"skip_rows\": {\"type\": \"integer\", \"default\": 0, \"title\": \"Skip Rows\"},\n\n        # JSON options\n        \"json_path\": {\"type\": \"string\", \"default\": \"$\", \"title\": \"JSON Path\"},\n\n        # Excel options\n        \"sheet_name\": {\"type\": \"string\", \"default\": \"Sheet1\", \"title\": \"Sheet Name\"}\n    }\n)\n\nconfig[\"field_configs\"] = {\n    \"delimiter\": create_conditional_field(\"format\", \"csv\"),\n    \"skip_rows\": create_conditional_field(\"format\", \"csv\"),\n    \"json_path\": create_conditional_field(\"format\", \"json\"),\n    \"sheet_name\": create_conditional_field(\"format\", \"excel\")\n}\n</code></pre>"},{"location":"guides/conditional-fields/#advanced-mode-toggle","title":"Advanced Mode Toggle","text":"<p>Simple/advanced mode switching:</p> <pre><code>config = create_form_node(\n    type_name=\"configurator\",\n    label=\"Configurator\",\n    fields={\n        \"mode\": {\n            \"type\": \"string\",\n            \"enum\": [\"simple\", \"advanced\"],\n            \"default\": \"simple\",\n            \"title\": \"Mode\"\n        },\n        # Simple mode (always visible)\n        \"name\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Name\"},\n\n        # Advanced mode (conditional)\n        \"timeout\": {\"type\": \"number\", \"default\": 30, \"title\": \"Timeout (seconds)\"},\n        \"retry_count\": {\"type\": \"integer\", \"default\": 3, \"title\": \"Retry Count\"},\n        \"debug\": {\"type\": \"boolean\", \"default\": False, \"title\": \"Debug Mode\"},\n        \"log_level\": {\n            \"type\": \"string\",\n            \"enum\": [\"info\", \"debug\", \"warning\", \"error\"],\n            \"default\": \"info\",\n            \"title\": \"Log Level\"\n        }\n    }\n)\n\nconfig[\"field_configs\"] = make_fields_conditional(\n    trigger_field=\"mode\",\n    trigger_value=\"advanced\",\n    dependent_fields=[\"timeout\", \"retry_count\", \"debug\", \"log_level\"]\n)\n</code></pre>"},{"location":"guides/conditional-fields/#connection-settings","title":"Connection Settings","text":"<p>Custom vs. predefined endpoints:</p> <pre><code>config = create_form_node(\n    type_name=\"api-connector\",\n    label=\"API Connector\",\n    fields={\n        \"endpoint_type\": {\n            \"type\": \"string\",\n            \"enum\": [\"production\", \"staging\", \"custom\"],\n            \"default\": \"production\",\n            \"title\": \"Endpoint\"\n        },\n        # Custom endpoint fields\n        \"custom_url\": {\"type\": \"string\", \"default\": \"\", \"title\": \"Custom URL\"},\n        \"custom_port\": {\"type\": \"integer\", \"default\": 443, \"title\": \"Port\"},\n        \"use_ssl\": {\"type\": \"boolean\", \"default\": True, \"title\": \"Use SSL\"}\n    }\n)\n\nconfig[\"field_configs\"] = make_fields_conditional(\n    trigger_field=\"endpoint_type\",\n    trigger_value=\"custom\",\n    dependent_fields=[\"custom_url\", \"custom_port\", \"use_ssl\"]\n)\n</code></pre>"},{"location":"guides/conditional-fields/#complex-conditions","title":"Complex Conditions","text":""},{"location":"guides/conditional-fields/#chaining-conditions","title":"Chaining Conditions","text":"<p>Multiple levels of conditional visibility:</p> <pre><code>config = create_form_node(\n    type_name=\"multi-level\",\n    label=\"Multi-Level Config\",\n    fields={\n        \"enable_feature\": {\"type\": \"boolean\", \"default\": False},\n        \"feature_mode\": {\"type\": \"string\", \"enum\": [\"basic\", \"advanced\"], \"default\": \"basic\"},\n        \"advanced_option\": {\"type\": \"string\", \"default\": \"\"}\n    }\n)\n\nconfig[\"field_configs\"] = {\n    # Show feature_mode only if enable_feature is True\n    \"feature_mode\": create_conditional_field(\"enable_feature\", True),\n\n    # Show advanced_option only if feature_mode is \"advanced\"\n    # (also requires enable_feature to be True)\n    \"advanced_option\": create_conditional_field(\"feature_mode\", \"advanced\")\n}\n</code></pre>"},{"location":"guides/conditional-fields/#threshold-based","title":"Threshold-Based","text":"<p>Show fields when value exceeds threshold:</p> <pre><code>config = create_form_node(\n    type_name=\"threshold-config\",\n    label=\"Threshold Config\",\n    fields={\n        \"sample_size\": {\"type\": \"integer\", \"default\": 10, \"title\": \"Sample Size\"},\n        \"batch_processing\": {\"type\": \"boolean\", \"default\": False, \"title\": \"Batch Processing\"},\n        \"batch_size\": {\"type\": \"integer\", \"default\": 100, \"title\": \"Batch Size\"}\n    }\n)\n\nconfig[\"field_configs\"] = {\n    # Show batch processing option when sample size &gt; 100\n    \"batch_processing\": create_conditional_field(\"sample_size\", 100, operator=\"greaterThan\"),\n\n    # Show batch size when batch processing is enabled\n    \"batch_size\": create_conditional_field(\"batch_processing\", True)\n}\n</code></pre>"},{"location":"guides/conditional-fields/#multi-value-conditions","title":"Multi-Value Conditions","text":"<p>Different fields for different selections:</p> <pre><code>config = create_form_node(\n    type_name=\"output-config\",\n    label=\"Output Config\",\n    fields={\n        \"output_format\": {\"type\": \"string\", \"enum\": [\"screen\", \"file\", \"api\"], \"default\": \"screen\"},\n\n        # File output options\n        \"file_path\": {\"type\": \"string\", \"default\": \"\"},\n        \"overwrite\": {\"type\": \"boolean\", \"default\": False},\n\n        # API output options\n        \"api_endpoint\": {\"type\": \"string\", \"default\": \"\"},\n        \"api_key\": {\"type\": \"string\", \"default\": \"\"}\n    }\n)\n\nconfig[\"field_configs\"] = {\n    # File options\n    \"file_path\": create_conditional_field(\"output_format\", \"file\"),\n    \"overwrite\": create_conditional_field(\"output_format\", \"file\"),\n\n    # API options\n    \"api_endpoint\": create_conditional_field(\"output_format\", \"api\"),\n    \"api_key\": create_conditional_field(\"output_format\", \"api\")\n}\n</code></pre>"},{"location":"guides/conditional-fields/#with-pydantic-models","title":"With Pydantic Models","text":"<p>When using class-based nodes, apply conditions in JSON schema:</p> <pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget\n\nclass ProcessorParams(BaseModel):\n    mode: str = Field(default=\"simple\", pattern=\"^(simple|advanced)$\")\n    name: str = \"\"\n    timeout: float = 30.0\n    retry_count: int = 3\n\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n        # Add conditional field configurations\n        # This modifies the generated JSON schema\n        if \"parameters\" in self.data:\n            schema = self.data[\"parameters\"]\n\n            # Add showWhen to advanced fields\n            if \"properties\" in schema:\n                if \"timeout\" in schema[\"properties\"]:\n                    schema[\"properties\"][\"timeout\"][\"showWhen\"] = {\n                        \"field\": \"mode\",\n                        \"operator\": \"equals\",\n                        \"value\": \"advanced\"\n                    }\n                if \"retry_count\" in schema[\"properties\"]:\n                    schema[\"properties\"][\"retry_count\"][\"showWhen\"] = {\n                        \"field\": \"mode\",\n                        \"operator\": \"equals\",\n                        \"value\": \"advanced\"\n                    }\n</code></pre> <p>Note: This approach is more verbose. Consider using factory functions for complex conditional logic.</p>"},{"location":"guides/conditional-fields/#real-world-example","title":"Real-World Example","text":"<p>Complete authenticated data loader:</p> <pre><code>from pynodewidget import NodeFlowWidget\nfrom pynodeflow.node_builder import create_processing_node, make_fields_conditional\n\nconfig = create_processing_node(\n    type_name=\"secure-loader\",\n    label=\"Secure Data Loader\",\n    icon=\"\ud83d\udd12\"\n)\n\n# Define comprehensive fields\nconfig[\"parameters\"] = {\n    \"type\": \"object\",\n    \"properties\": {\n        # Data source\n        \"source_type\": {\n            \"type\": \"string\",\n            \"enum\": [\"local\", \"remote\"],\n            \"default\": \"local\",\n            \"title\": \"Source Type\"\n        },\n\n        # Local source\n        \"file_path\": {\n            \"type\": \"string\",\n            \"default\": \"\",\n            \"title\": \"File Path\"\n        },\n\n        # Remote source\n        \"url\": {\n            \"type\": \"string\",\n            \"default\": \"\",\n            \"title\": \"URL\"\n        },\n        \"use_auth\": {\n            \"type\": \"boolean\",\n            \"default\": False,\n            \"title\": \"Use Authentication\"\n        },\n\n        # Authentication\n        \"auth_method\": {\n            \"type\": \"string\",\n            \"enum\": [\"bearer\", \"basic\", \"api_key\"],\n            \"default\": \"bearer\",\n            \"title\": \"Auth Method\"\n        },\n        \"token\": {\n            \"type\": \"string\",\n            \"default\": \"\",\n            \"title\": \"Token\"\n        },\n        \"username\": {\n            \"type\": \"string\",\n            \"default\": \"\",\n            \"title\": \"Username\"\n        },\n        \"password\": {\n            \"type\": \"string\",\n            \"default\": \"\",\n            \"title\": \"Password\"\n        },\n        \"api_key\": {\n            \"type\": \"string\",\n            \"default\": \"\",\n            \"title\": \"API Key\"\n        },\n\n        # Advanced options\n        \"show_advanced\": {\n            \"type\": \"boolean\",\n            \"default\": False,\n            \"title\": \"Show Advanced Options\"\n        },\n        \"timeout\": {\n            \"type\": \"number\",\n            \"default\": 30,\n            \"title\": \"Timeout (seconds)\"\n        },\n        \"retry_attempts\": {\n            \"type\": \"integer\",\n            \"default\": 3,\n            \"title\": \"Retry Attempts\"\n        }\n    }\n}\n\n# Set up conditional visibility\nfrom pynodeflow.node_builder import create_conditional_field\n\nconfig[\"field_configs\"] = {\n    # Local source\n    \"file_path\": create_conditional_field(\"source_type\", \"local\"),\n\n    # Remote source\n    \"url\": create_conditional_field(\"source_type\", \"remote\"),\n    \"use_auth\": create_conditional_field(\"source_type\", \"remote\"),\n\n    # Authentication\n    \"auth_method\": create_conditional_field(\"use_auth\", True),\n\n    # Auth method-specific fields\n    \"token\": create_conditional_field(\"auth_method\", \"bearer\"),\n    \"username\": create_conditional_field(\"auth_method\", \"basic\"),\n    \"password\": create_conditional_field(\"auth_method\", \"basic\"),\n    \"api_key\": create_conditional_field(\"auth_method\", \"api_key\"),\n\n    # Advanced options\n    \"timeout\": create_conditional_field(\"show_advanced\", True),\n    \"retry_attempts\": create_conditional_field(\"show_advanced\", True)\n}\n\n# Register\nflow = NodeFlowWidget()\nflow.add_node_type_from_schema(\n    json_schema=config[\"parameters\"],\n    type_name=\"secure-loader\",\n    label=\"Secure Data Loader\"\n)\n</code></pre>"},{"location":"guides/conditional-fields/#best-practices","title":"Best Practices","text":"<ul> <li>Clear triggers: Use descriptive field names</li> <li>Logical grouping: Group related conditional fields</li> <li>Sensible defaults: Provide good defaults even for hidden fields</li> <li>Avoid deep nesting: Limit chains to 2-3 levels</li> <li>Document dependencies: Comment conditional relationships</li> </ul>"},{"location":"guides/conditional-fields/#troubleshooting","title":"Troubleshooting","text":"<p>Fields not showing/hiding: Check trigger field name matches exactly.</p> <p>Condition not evaluating: Verify operator matches value type (e.g., use <code>\"equals\"</code> for booleans, not <code>\"contains\"</code>).</p> <p>Complex conditions not working: Break into simpler chained conditions.</p>"},{"location":"guides/conditional-fields/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Custom Nodes: Build custom nodes with conditional fields</li> <li>Styling Nodes: Style conditional fields</li> </ul>"},{"location":"guides/custom-nodes/","title":"Creating Custom Nodes","text":"<p>Learn how to create custom nodes with Pydantic models for type-safe configuration.</p>"},{"location":"guides/custom-nodes/#overview","title":"Overview","text":"<p>PyNodeWidget provides two main approaches for creating custom nodes:</p> <ol> <li>Class-based nodes (Recommended): Inherit from <code>JsonSchemaNodeWidget</code> and define node behavior using class attributes</li> <li>Factory functions: Use helper functions from <code>node_builder</code> for quick node creation</li> </ol> <p>Both approaches use Pydantic models to define node parameters with automatic validation and JSON schema generation.</p>"},{"location":"guides/custom-nodes/#class-based-nodes-recommended","title":"Class-Based Nodes (Recommended)","text":""},{"location":"guides/custom-nodes/#minimal-node","title":"Minimal Node","text":"<p>The simplest node requires just three things:</p> <pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget\n\nclass MyParams(BaseModel):\n    \"\"\"Configuration parameters for the node.\"\"\"\n    name: str = Field(default=\"default\", description=\"Name parameter\")\n    value: int = Field(default=42, description=\"Numeric value\")\n\nclass MyNode(JsonSchemaNodeWidget):\n    \"\"\"A minimal custom node.\"\"\"\n    label = \"My Node\"\n    parameters = MyParams\n</code></pre> <p>Required attributes:</p> <ul> <li><code>label</code>: Display name shown in the node</li> <li><code>parameters</code>: Pydantic <code>BaseModel</code> class defining configuration fields</li> </ul>"},{"location":"guides/custom-nodes/#full-featured-node","title":"Full-Featured Node","text":"<p>Add optional attributes for more functionality:</p> <pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget\n\nclass ProcessingParams(BaseModel):\n    threshold: float = Field(default=0.5, ge=0.0, le=1.0)\n    mode: str = Field(default=\"auto\", pattern=\"^(auto|manual|advanced)$\")\n    enabled: bool = Field(default=True)\n\nclass ProcessingNode(JsonSchemaNodeWidget):\n    # Required\n    label = \"Image Processor\"\n    parameters = ProcessingParams\n\n    # Optional metadata\n    icon = \"\ud83d\uddbc\ufe0f\"\n    category = \"processing\"\n    description = \"Process images with configurable settings\"\n\n    # Optional connection points\n    inputs = [{\"id\": \"image\", \"label\": \"Input Image\"}]\n    outputs = [\n        {\"id\": \"processed\", \"label\": \"Processed Image\"},\n        {\"id\": \"metadata\", \"label\": \"Metadata\"}\n    ]\n\n    # Optional layout\n    layout_type = \"horizontal\"  # or \"vertical\"\n    handle_type = \"base\"  # or \"button\", \"labeled\"\n</code></pre> <p>Optional attributes:</p> <ul> <li><code>icon</code>: Emoji or Lucide icon name (e.g., <code>\"image\"</code>, <code>\"\u2699\ufe0f\"</code>)</li> <li><code>category</code>: Organization category (e.g., <code>\"input\"</code>, <code>\"processing\"</code>, <code>\"output\"</code>)</li> <li><code>description</code>: Tooltip text shown on hover</li> <li><code>inputs</code>: List of input handles (connection points)</li> <li><code>outputs</code>: List of output handles</li> <li><code>layout_type</code>: Field layout (<code>\"horizontal\"</code> or <code>\"vertical\"</code>)</li> <li><code>handle_type</code>: Handle style (<code>\"base\"</code>, <code>\"button\"</code>, or <code>\"labeled\"</code>)</li> </ul>"},{"location":"guides/custom-nodes/#using-pydantic-models","title":"Using Pydantic Models","text":""},{"location":"guides/custom-nodes/#field-types","title":"Field Types","text":"<p>Pydantic supports many field types with automatic validation:</p> <pre><code>from pydantic import BaseModel, Field\nfrom typing import Literal\n\nclass NodeParams(BaseModel):\n    # Strings\n    name: str = Field(default=\"\", description=\"Name\")\n    mode: Literal[\"auto\", \"manual\"] = \"auto\"  # Dropdown\n\n    # Numbers\n    count: int = Field(default=10, ge=1, le=100)  # Integer with range\n    threshold: float = Field(default=0.5, ge=0.0, le=1.0)  # Float with range\n\n    # Booleans\n    enabled: bool = True\n\n    # Complex types\n    tags: list[str] = Field(default_factory=list)\n    config: dict[str, Any] = Field(default_factory=dict)\n</code></pre>"},{"location":"guides/custom-nodes/#field-constraints","title":"Field Constraints","text":"<p>Use Pydantic's validation features:</p> <pre><code>from pydantic import BaseModel, Field, field_validator\n\nclass ValidatedParams(BaseModel):\n    email: str = Field(pattern=r\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\")\n    age: int = Field(ge=0, le=120)\n    score: float = Field(ge=0.0, le=1.0, multiple_of=0.1)\n\n    @field_validator(\"email\")\n    def validate_email(cls, v):\n        if not \"@\" in v:\n            raise ValueError(\"Invalid email address\")\n        return v.lower()\n</code></pre>"},{"location":"guides/custom-nodes/#field-descriptions","title":"Field Descriptions","text":"<p>Add descriptions for better UI and documentation:</p> <pre><code>class DocumentedParams(BaseModel):\n    threshold: float = Field(\n        default=0.5,\n        ge=0.0,\n        le=1.0,\n        description=\"Detection threshold (higher = stricter)\"\n    )\n    mode: str = Field(\n        default=\"auto\",\n        description=\"Processing mode: auto, manual, or advanced\"\n    )\n</code></pre> <p>Descriptions appear as: - Tooltips in the UI - Documentation in generated docs - Help text for users</p>"},{"location":"guides/custom-nodes/#registering-nodes","title":"Registering Nodes","text":""},{"location":"guides/custom-nodes/#single-node-registration","title":"Single Node Registration","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\nflow.register_node(MyNode)\n</code></pre>"},{"location":"guides/custom-nodes/#batch-registration","title":"Batch Registration","text":"<p>Register multiple nodes at widget creation:</p> <pre><code>flow = NodeFlowWidget(\n    nodes=[\n        DataLoaderNode,\n        ProcessingNode,\n        VisualizationNode\n    ]\n)\n</code></pre>"},{"location":"guides/custom-nodes/#registration-validation","title":"Registration Validation","text":"<p>PyNodeWidget validates nodes during registration:</p> <pre><code># \u2705 Valid node\nclass ValidNode(JsonSchemaNodeWidget):\n    label = \"Valid\"\n    parameters = ValidParams\n\nflow.register_node(ValidNode)  # OK\n\n# \u274c Invalid node (missing label)\nclass InvalidNode(JsonSchemaNodeWidget):\n    parameters = ValidParams\n\nflow.register_node(InvalidNode)  # Raises ValueError\n</code></pre>"},{"location":"guides/custom-nodes/#node-instances","title":"Node Instances","text":""},{"location":"guides/custom-nodes/#creating-instances","title":"Creating Instances","text":"<p>Create node instances with initial values:</p> <pre><code># With defaults\nnode = ProcessingNode()\n\n# With custom values\nnode = ProcessingNode(threshold=0.75, mode=\"manual\")\n\n# Keyword arguments become field values\nnode = ProcessingNode(\n    threshold=0.9,\n    mode=\"advanced\",\n    enabled=False\n)\n</code></pre>"},{"location":"guides/custom-nodes/#getting-values","title":"Getting Values","text":"<pre><code># Get all values\nvalues = node.get_values()\n# {\"threshold\": 0.75, \"mode\": \"manual\", \"enabled\": True}\n\n# Get single value\nthreshold = values[\"threshold\"]\n</code></pre>"},{"location":"guides/custom-nodes/#setting-values","title":"Setting Values","text":"<pre><code># Set multiple values\nnode.set_values({\"threshold\": 0.8, \"mode\": \"auto\"})\n\n# Set single value\nnode.set_value(\"enabled\", False)\n\n# Direct attribute access (if using custom properties)\n# Note: This doesn't sync to UI, use set_value instead\n</code></pre>"},{"location":"guides/custom-nodes/#validation","title":"Validation","text":"<pre><code># Validate current configuration\nis_valid = node.validate()\n\nif is_valid:\n    result = node.execute(inputs)\nelse:\n    print(\"Invalid configuration\")\n</code></pre>"},{"location":"guides/custom-nodes/#connection-points-handles","title":"Connection Points (Handles)","text":""},{"location":"guides/custom-nodes/#simple-handles","title":"Simple Handles","text":"<p>Define handles as lists of dictionaries:</p> <pre><code>class SimpleNode(JsonSchemaNodeWidget):\n    label = \"Simple\"\n    parameters = SimpleParams\n\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n</code></pre>"},{"location":"guides/custom-nodes/#multiple-handles","title":"Multiple Handles","text":"<pre><code>class MultiHandleNode(JsonSchemaNodeWidget):\n    label = \"Multi-Handle\"\n    parameters = Params\n\n    inputs = [\n        {\"id\": \"data\", \"label\": \"Data Input\"},\n        {\"id\": \"config\", \"label\": \"Configuration\"}\n    ]\n    outputs = [\n        {\"id\": \"result\", \"label\": \"Result\"},\n        {\"id\": \"metadata\", \"label\": \"Metadata\"},\n        {\"id\": \"errors\", \"label\": \"Errors\"}\n    ]\n</code></pre>"},{"location":"guides/custom-nodes/#typed-handles-with-pydantic","title":"Typed Handles with Pydantic","text":"<p>For type safety, use Pydantic models:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass DataLoaderInputs(BaseModel):\n    \"\"\"No inputs - source node.\"\"\"\n    pass\n\nclass DataLoaderOutputs(BaseModel):\n    \"\"\"Typed outputs.\"\"\"\n    data: str = Field(description=\"Loaded data\")\n    metadata: str = Field(description=\"File metadata\")\n\nclass DataLoaderNode(JsonSchemaNodeWidget):\n    label = \"Data Loader\"\n    parameters = LoaderParams\n    inputs = DataLoaderInputs  # Empty = no inputs\n    outputs = DataLoaderOutputs  # Auto-generates handles\n</code></pre> <p>The widget automatically converts Pydantic models to handle configurations.</p>"},{"location":"guides/custom-nodes/#source-and-sink-nodes","title":"Source and Sink Nodes","text":"<p>Source nodes (no inputs):</p> <pre><code>class SourceNode(JsonSchemaNodeWidget):\n    label = \"Data Source\"\n    parameters = SourceParams\n    inputs = []  # No inputs\n    outputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n</code></pre> <p>Sink nodes (no outputs):</p> <pre><code>class SinkNode(JsonSchemaNodeWidget):\n    label = \"Data Output\"\n    parameters = OutputParams\n    inputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n    outputs = []  # No outputs\n</code></pre>"},{"location":"guides/custom-nodes/#node-execution","title":"Node Execution","text":""},{"location":"guides/custom-nodes/#the-execute-method","title":"The execute Method","text":"<p>Override <code>execute()</code> to add processing logic:</p> <pre><code>class ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    inputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n    outputs = [{\"id\": \"result\", \"label\": \"Result\"}]\n\n    def execute(self, inputs: dict) -&gt; dict:\n        \"\"\"Process input data.\"\"\"\n        # Get current configuration\n        config = self.get_values()\n\n        # Get input data\n        data = inputs.get(\"data\")\n\n        if data is None:\n            return {\"result\": None}\n\n        # Process\n        threshold = config[\"threshold\"]\n        result = data * threshold\n\n        return {\"result\": result}\n</code></pre> <p>Method signature:</p> <ul> <li>Input: <code>inputs</code> - dict mapping handle IDs to data</li> <li>Output: dict mapping output handle IDs to data</li> </ul>"},{"location":"guides/custom-nodes/#error-handling","title":"Error Handling","text":"<pre><code>def execute(self, inputs: dict) -&gt; dict:\n    \"\"\"Execute with error handling.\"\"\"\n    try:\n        data = inputs.get(\"data\")\n\n        if data is None:\n            raise ValueError(\"No input data\")\n\n        config = self.get_values()\n        result = self._process(data, config)\n\n        return {\"result\": result}\n\n    except Exception as e:\n        # Return error on error output\n        return {\n            \"result\": None,\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"guides/custom-nodes/#validation-before-execution","title":"Validation Before Execution","text":"<pre><code>def execute(self, inputs: dict) -&gt; dict:\n    \"\"\"Execute with input validation.\"\"\"\n    # Validate configuration\n    if not self.validate():\n        return {\"error\": \"Invalid configuration\"}\n\n    # Validate inputs\n    if not self._validate_inputs(inputs):\n        return {\"error\": \"Invalid inputs\"}\n\n    # Process\n    return self._process(inputs)\n\ndef _validate_inputs(self, inputs: dict) -&gt; bool:\n    \"\"\"Check if inputs are valid.\"\"\"\n    return (\n        \"data\" in inputs and\n        inputs[\"data\"] is not None and\n        isinstance(inputs[\"data\"], (int, float))\n    )\n</code></pre>"},{"location":"guides/custom-nodes/#real-world-examples","title":"Real-World Examples","text":""},{"location":"guides/custom-nodes/#data-loader","title":"Data Loader","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pynodewidget import JsonSchemaNodeWidget\n\nclass DataLoaderParams(BaseModel):\n    file_path: str = Field(default=\"\", description=\"Path to data file\")\n    format: Literal[\"csv\", \"json\", \"parquet\"] = \"csv\"\n    skip_rows: int = Field(default=0, ge=0)\n\nclass DataLoaderNode(JsonSchemaNodeWidget):\n    label = \"Data Loader\"\n    parameters = DataLoaderParams\n    icon = \"\ud83d\udcc1\"\n    category = \"input\"\n    outputs = [\n        {\"id\": \"data\", \"label\": \"Data\"},\n        {\"id\": \"metadata\", \"label\": \"Metadata\"}\n    ]\n\n    def execute(self, inputs):\n        config = self.get_values()\n\n        # Load data based on format\n        if config[\"format\"] == \"csv\":\n            data = self._load_csv(config[\"file_path\"], config[\"skip_rows\"])\n        elif config[\"format\"] == \"json\":\n            data = self._load_json(config[\"file_path\"])\n        else:\n            data = self._load_parquet(config[\"file_path\"])\n\n        return {\n            \"data\": data,\n            \"metadata\": {\n                \"path\": config[\"file_path\"],\n                \"format\": config[\"format\"],\n                \"rows\": len(data)\n            }\n        }\n</code></pre>"},{"location":"guides/custom-nodes/#data-transformer","title":"Data Transformer","text":"<pre><code>class TransformParams(BaseModel):\n    operation: Literal[\"filter\", \"map\", \"reduce\"] = \"map\"\n    expression: str = Field(default=\"x\", description=\"Transformation expression\")\n\nclass TransformerNode(JsonSchemaNodeWidget):\n    label = \"Transformer\"\n    parameters = TransformParams\n    icon = \"\u2699\ufe0f\"\n    category = \"processing\"\n    inputs = [{\"id\": \"data\", \"label\": \"Input Data\"}]\n    outputs = [{\"id\": \"result\", \"label\": \"Transformed Data\"}]\n\n    def execute(self, inputs):\n        data = inputs.get(\"data\", [])\n        config = self.get_values()\n\n        operation = config[\"operation\"]\n        expr = config[\"expression\"]\n\n        if operation == \"filter\":\n            result = [x for x in data if eval(expr, {\"x\": x})]\n        elif operation == \"map\":\n            result = [eval(expr, {\"x\": x}) for x in data]\n        else:  # reduce\n            result = eval(f\"reduce(lambda acc, x: {expr}, data, 0)\", \n                         {\"data\": data, \"reduce\": __import__(\"functools\").reduce})\n\n        return {\"result\": result}\n</code></pre>"},{"location":"guides/custom-nodes/#visualization","title":"Visualization","text":"<pre><code>class ChartParams(BaseModel):\n    chart_type: Literal[\"bar\", \"line\", \"scatter\", \"pie\"] = \"bar\"\n    title: str = Field(default=\"Chart\", description=\"Chart title\")\n    x_label: str = \"X\"\n    y_label: str = \"Y\"\n\nclass ChartNode(JsonSchemaNodeWidget):\n    label = \"Chart\"\n    parameters = ChartParams\n    icon = \"\ud83d\udcca\"\n    category = \"visualization\"\n    inputs = [{\"id\": \"data\", \"label\": \"Chart Data\"}]\n\n    def execute(self, inputs):\n        data = inputs.get(\"data\", [])\n        config = self.get_values()\n\n        # Generate chart (simplified)\n        chart = self._create_chart(\n            data,\n            config[\"chart_type\"],\n            config[\"title\"],\n            config[\"x_label\"],\n            config[\"y_label\"]\n        )\n\n        # Display in notebook or save\n        return {\"chart\": chart}\n</code></pre>"},{"location":"guides/custom-nodes/#best-practices","title":"Best Practices","text":"<ul> <li>Use descriptive names for classes and labels</li> <li>Add descriptions to fields for better UX</li> <li>Validate inputs in <code>execute()</code> method</li> <li>Handle errors gracefully with try/except</li> <li>Provide sensible defaults for all parameters</li> <li>Organize by category (input, processing, output)</li> </ul>"},{"location":"guides/custom-nodes/#troubleshooting","title":"Troubleshooting","text":"<p>Node not appearing: Ensure <code>label</code> and <code>parameters</code> are defined and node is registered.</p> <p>Pydantic validation errors: Check field constraints match provided values.</p> <p>Values not updating: Use <code>set_value()</code> or <code>set_values()</code> methods, not direct assignment.</p>"},{"location":"guides/custom-nodes/#next-steps","title":"Next Steps","text":"<ul> <li>Styling Nodes: Customize node appearance</li> <li>Handles Configuration: Advanced handle setup</li> <li>Working with Values: Value management patterns</li> <li>Protocols API: NodeFactory protocol details</li> </ul>"},{"location":"guides/grid-layouts/","title":"Grid Layouts with GridBuilder","text":"<p>Build complex node layouts efficiently using the GridBuilder API, which reduces layout code by 60-70% compared to manual grid construction.</p>"},{"location":"guides/grid-layouts/#overview","title":"Overview","text":"<p>GridBuilder provides a fluent API for creating CSS grid layouts within nodes. Instead of manually constructing <code>NodeGrid</code>, <code>GridCell</code>, and <code>GridCoordinates</code> objects, you can use a chainable builder pattern with preset templates for common layouts.</p> <p>Key features: - \ud83c\udfa8 Preset layouts: Ready-to-use templates (three_column, simple_node) - \ud83d\udd27 Fluent API: Chainable methods for readable code - \ud83d\udcd0 Row/column helpers: Convenient methods for horizontal and vertical layouts - \u26a1 Reduced boilerplate: 60-70% less code than manual construction - \ud83c\udfaf Type-safe: Full Pydantic validation</p>"},{"location":"guides/grid-layouts/#quick-start","title":"Quick Start","text":""},{"location":"guides/grid-layouts/#using-presets","title":"Using Presets","text":"<p>The fastest way to create common layouts:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget, GridBuilder, PRESETS\nfrom pydantic import BaseModel, Field\n\nclass Params(BaseModel):\n    threshold: float = Field(default=0.5, ge=0, le=1)\n    enabled: bool = True\n\nclass DashboardNode(JsonSchemaNodeWidget):\n    label = \"Dashboard\"\n    parameters = Params\n    icon = \"\ud83d\udcca\"\n\n    # Three-column preset\n    grid = (\n        GridBuilder()\n        .preset(PRESETS.three_column)\n        .slot(\"header\", HeaderComponent(id=\"header\", label=\"Settings\"))\n        .slot(\"center\", TextField(id=\"notes\", label=\"Notes\", multiline=True))\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#custom-grid-layouts","title":"Custom Grid Layouts","text":"<p>Build custom layouts cell-by-cell:</p> <pre><code>class CustomNode(JsonSchemaNodeWidget):\n    label = \"Custom Layout\"\n    parameters = Params\n\n    grid = (\n        GridBuilder()\n        .rows([\"60px\", \"1fr\", \"40px\"])\n        .cols([\"200px\", \"1fr\"])\n        .gap(\"0.5rem\")\n        .cell(row=1, col=1, col_span=2, components=[\n            HeaderComponent(id=\"header\", label=\"Title\")\n        ])\n        .cell(row=2, col=1, components=[\n            TextField(id=\"sidebar\", label=\"Sidebar\")\n        ])\n        .cell(row=2, col=2, components=[\n            TextField(id=\"content\", label=\"Content\", multiline=True)\n        ])\n        .cell(row=3, col=1, col_span=2, components=[\n            ButtonHandle(id=\"submit\", label=\"Submit\", action=\"execute\")\n        ])\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#preset-layouts","title":"Preset Layouts","text":"<p>GridBuilder includes two common layout presets:</p>"},{"location":"guides/grid-layouts/#1-three-column","title":"1. Three-Column","text":"<p>Three-column layout with optional header and footer.</p> <pre><code>from pynodewidget import GridBuilder, PRESETS\n\n# Basic three-column layout\ngrid = (\n    GridBuilder()\n    .preset(PRESETS.three_column)\n    .slot(\"left\", LabeledHandle(id=\"input\", handle_type=\"input\"))\n    .slot(\"center\", TextField(id=\"content\", label=\"Content\"))\n    .slot(\"right\", LabeledHandle(id=\"output\", handle_type=\"output\"))\n    .build()\n)\n\n# With optional header and footer\ngrid = (\n    GridBuilder()\n    .preset(PRESETS.three_column)\n    .slot(\"header\", HeaderComponent(id=\"header\", label=\"Node Title\"))\n    .slot(\"left\", LabeledHandle(id=\"input\", handle_type=\"input\"))\n    .slot(\"center\", TextField(id=\"content\", label=\"Content\"))\n    .slot(\"right\", LabeledHandle(id=\"output\", handle_type=\"output\"))\n    .slot(\"footer\", BoolField(id=\"enabled\", value=True))\n    .build()\n)\n</code></pre> <p>Structure (basic): <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      \u2502      \u2502      \u2502\n\u2502 Left \u2502Center\u2502Right \u2502  1fr\n\u2502      \u2502      \u2502      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  auto    1fr    auto\n</code></pre></p> <p>Structure (with header/footer): <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Header        \u2502  auto\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      \u2502      \u2502       \u2502\n\u2502 Left \u2502Center\u2502 Right \u2502  1fr\n\u2502      \u2502      \u2502       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       Footer        \u2502  auto\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  auto    1fr    auto\n</code></pre></p> <p>Slot names: <code>\"left\"</code>, <code>\"center\"</code>, <code>\"right\"</code>, <code>\"header\"</code> (optional), <code>\"footer\"</code> (optional)</p>"},{"location":"guides/grid-layouts/#2-simple-node","title":"2. Simple Node","text":"<p>Minimal node layout with header and centered input/output handles.</p> <pre><code>grid = (\n    GridBuilder()\n    .preset(PRESETS.simple_node)\n    .slot(\"header\", HeaderComponent(id=\"header\", label=\"Transform\"))\n    .slot(\"input\", ButtonHandle(id=\"in\", handle_type=\"input\"))\n    .slot(\"center\", TextField(id=\"value\", label=\"Value\"))\n    .slot(\"output\", ButtonHandle(id=\"out\", handle_type=\"output\"))\n    .build()\n)\n</code></pre> <p>Structure: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Header        \u2502  auto\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  In  \u2502 Value\u2502  Out  \u2502  1fr\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  auto    1fr    auto\n</code></pre></p> <p>Slot names: <code>\"header\"</code>, <code>\"input\"</code>, <code>\"center\"</code>, <code>\"output\"</code></p>"},{"location":"guides/grid-layouts/#row-and-column-helpers","title":"Row and Column Helpers","text":"<p>Convenience methods for linear layouts:</p>"},{"location":"guides/grid-layouts/#row-horizontal-layout","title":"row() - Horizontal Layout","text":"<p>Create a single-row layout with multiple columns:</p> <pre><code>from pynodewidget import GridBuilder, TextField, NumberField\n\ngrid = (\n    GridBuilder()\n    .row(\n        TextField(id=\"name\", label=\"Name\"),\n        NumberField(id=\"age\", label=\"Age\"),\n        TextField(id=\"email\", label=\"Email\")\n    )\n    .build()\n)\n</code></pre> <p>Equivalent to: <pre><code>grid = (\n    GridBuilder()\n    .rows([\"1fr\"])\n    .cols([\"1fr\", \"1fr\", \"1fr\"])\n    .cell(row=1, col=1, components=[TextField(id=\"name\", label=\"Name\")])\n    .cell(row=1, col=2, components=[NumberField(id=\"age\", label=\"Age\")])\n    .cell(row=1, col=3, components=[TextField(id=\"email\", label=\"Email\")])\n    .build()\n)\n</code></pre></p>"},{"location":"guides/grid-layouts/#col-vertical-layout","title":"col() - Vertical Layout","text":"<p>Create a single-column layout with multiple rows:</p> <pre><code>grid = (\n    GridBuilder()\n    .col(\n        HeaderComponent(id=\"header\", label=\"Form\"),\n        TextField(id=\"name\", label=\"Name\"),\n        NumberField(id=\"count\", label=\"Count\"),\n        ButtonHandle(id=\"submit\", label=\"Submit\", action=\"execute\")\n    )\n    .build()\n)\n</code></pre> <p>Equivalent to: <pre><code>grid = (\n    GridBuilder()\n    .rows([\"auto\", \"auto\", \"auto\", \"auto\"])\n    .cols([\"1fr\"])\n    .cell(row=1, col=1, components=[HeaderComponent(...)])\n    .cell(row=2, col=1, components=[TextField(...)])\n    .cell(row=3, col=1, components=[NumberField(...)])\n    .cell(row=4, col=1, components=[ButtonHandle(...)])\n    .build()\n)\n</code></pre></p>"},{"location":"guides/grid-layouts/#combining-row-with-customization","title":"Combining row() with Customization","text":"<pre><code>grid = (\n    GridBuilder()\n    .row(\n        TextField(id=\"input1\", label=\"Input 1\"),\n        TextField(id=\"input2\", label=\"Input 2\")\n    )\n    .gap(\"1rem\")  # Add spacing\n    .build()\n)\n</code></pre>"},{"location":"guides/grid-layouts/#custom-grid-building","title":"Custom Grid Building","text":""},{"location":"guides/grid-layouts/#basic-grid-configuration","title":"Basic Grid Configuration","text":"<p>Set up grid dimensions and spacing:</p> <pre><code>grid = (\n    GridBuilder()\n    .rows([\"60px\", \"1fr\", \"40px\"])  # 3 rows: fixed, flexible, fixed\n    .cols([\"1fr\", \"2fr\"])            # 2 cols: 1:2 ratio\n    .gap(\"0.5rem\")                   # Spacing between cells\n    .build()\n)\n</code></pre> <p>Row/column sizing options: - <code>\"auto\"</code>: Size to content - <code>\"1fr\"</code>, <code>\"2fr\"</code>, etc.: Fractional units (flexible) - <code>\"100px\"</code>, <code>\"50%\"</code>: Fixed sizes - <code>\"minmax(100px, 1fr)\"</code>: Min/max constraints</p>"},{"location":"guides/grid-layouts/#adding-cells","title":"Adding Cells","text":"<p>Place components in grid cells:</p> <pre><code>grid = (\n    GridBuilder()\n    .rows([\"60px\", \"1fr\"])\n    .cols([\"1fr\"])\n    .cell(\n        row=1,          # Grid row (1-indexed)\n        col=1,          # Grid column (1-indexed)\n        components=[    # List of components\n            HeaderComponent(id=\"header\", label=\"Title\", icon=\"\ud83d\udccb\")\n        ]\n    )\n    .cell(\n        row=2,\n        col=1,\n        components=[\n            TextField(id=\"notes\", label=\"Notes\", multiline=True)\n        ]\n    )\n    .build()\n)\n</code></pre>"},{"location":"guides/grid-layouts/#cell-spanning","title":"Cell Spanning","text":"<p>Cells can span multiple rows or columns:</p> <pre><code>grid = (\n    GridBuilder()\n    .rows([\"60px\", \"1fr\"])\n    .cols([\"1fr\", \"1fr\", \"1fr\"])\n    .cell(\n        row=1,\n        col=1,\n        col_span=3,  # Span all 3 columns\n        components=[HeaderComponent(id=\"header\", label=\"Full Width Header\")]\n    )\n    .cell(row=2, col=1, components=[TextField(id=\"col1\", label=\"Column 1\")])\n    .cell(row=2, col=2, components=[TextField(id=\"col2\", label=\"Column 2\")])\n    .cell(row=2, col=3, components=[TextField(id=\"col3\", label=\"Column 3\")])\n    .build()\n)\n</code></pre> <p>Spanning options: - <code>col_span</code>: Number of columns to span - <code>row_span</code>: Number of rows to span</p>"},{"location":"guides/grid-layouts/#cell-layout-options","title":"Cell Layout Options","text":"<p>Customize alignment and padding within cells:</p> <pre><code>grid = (\n    GridBuilder()\n    .rows([\"auto\"])\n    .cols([\"1fr\"])\n    .cell(\n        row=1,\n        col=1,\n        components=[ButtonHandle(id=\"btn\", label=\"Click\", action=\"execute\")],\n        # Cell-level layout\n        h_align=\"center\",      # Horizontal: \"start\", \"center\", \"end\", \"stretch\"\n        v_align=\"center\",      # Vertical: \"start\", \"center\", \"end\", \"stretch\"\n        padding=\"1rem\"         # Internal padding\n    )\n    .build()\n)\n</code></pre>"},{"location":"guides/grid-layouts/#complete-examples","title":"Complete Examples","text":""},{"location":"guides/grid-layouts/#dashboard-with-statistics","title":"Dashboard with Statistics","text":"<pre><code>from pynodewidget import (\n    JsonSchemaNodeWidget, GridBuilder,\n    HeaderComponent, TextField, NumberField, BoolField, ButtonHandle\n)\nfrom pydantic import BaseModel, Field\n\nclass DashboardParams(BaseModel):\n    title: str = Field(default=\"Dashboard\")\n    metric1: float = Field(default=0.0)\n    metric2: float = Field(default=0.0)\n    enabled: bool = True\n\nclass DashboardNode(JsonSchemaNodeWidget):\n    label = \"Dashboard\"\n    parameters = DashboardParams\n    icon = \"\ud83d\udcca\"\n    color = \"blue\"\n\n    grid = (\n        GridBuilder()\n        .rows([\"60px\", \"auto\", \"1fr\", \"40px\"])\n        .cols([\"1fr\", \"1fr\"])\n        .gap(\"0.5rem\")\n        # Header spanning full width\n        .cell(\n            row=1, col=1, col_span=2,\n            components=[HeaderComponent(\n                id=\"header\",\n                label=\"Analytics Dashboard\",\n                icon=\"\ud83d\udcc8\",\n                bgColor=\"#1e40af\"\n            )]\n        )\n        # Metrics row\n        .cell(row=2, col=1, components=[\n            NumberField(id=\"metric1\", label=\"Metric 1\", value=0.0)\n        ])\n        .cell(row=2, col=2, components=[\n            NumberField(id=\"metric2\", label=\"Metric 2\", value=0.0)\n        ])\n        # Content spanning full width\n        .cell(\n            row=3, col=1, col_span=2,\n            components=[TextField(\n                id=\"notes\",\n                label=\"Analysis Notes\",\n                multiline=True,\n                placeholder=\"Enter your analysis...\"\n            )]\n        )\n        # Footer with controls\n        .cell(row=4, col=1, components=[\n            BoolField(id=\"enabled\", label=\"Enable Updates\")\n        ])\n        .cell(row=4, col=2, components=[\n            ButtonHandle(id=\"refresh\", label=\"Refresh\", action=\"refresh\")\n        ], h_align=\"end\")\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#form-with-sections","title":"Form with Sections","text":"<pre><code>class FormParams(BaseModel):\n    name: str = Field(default=\"\")\n    email: str = Field(default=\"\")\n    age: int = Field(default=18, ge=0, le=120)\n    newsletter: bool = False\n\nclass FormNode(JsonSchemaNodeWidget):\n    label = \"Registration Form\"\n    parameters = FormParams\n    icon = \"\ud83d\udcdd\"\n\n    grid = (\n        GridBuilder()\n        .col(\n            HeaderComponent(id=\"h1\", label=\"Personal Information\", bgColor=\"#059669\"),\n            TextField(id=\"name\", label=\"Full Name\"),\n            TextField(id=\"email\", label=\"Email\"),\n            NumberField(id=\"age\", label=\"Age\"),\n            HeaderComponent(id=\"h2\", label=\"Preferences\", bgColor=\"#0891b2\"),\n            BoolField(id=\"newsletter\", label=\"Subscribe to newsletter\"),\n            ButtonHandle(id=\"submit\", label=\"Submit\", action=\"register\")\n        )\n        .gap(\"0.5rem\")\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#split-view-editor","title":"Split View Editor","text":"<pre><code>class EditorParams(BaseModel):\n    source: str = Field(default=\"\")\n    compiled: str = Field(default=\"\")\n    auto_compile: bool = True\n\nclass EditorNode(JsonSchemaNodeWidget):\n    label = \"Code Editor\"\n    parameters = EditorParams\n    icon = \"\ud83d\udcbb\"\n\n    grid = (\n        GridBuilder()\n        .rows([\"60px\", \"1fr\", \"40px\"])\n        .cols([\"1fr\", \"1fr\"])\n        .gap(\"0.5rem\")\n        # Header\n        .cell(\n            row=1, col=1, col_span=2,\n            components=[HeaderComponent(\n                id=\"header\",\n                label=\"Code Compiler\",\n                icon=\"\u2699\ufe0f\"\n            )]\n        )\n        # Source code\n        .cell(row=2, col=1, components=[\n            TextField(\n                id=\"source\",\n                label=\"Source Code\",\n                multiline=True,\n                placeholder=\"Enter code...\"\n            )\n        ])\n        # Compiled output\n        .cell(row=2, col=2, components=[\n            TextField(\n                id=\"compiled\",\n                label=\"Compiled Output\",\n                multiline=True,\n                disabled=True\n            )\n        ])\n        # Footer controls\n        .cell(row=3, col=1, components=[\n            BoolField(id=\"auto_compile\", label=\"Auto-compile\")\n        ])\n        .cell(row=3, col=2, components=[\n            ButtonHandle(id=\"compile\", label=\"Compile Now\", action=\"compile\")\n        ], h_align=\"end\")\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#sidebar-navigation","title":"Sidebar Navigation","text":"<pre><code>class NavParams(BaseModel):\n    current_page: str = Field(default=\"home\")\n    content: str = Field(default=\"\")\n\nclass NavNode(JsonSchemaNodeWidget):\n    label = \"Page Layout\"\n    parameters = NavParams\n    icon = \"\ud83d\uddc2\ufe0f\"\n\n    grid = (\n        GridBuilder()\n        .preset(PRESETS.sidebar)\n        .slot(\"sidebar\", SelectField(\n            id=\"current_page\",\n            label=\"Navigation\",\n            options=[\"home\", \"dashboard\", \"settings\", \"help\"]\n        ))\n        .slot(\"content\", TextField(\n            id=\"content\",\n            label=\"Page Content\",\n            multiline=True,\n            placeholder=\"Content goes here...\"\n        ))\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#asymmetric-dashboard","title":"Asymmetric Dashboard","text":"<pre><code>class AsymmetricParams(BaseModel):\n    featured: str = Field(default=\"\")\n    widget1: str = Field(default=\"\")\n    widget2: str = Field(default=\"\")\n    widget3: str = Field(default=\"\")\n\nclass AsymmetricNode(JsonSchemaNodeWidget):\n    label = \"Asymmetric Layout\"\n    parameters = AsymmetricParams\n    icon = \"\ud83d\udcd0\"\n\n    grid = (\n        GridBuilder()\n        .rows([\"60px\", \"200px\", \"100px\"])\n        .cols([\"1fr\", \"1fr\", \"1fr\"])\n        .gap(\"0.5rem\")\n        # Header\n        .cell(row=1, col=1, col_span=3, components=[\n            HeaderComponent(id=\"header\", label=\"Dashboard\")\n        ])\n        # Featured content (spans 2 columns)\n        .cell(row=2, col=1, col_span=2, components=[\n            TextField(id=\"featured\", label=\"Featured\", multiline=True)\n        ])\n        # Side widget\n        .cell(row=2, col=3, components=[\n            TextField(id=\"widget1\", label=\"Quick Stats\")\n        ])\n        # Bottom row (3 equal widgets)\n        .cell(row=3, col=1, components=[\n            TextField(id=\"widget2\", label=\"Widget 2\")\n        ])\n        .cell(row=3, col=2, components=[\n            TextField(id=\"widget3\", label=\"Widget 3\")\n        ])\n        .cell(row=3, col=3, components=[\n            ButtonHandle(id=\"action\", label=\"Action\", action=\"execute\")\n        ])\n        .build()\n    )\n</code></pre>"},{"location":"guides/grid-layouts/#comparison-manual-vs-gridbuilder","title":"Comparison: Manual vs GridBuilder","text":""},{"location":"guides/grid-layouts/#manual-construction-old-way","title":"Manual Construction (Old Way)","text":"<pre><code>from pynodewidget.models import NodeGrid, GridCell, GridCoordinates, CellLayout\n\ngrid = NodeGrid(\n    rows=[\"60px\", \"1fr\"],\n    columns=[\"1fr\"],\n    gap=\"0.5rem\",\n    cells=[\n        GridCell(\n            id=\"cell-header\",\n            coordinates=GridCoordinates(row=1, col=1),\n            layout=CellLayout(),\n            components=[\n                HeaderComponent(id=\"header\", label=\"Title\")\n            ]\n        ),\n        GridCell(\n            id=\"cell-body\",\n            coordinates=GridCoordinates(row=2, col=1),\n            layout=CellLayout(),\n            components=[\n                TextField(id=\"content\", label=\"Content\")\n            ]\n        )\n    ]\n)\n</code></pre>"},{"location":"guides/grid-layouts/#gridbuilder-new-way","title":"GridBuilder (New Way)","text":"<pre><code>from pynodewidget import GridBuilder, PRESETS\n\ngrid = (\n    GridBuilder()\n    .preset(PRESETS.three_column)\n    .slot(\"header\", HeaderComponent(id=\"header\", label=\"Title\"))\n    .slot(\"center\", TextField(id=\"content\", label=\"Content\"))\n    .build()\n)\n</code></pre> <p>Benefits: - \u2705 70% less code - \u2705 Chainable, readable API - \u2705 No manual ID generation for cells - \u2705 Type-safe with Pydantic validation - \u2705 Preset templates for common layouts</p>"},{"location":"guides/grid-layouts/#best-practices","title":"Best Practices","text":""},{"location":"guides/grid-layouts/#1-start-with-presets","title":"1. Start with Presets","text":"<p>Use presets for standard layouts before building custom grids:</p> <pre><code># \u2705 Good: Use preset when it fits\ngrid = GridBuilder().preset(PRESETS.three_column)...\n\n# \u274c Avoid: Rebuilding common layouts manually\ngrid = GridBuilder().rows([\"auto\", \"1fr\", \"auto\"]).cols([\"auto\", \"1fr\", \"auto\"])...\n</code></pre>"},{"location":"guides/grid-layouts/#2-use-row-and-col-for-linear-layouts","title":"2. Use row() and col() for Linear Layouts","text":"<pre><code># \u2705 Good: Use row() for horizontal layout\ngrid = GridBuilder().row(field1, field2, field3).build()\n\n# \u274c Avoid: Manual cell placement for simple rows\ngrid = GridBuilder().rows([\"1fr\"]).cols([\"1fr\", \"1fr\", \"1fr\"])\n    .cell(row=1, col=1, components=[field1])\n    .cell(row=1, col=2, components=[field2])...\n</code></pre>"},{"location":"guides/grid-layouts/#3-chain-methods-for-readability","title":"3. Chain Methods for Readability","text":"<pre><code># \u2705 Good: Chain methods\ngrid = (\n    GridBuilder()\n    .rows([\"60px\", \"1fr\"])\n    .cols([\"200px\", \"1fr\"])\n    .gap(\"0.5rem\")\n    .cell(...)\n    .build()\n)\n\n# \u274c Avoid: Breaking chain unnecessarily\nbuilder = GridBuilder()\nbuilder = builder.rows([\"60px\", \"1fr\"])\nbuilder = builder.cols([\"200px\", \"1fr\"])\ngrid = builder.build()\n</code></pre>"},{"location":"guides/grid-layouts/#4-use-descriptive-component-ids","title":"4. Use Descriptive Component IDs","text":"<pre><code># \u2705 Good: Clear IDs\n.slot(\"header\", HeaderComponent(id=\"main-header\", label=\"Title\"))\n.slot(\"body\", TextField(id=\"notes-content\", label=\"Notes\"))\n\n# \u274c Avoid: Generic IDs\n.slot(\"header\", HeaderComponent(id=\"comp1\", label=\"Title\"))\n.slot(\"body\", TextField(id=\"comp2\", label=\"Notes\"))\n</code></pre>"},{"location":"guides/grid-layouts/#5-leverage-spanning-for-headersfooters","title":"5. Leverage Spanning for Headers/Footers","text":"<pre><code># \u2705 Good: Span full width for headers\n.cell(row=1, col=1, col_span=3, components=[HeaderComponent(...)])\n\n# \u274c Avoid: Multiple header cells\n.cell(row=1, col=1, components=[HeaderComponent(...)])\n.cell(row=1, col=2, components=[HeaderComponent(...)])\n.cell(row=1, col=3, components=[HeaderComponent(...)])\n</code></pre>"},{"location":"guides/grid-layouts/#6-set-appropriate-row-sizes","title":"6. Set Appropriate Row Sizes","text":"<pre><code># \u2705 Good: Fixed size for headers/footers, flexible for content\n.rows([\"60px\", \"1fr\", \"40px\"])\n\n# \u274c Avoid: All flexible rows when you need fixed sizes\n.rows([\"1fr\", \"1fr\", \"1fr\"])\n</code></pre>"},{"location":"guides/grid-layouts/#7-add-gap-for-visual-separation","title":"7. Add Gap for Visual Separation","text":"<pre><code># \u2705 Good: Consistent spacing\nGridBuilder().rows([...]).cols([...]).gap(\"0.5rem\")\n\n# \u274c Avoid: No gap (components touch)\nGridBuilder().rows([...]).cols([...])  # gap defaults to \"0\"\n</code></pre>"},{"location":"guides/grid-layouts/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/grid-layouts/#grid-not-displaying","title":"Grid Not Displaying","text":"<p>Problem: Grid appears empty or components don't show.</p> <p>Solutions: - Ensure you call <code>.build()</code> at the end - Check that component IDs are unique - Verify row/col indices are 1-based (not 0-based)</p> <pre><code># \u2705 Correct\n.cell(row=1, col=1, components=[...])\n\n# \u274c Wrong (0-based indexing)\n.cell(row=0, col=0, components=[...])\n</code></pre>"},{"location":"guides/grid-layouts/#spanning-not-working","title":"Spanning Not Working","text":"<p>Problem: Cell doesn't span as expected.</p> <p>Solutions: - Verify you have enough rows/columns for the span - Check that col_span and row_span are integers - Ensure no overlapping cells</p> <pre><code># \u2705 Correct: 3 columns available for col_span=3\n.cols([\"1fr\", \"1fr\", \"1fr\"])\n.cell(row=1, col=1, col_span=3, components=[...])\n\n# \u274c Wrong: Only 2 columns, can't span 3\n.cols([\"1fr\", \"1fr\"])\n.cell(row=1, col=1, col_span=3, components=[...])\n</code></pre>"},{"location":"guides/grid-layouts/#components-overlap","title":"Components Overlap","text":"<p>Problem: Components render on top of each other.</p> <p>Solutions: - Add gap between cells: <code>.gap(\"0.5rem\")</code> - Check for overlapping cell coordinates - Verify spanning doesn't create conflicts</p>"},{"location":"guides/grid-layouts/#preset-slot-not-found","title":"Preset Slot Not Found","text":"<p>Problem: <code>ValueError: Unknown slot name 'xyz'</code></p> <p>Solutions: - Check preset documentation for correct slot names - Use <code>PRESETS.three_column</code>, <code>PRESETS.simple_node</code> - Verify spelling of slot names</p> <pre><code># \u2705 Correct\n.preset(PRESETS.three_column)\n.slot(\"left\", ...)\n.slot(\"center\", ...)\n\n# \u274c Wrong slot name\n.preset(PRESETS.three_column)\n.slot(\"middle\", ...)  # Should be \"center\"\n</code></pre>"},{"location":"guides/grid-layouts/#api-reference","title":"API Reference","text":""},{"location":"guides/grid-layouts/#gridbuilder-methods","title":"GridBuilder Methods","text":""},{"location":"guides/grid-layouts/#presetpreset-presetconfig-gridbuilder","title":"<code>.preset(preset: PresetConfig) -&gt; GridBuilder</code>","text":"<p>Apply a preset configuration.</p> <p>Parameters: - <code>preset</code>: One of <code>PRESETS.three_column</code>, <code>PRESETS.simple_node</code></p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#slotname-str-components-gridbuilder","title":"<code>.slot(name: str, *components) -&gt; GridBuilder</code>","text":"<p>Assign components to a preset slot.</p> <p>Parameters: - <code>name</code>: Slot name from preset (e.g., \"header\", \"body\", \"left\") - <code>*components</code>: Component instances to place in the slot</p> <p>Returns: Self (for chaining)</p> <p>Raises: <code>ValueError</code> if slot name not found in preset</p>"},{"location":"guides/grid-layouts/#rowssizes-liststr-gridbuilder","title":"<code>.rows(sizes: list[str]) -&gt; GridBuilder</code>","text":"<p>Set grid row sizes.</p> <p>Parameters: - <code>sizes</code>: List of CSS grid row sizes (e.g., <code>[\"60px\", \"1fr\", \"auto\"]</code>)</p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#colssizes-liststr-gridbuilder","title":"<code>.cols(sizes: list[str]) -&gt; GridBuilder</code>","text":"<p>Set grid column sizes.</p> <p>Parameters: - <code>sizes</code>: List of CSS grid column sizes (e.g., <code>[\"200px\", \"1fr\"]</code>)</p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#gapgap-str-gridbuilder","title":"<code>.gap(gap: str) -&gt; GridBuilder</code>","text":"<p>Set spacing between grid cells.</p> <p>Parameters: - <code>gap</code>: CSS gap value (e.g., <code>\"0.5rem\"</code>, <code>\"10px\"</code>)</p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#cellrow-int-col-int-components-list-gridbuilder","title":"<code>.cell(row: int, col: int, components: list, ...) -&gt; GridBuilder</code>","text":"<p>Add a cell to the grid.</p> <p>Parameters: - <code>row</code>: Row number (1-indexed) - <code>col</code>: Column number (1-indexed) - <code>components</code>: List of component instances - <code>row_span</code>: (Optional) Number of rows to span (default: 1) - <code>col_span</code>: (Optional) Number of columns to span (default: 1) - <code>h_align</code>: (Optional) Horizontal alignment: \"start\", \"center\", \"end\", \"stretch\" - <code>v_align</code>: (Optional) Vertical alignment: \"start\", \"center\", \"end\", \"stretch\" - <code>padding</code>: (Optional) Cell padding (CSS value)</p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#rowcomponents-gridbuilder","title":"<code>.row(*components) -&gt; GridBuilder</code>","text":"<p>Create single-row layout with components as columns.</p> <p>Parameters: - <code>*components</code>: Component instances to place in columns</p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#colcomponents-gridbuilder","title":"<code>.col(*components) -&gt; GridBuilder</code>","text":"<p>Create single-column layout with components as rows.</p> <p>Parameters: - <code>*components</code>: Component instances to place in rows</p> <p>Returns: Self (for chaining)</p>"},{"location":"guides/grid-layouts/#build-nodegrid","title":"<code>.build() -&gt; NodeGrid</code>","text":"<p>Build and return the final grid configuration.</p> <p>Returns: <code>NodeGrid</code> instance ready for use in node classes</p>"},{"location":"guides/grid-layouts/#next-steps","title":"Next Steps","text":"<ul> <li>Styling Nodes: Customize node appearance</li> <li>Custom Nodes: Build complete custom nodes</li> <li>Handles Configuration: Configure connection points</li> <li>Developer Architecture: Understand internal structure</li> </ul>"},{"location":"guides/handles/","title":"Handle Configuration","text":"<p>Configure connection points (handles) for node inputs and outputs.</p>"},{"location":"guides/handles/#overview","title":"Overview","text":"<p>Handles are connection points on nodes that allow data flow between nodes. PyNodeWidget supports three handle types with different visual styles and behaviors:</p> <ul> <li>Base handles: Simple connection points (default)</li> <li>Button handles: Prominent button-style handles</li> <li>Labeled handles: Handles with visible labels and optional icons</li> </ul>"},{"location":"guides/handles/#simple-handle-definition","title":"Simple Handle Definition","text":""},{"location":"guides/handles/#basic-inputs-and-outputs","title":"Basic Inputs and Outputs","text":"<p>Define handles as lists of dictionaries:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass DataProcessor(JsonSchemaNodeWidget):\n    label = \"Data Processor\"\n    parameters = ProcessorParams\n\n    inputs = [{\"id\": \"data\", \"label\": \"Input Data\"}]\n    outputs = [{\"id\": \"result\", \"label\": \"Processed Data\"}]\n</code></pre>"},{"location":"guides/handles/#multiple-handles","title":"Multiple Handles","text":"<p>Add multiple connection points:</p> <pre><code>class JoinNode(JsonSchemaNodeWidget):\n    label = \"Join\"\n    parameters = JoinParams\n\n    # Two inputs\n    inputs = [\n        {\"id\": \"left\", \"label\": \"Left Dataset\"},\n        {\"id\": \"right\", \"label\": \"Right Dataset\"}\n    ]\n\n    # Single output\n    outputs = [{\"id\": \"joined\", \"label\": \"Joined Data\"}]\n</code></pre>"},{"location":"guides/handles/#source-and-sink-nodes","title":"Source and Sink Nodes","text":"<p>Source nodes (no inputs):</p> <pre><code>class DataSource(JsonSchemaNodeWidget):\n    label = \"Data Source\"\n    parameters = SourceParams\n\n    inputs = []  # No inputs\n    outputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n</code></pre> <p>Sink nodes (no outputs):</p> <pre><code>class DataSink(JsonSchemaNodeWidget):\n    label = \"Data Sink\"\n    parameters = SinkParams\n\n    inputs = [{\"id\": \"data\", \"label\": \"Data\"}]\n    outputs = []  # No outputs - terminal node\n</code></pre>"},{"location":"guides/handles/#handle-types","title":"Handle Types","text":""},{"location":"guides/handles/#base-handles-default","title":"Base Handles (default)","text":"<p>Simple connection points:</p> <pre><code>class SimpleNode(JsonSchemaNodeWidget):\n    label = \"Simple\"\n    parameters = Params\n    handle_type = \"base\"  # Default\n\n    inputs = [{\"id\": \"in\", \"label\": \"Input\"}]\n    outputs = [{\"id\": \"out\", \"label\": \"Output\"}]\n</code></pre> <p>Characteristics: - Minimal visual footprint - Small circular connection points - Labels not always visible - Best for simple workflows</p>"},{"location":"guides/handles/#button-handles","title":"Button Handles","text":"<p>Prominent button-style handles:</p> <pre><code>class ProcessingNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    handle_type = \"button\"\n\n    inputs = [{\"id\": \"data\", \"label\": \"Process\"}]\n    outputs = [{\"id\": \"result\", \"label\": \"Result\"}]\n</code></pre> <p>Characteristics: - Larger, more visible - Button-like appearance - Clear affordance for connection - Good for processing/action nodes</p>"},{"location":"guides/handles/#labeled-handles","title":"Labeled Handles","text":"<p>Handles with visible labels and optional icons:</p> <pre><code>class LabeledNode(JsonSchemaNodeWidget):\n    label = \"Labeled Node\"\n    parameters = Params\n    handle_type = \"labeled\"\n\n    inputs = [{\"id\": \"data\", \"label\": \"Input Data\"}]\n    outputs = [\n        {\"id\": \"result\", \"label\": \"Result\"},\n        {\"id\": \"metadata\", \"label\": \"Metadata\"}\n    ]\n</code></pre> <p>Characteristics: - Labels always visible - Optional icons - Clear handle identification - Best for complex nodes with many handles</p>"},{"location":"guides/handles/#advanced-handle-specs","title":"Advanced Handle Specs","text":"<p>Use <code>HandleSpec</code> from protocols for fine-grained control:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\nfrom pynodeflow.protocols import HandleSpec\n\nclass AdvancedNode(JsonSchemaNodeWidget):\n    label = \"Advanced Node\"\n    parameters = Params\n\n    inputs = [\n        HandleSpec(\n            id=\"data\",\n            label=\"Data Input\",\n            handle_type=\"labeled\"\n        )\n    ]\n\n    outputs = [\n        HandleSpec(\n            id=\"primary\",\n            label=\"Primary Output\",\n            handle_type=\"labeled\"\n        ),\n        HandleSpec(\n            id=\"secondary\",\n            label=\"Secondary Output\",\n            handle_type=\"base\"\n        )\n    ]\n</code></pre> <p>HandleSpec attributes: - <code>id</code>: Unique identifier (required) - <code>label</code>: Display name (required) - <code>handle_type</code>: Visual style (<code>\"base\"</code>, <code>\"button\"</code>, <code>\"labeled\"</code>)</p>"},{"location":"guides/handles/#mixed-handle-types","title":"Mixed Handle Types","text":"<p>Different types for inputs vs. outputs:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass MixedNode(JsonSchemaNodeWidget):\n    label = \"Mixed Handles\"\n    parameters = Params\n\n    # Override global handle_type per handle\n    inputs = [\n        {\"id\": \"data\", \"label\": \"Data\", \"type\": \"labeled\"},\n        {\"id\": \"config\", \"label\": \"Config\", \"type\": \"base\"}\n    ]\n\n    outputs = [\n        {\"id\": \"result\", \"label\": \"Result\", \"type\": \"button\"}\n    ]\n</code></pre> <p>Or use factory method with separate types:</p> <pre><code>from pynodeflow.json_schema_node import JsonSchemaNodeWidget\n\nnode = JsonSchemaNodeWidget.from_pydantic(\n    ConfigModel,\n    label=\"Mixed Node\",\n    inputs=[{\"id\": \"in\", \"label\": \"Input\"}],\n    outputs=[{\"id\": \"out\", \"label\": \"Output\"}],\n    input_handle_type=\"labeled\",   # Inputs use labeled\n    output_handle_type=\"button\"    # Outputs use button\n)\n</code></pre>"},{"location":"guides/handles/#pydantic-based-handles","title":"Pydantic-Based Handles","text":"<p>Define handles using Pydantic models for type safety:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass DataLoaderInputs(BaseModel):\n    \"\"\"No inputs - source node.\"\"\"\n    pass\n\nclass DataLoaderOutputs(BaseModel):\n    \"\"\"Typed outputs.\"\"\"\n    data: str = Field(description=\"Loaded data\")\n    metadata: str = Field(description=\"File metadata\")\n\nclass DataLoader(JsonSchemaNodeWidget):\n    label = \"Data Loader\"\n    parameters = LoaderParams\n\n    # Use Pydantic models\n    inputs = DataLoaderInputs    # Empty = no inputs\n    outputs = DataLoaderOutputs  # Auto-generates handles\n</code></pre> <p>The widget automatically converts Pydantic fields to handle configurations: - Field name \u2192 handle ID - Field title/name \u2192 handle label - Field description \u2192 tooltip (if supported)</p>"},{"location":"guides/handles/#real-world-examples","title":"Real-World Examples","text":""},{"location":"guides/handles/#data-pipeline-node","title":"Data Pipeline Node","text":"<pre><code>class DataPipeline(JsonSchemaNodeWidget):\n    label = \"Data Pipeline\"\n    parameters = PipelineParams\n    handle_type = \"labeled\"\n\n    inputs = [\n        {\"id\": \"raw_data\", \"label\": \"\ud83d\udce5 Raw Data\"},\n        {\"id\": \"config\", \"label\": \"\u2699\ufe0f Configuration\"}\n    ]\n\n    outputs = [\n        {\"id\": \"processed\", \"label\": \"\u2705 Processed Data\"},\n        {\"id\": \"errors\", \"label\": \"\u274c Errors\"},\n        {\"id\": \"stats\", \"label\": \"\ud83d\udcca Statistics\"}\n    ]\n</code></pre>"},{"location":"guides/handles/#ml-training-node","title":"ML Training Node","text":"<pre><code>class MLTrainer(JsonSchemaNodeWidget):\n    label = \"ML Trainer\"\n    parameters = TrainerParams\n    handle_type = \"labeled\"\n\n    inputs = [\n        {\"id\": \"train_data\", \"label\": \"Training Data\"},\n        {\"id\": \"train_labels\", \"label\": \"Training Labels\"},\n        {\"id\": \"val_data\", \"label\": \"Validation Data\"},\n        {\"id\": \"val_labels\", \"label\": \"Validation Labels\"}\n    ]\n\n    outputs = [\n        {\"id\": \"model\", \"label\": \"Trained Model\"},\n        {\"id\": \"metrics\", \"label\": \"Training Metrics\"},\n        {\"id\": \"predictions\", \"label\": \"Predictions\"}\n    ]\n</code></pre>"},{"location":"guides/handles/#conditional-output-node","title":"Conditional Output Node","text":"<p>Different outputs based on condition:</p> <pre><code>class Classifier(JsonSchemaNodeWidget):\n    label = \"Classifier\"\n    parameters = ClassifierParams\n    handle_type = \"labeled\"\n\n    inputs = [\n        {\"id\": \"data\", \"label\": \"Input Data\"}\n    ]\n\n    outputs = [\n        {\"id\": \"class_a\", \"label\": \"Class A\"},\n        {\"id\": \"class_b\", \"label\": \"Class B\"},\n        {\"id\": \"uncertain\", \"label\": \"Uncertain\"}\n    ]\n\n    def execute(self, inputs):\n        data = inputs.get(\"data\")\n        config = self.get_values()\n\n        # Classify data\n        classification = self._classify(data, config)\n\n        # Route to appropriate output\n        if classification[\"confidence\"] &gt; config[\"threshold\"]:\n            if classification[\"class\"] == \"A\":\n                return {\"class_a\": data}\n            else:\n                return {\"class_b\": data}\n        else:\n            return {\"uncertain\": data}\n</code></pre>"},{"location":"guides/handles/#aggregator-node","title":"Aggregator Node","text":"<p>Many inputs, single output:</p> <pre><code>class Aggregator(JsonSchemaNodeWidget):\n    label = \"Data Aggregator\"\n    parameters = AggregatorParams\n    handle_type = \"labeled\"\n\n    inputs = [\n        {\"id\": \"source1\", \"label\": \"Source 1\"},\n        {\"id\": \"source2\", \"label\": \"Source 2\"},\n        {\"id\": \"source3\", \"label\": \"Source 3\"},\n        {\"id\": \"source4\", \"label\": \"Source 4\"}\n    ]\n\n    outputs = [\n        {\"id\": \"combined\", \"label\": \"Combined Data\"}\n    ]\n\n    def execute(self, inputs):\n        # Combine all non-None inputs\n        sources = [v for k, v in inputs.items() if v is not None]\n        combined = self._aggregate(sources, self.get_values())\n        return {\"combined\": combined}\n</code></pre>"},{"location":"guides/handles/#splitter-node","title":"Splitter Node","text":"<p>Single input, many outputs:</p> <pre><code>class DataSplitter(JsonSchemaNodeWidget):\n    label = \"Data Splitter\"\n    parameters = SplitterParams\n    handle_type = \"labeled\"\n\n    inputs = [\n        {\"id\": \"dataset\", \"label\": \"Full Dataset\"}\n    ]\n\n    outputs = [\n        {\"id\": \"train\", \"label\": \"Training Set\"},\n        {\"id\": \"val\", \"label\": \"Validation Set\"},\n        {\"id\": \"test\", \"label\": \"Test Set\"}\n    ]\n\n    def execute(self, inputs):\n        dataset = inputs.get(\"dataset\")\n        config = self.get_values()\n\n        # Split dataset\n        train, val, test = self._split(\n            dataset,\n            train_ratio=config[\"train_ratio\"],\n            val_ratio=config[\"val_ratio\"],\n            random_seed=config[\"seed\"]\n        )\n\n        return {\n            \"train\": train,\n            \"val\": val,\n            \"test\": test\n        }\n</code></pre>"},{"location":"guides/handles/#handle-labels","title":"Handle Labels","text":""},{"location":"guides/handles/#using-emojis","title":"Using Emojis","text":"<p>Add visual clarity with emojis:</p> <pre><code>inputs = [\n    {\"id\": \"data\", \"label\": \"\ud83d\udce5 Data Input\"},\n    {\"id\": \"config\", \"label\": \"\u2699\ufe0f Configuration\"}\n]\n\noutputs = [\n    {\"id\": \"success\", \"label\": \"\u2705 Success\"},\n    {\"id\": \"error\", \"label\": \"\u274c Error\"},\n    {\"id\": \"warning\", \"label\": \"\u26a0\ufe0f Warning\"}\n]\n</code></pre> <p>Common emojis: - \ud83d\udce5 Input/download - \ud83d\udce4 Output/upload - \u2699\ufe0f Configuration - \ud83d\udd17 Connection - \u2705 Success - \u274c Error - \u26a0\ufe0f Warning - \ud83d\udcca Data/statistics - \ud83e\udd16 ML/AI - \ud83d\udcc1 File</p>"},{"location":"guides/handles/#descriptive-names","title":"Descriptive Names","text":"<p>Clear, action-oriented labels:</p> <pre><code># \u274c Vague\ninputs = [{\"id\": \"in\", \"label\": \"In\"}]\n\n# \u2705 Clear\ninputs = [{\"id\": \"dataset\", \"label\": \"Training Dataset\"}]\n\n# \u274c Cryptic\noutputs = [{\"id\": \"out1\", \"label\": \"Output 1\"}]\n\n# \u2705 Descriptive\noutputs = [{\"id\": \"predictions\", \"label\": \"Model Predictions\"}]\n</code></pre>"},{"location":"guides/handles/#handle-validation","title":"Handle Validation","text":""},{"location":"guides/handles/#check-required-inputs","title":"Check Required Inputs","text":"<p>In <code>execute()</code> method:</p> <pre><code>def execute(self, inputs):\n    # Validate required inputs exist\n    required = [\"data\", \"config\"]\n    missing = [r for r in required if r not in inputs or inputs[r] is None]\n\n    if missing:\n        return {\"error\": f\"Missing required inputs: {', '.join(missing)}\"}\n\n    # Process\n    ...\n</code></pre>"},{"location":"guides/handles/#type-checking","title":"Type Checking","text":"<pre><code>def execute(self, inputs):\n    # Check input types\n    data = inputs.get(\"data\")\n\n    if not isinstance(data, list):\n        return {\"error\": \"Input 'data' must be a list\"}\n\n    # Process\n    ...\n</code></pre>"},{"location":"guides/handles/#best-practices","title":"Best Practices","text":"<ul> <li>Consistent naming: Use clear, consistent handle IDs and labels</li> <li>Meaningful labels: Describe data content, not just \"Input 1\"</li> <li>Appropriate types: Base for simple, labeled for complex, button for interactive</li> <li>Limit handle count: Avoid too many handles (keep under ~10)</li> <li>Document purpose: Add descriptions for complex handles</li> </ul>"},{"location":"guides/handles/#troubleshooting","title":"Troubleshooting","text":"<p>Handles not appearing: Use dict format <code>[{\"id\": \"data\", \"label\": \"Data\"}]</code>, not list of strings.</p> <p>Handle IDs conflict: Ensure all IDs are unique within inputs and outputs.</p> <p>Handle type not working: Valid types are <code>\"base\"</code>, <code>\"button\"</code>, or <code>\"labeled\"</code>.</p> <p>Pydantic handles not converting: Ensure class inherits from <code>BaseModel</code>.</p>"},{"location":"guides/handles/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Custom Nodes: Build nodes with custom handles</li> <li>Working with Values: Handle data flow between nodes</li> <li>Protocols API: HandleSpec documentation</li> </ul>"},{"location":"guides/import-export/","title":"Import and Export","text":"<p>Save and load workflows with JSON serialization, or export as standalone HTML for visualization.</p>"},{"location":"guides/import-export/#overview","title":"Overview","text":"<p>PyNodeWidget workflows can be exported in multiple formats:</p>"},{"location":"guides/import-export/#json-export","title":"JSON Export","text":"<p>For persistence, sharing, and version control: - Nodes (configuration, position, type) - Edges (connections between nodes) - Node values (current field values) - Viewport (zoom and pan state) - Node templates (registered node types)</p>"},{"location":"guides/import-export/#html-export","title":"HTML Export","text":"<p>For visualization and documentation (no Python/Jupyter required): - Standalone HTML files that work in any web browser - Interactive or static (view-only) modes - Self-contained with embedded JavaScript and CSS - Perfect for sharing DAG visualizations, documentation, and reports</p>"},{"location":"guides/import-export/#basic-exportimport","title":"Basic Export/Import","text":""},{"location":"guides/import-export/#export-to-file","title":"Export to File","text":"<p>Save current workflow:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\n# Build workflow...\n# ...\n\n# Export to JSON file\nflow.export_json(\"my_workflow.json\")\n# \u2713 Flow exported to my_workflow.json\n</code></pre>"},{"location":"guides/import-export/#import-from-file","title":"Import from File","text":"<p>Load saved workflow:</p> <pre><code>flow = NodeFlowWidget()\n\n# Load workflow\nflow.load_json(\"my_workflow.json\")\n# \u2713 Flow loaded from my_workflow.json\n</code></pre>"},{"location":"guides/import-export/#custom-filenames","title":"Custom Filenames","text":"<pre><code># Export with custom name\nflow.export_json(\"data_pipeline_v2.json\")\n\n# Load from custom location\nflow.load_json(\"/path/to/saved_workflow.json\")\n</code></pre>"},{"location":"guides/import-export/#json-structure","title":"JSON Structure","text":""},{"location":"guides/import-export/#complete-export","title":"Complete Export","text":"<p>Exported JSON contains:</p> <pre><code>{\n  \"nodes\": [\n    {\n      \"id\": \"node-1\",\n      \"type\": \"data_loader\",\n      \"position\": {\"x\": 100, \"y\": 100},\n      \"data\": {\n        \"label\": \"Data Loader\",\n        \"values\": {\n          \"file_path\": \"data.csv\",\n          \"format\": \"csv\"\n        }\n      }\n    }\n  ],\n  \"edges\": [\n    {\n      \"id\": \"edge-1\",\n      \"source\": \"node-1\",\n      \"target\": \"node-2\",\n      \"sourceHandle\": \"data\",\n      \"targetHandle\": \"input\"\n    }\n  ],\n  \"viewport\": {\n    \"x\": 0,\n    \"y\": 0,\n    \"zoom\": 1\n  },\n  \"node_templates\": [\n    {\n      \"type\": \"data_loader\",\n      \"label\": \"Data Loader\",\n      \"defaultData\": {...}\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/import-export/#node-structure","title":"Node Structure","text":"<p>Each node contains:</p> <pre><code>{\n  \"id\": \"unique-node-id\",\n  \"type\": \"node-type-name\",\n  \"position\": {\"x\": 100, \"y\": 200},\n  \"data\": {\n    \"label\": \"Node Label\",\n    \"parameters\": {...},  // JSON Schema\n    \"inputs\": [...],\n    \"outputs\": [...],\n    \"values\": {...}  // Current field values\n  }\n}\n</code></pre>"},{"location":"guides/import-export/#edge-structure","title":"Edge Structure","text":"<p>Each edge contains:</p> <pre><code>{\n  \"id\": \"unique-edge-id\",\n  \"source\": \"source-node-id\",\n  \"target\": \"target-node-id\",\n  \"sourceHandle\": \"output-handle-id\",\n  \"targetHandle\": \"input-handle-id\"\n}\n</code></pre>"},{"location":"guides/import-export/#programmatic-access","title":"Programmatic Access","text":""},{"location":"guides/import-export/#get-flow-data","title":"Get Flow Data","text":"<p>Access flow data as dictionary:</p> <pre><code># Get complete flow data\ndata = flow.get_flow_data()\n\n# Access components\nnodes = data[\"nodes\"]\nedges = data[\"edges\"]\nviewport = data[\"viewport\"]\n</code></pre>"},{"location":"guides/import-export/#export-to-dictionary","title":"Export to Dictionary","text":"<pre><code># Get as dict instead of file\nflow_dict = {\n    \"nodes\": flow.nodes,\n    \"edges\": flow.edges,\n    \"viewport\": flow.viewport,\n    \"node_templates\": flow.node_templates\n}\n\n# Use for custom serialization\nimport json\njson_string = json.dumps(flow_dict, indent=2)\n</code></pre>"},{"location":"guides/import-export/#import-from-dictionary","title":"Import from Dictionary","text":"<pre><code>import json\n\n# Load JSON string\njson_string = '{\"nodes\": [...], \"edges\": [...]}'\ndata = json.loads(json_string)\n\n# Apply to widget\nflow.nodes = data[\"nodes\"]\nflow.edges = data[\"edges\"]\nflow.viewport = data.get(\"viewport\", {\"x\": 0, \"y\": 0, \"zoom\": 1})\n</code></pre>"},{"location":"guides/import-export/#node-values","title":"Node Values","text":""},{"location":"guides/import-export/#include-values-in-export","title":"Include Values in Export","text":"<p>Node values are automatically included:</p> <pre><code># Set node values\nflow.set_node_values(\"processor-1\", {\n    \"threshold\": 0.8,\n    \"mode\": \"advanced\",\n    \"workers\": 8\n})\n\n# Export (includes values)\nflow.export_json(\"workflow_with_values.json\")\n</code></pre>"},{"location":"guides/import-export/#access-node-values-from-json","title":"Access Node Values from JSON","text":"<pre><code># Load workflow\nflow.load_json(\"workflow_with_values.json\")\n\n# Access values\nvalues = flow.get_node_values(\"processor-1\")\nprint(values)  # {\"threshold\": 0.8, \"mode\": \"advanced\", \"workers\": 8}\n</code></pre>"},{"location":"guides/import-export/#clear-values-before-export","title":"Clear Values Before Export","text":"<pre><code># Clear all node values\nflow.node_values = {}\n\n# Export without values\nflow.export_json(\"workflow_template.json\")\n</code></pre>"},{"location":"guides/import-export/#workflow-templates","title":"Workflow Templates","text":""},{"location":"guides/import-export/#create-template","title":"Create Template","text":"<p>Export workflow as reusable template:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\n# Create template workflow\ntemplate = NodeFlowWidget(nodes=[DataLoader, Processor, OutputNode])\n\n# Add template nodes (no connections)\ntemplate.nodes = [\n    {\n        \"id\": \"loader\",\n        \"type\": \"data_loader\",\n        \"position\": {\"x\": 50, \"y\": 100},\n        \"data\": {...}\n    },\n    {\n        \"id\": \"processor\",\n        \"type\": \"processor\",\n        \"position\": {\"x\": 300, \"y\": 100},\n        \"data\": {...}\n    },\n    {\n        \"id\": \"output\",\n        \"type\": \"output\",\n        \"position\": {\"x\": 550, \"y\": 100},\n        \"data\": {...}\n    }\n]\n\n# Export as template\ntemplate.export_json(\"data_pipeline_template.json\")\n</code></pre>"},{"location":"guides/import-export/#use-template","title":"Use Template","text":"<pre><code># Load template\nflow = NodeFlowWidget()\nflow.load_json(\"data_pipeline_template.json\")\n\n# Customize and use\nflow.set_node_values(\"loader\", {\"file_path\": \"my_data.csv\"})\n</code></pre>"},{"location":"guides/import-export/#sharing-workflows","title":"Sharing Workflows","text":""},{"location":"guides/import-export/#export-for-sharing","title":"Export for Sharing","text":"<pre><code># Export with descriptive name\nflow.export_json(\"ml_training_pipeline.json\")\n\n# Share the JSON file\n# Users can load it with:\n# flow.load_json(\"ml_training_pipeline.json\")\n</code></pre>"},{"location":"guides/import-export/#version-control","title":"Version Control","text":"<pre><code># Export with version in filename\nversion = \"v1.2\"\nflow.export_json(f\"workflow_{version}.json\")\n\n# Commit to git\n# git add workflow_v1.2.json\n# git commit -m \"Update workflow to v1.2\"\n</code></pre>"},{"location":"guides/import-export/#documentation","title":"Documentation","text":"<p>Include README with workflow:</p> <pre><code># Export workflow\nflow.export_json(\"workflow.json\")\n\n# Create README\nreadme = \"\"\"\n# Data Processing Workflow\n\n## Description\nThis workflow processes CSV data and generates visualizations.\n\n## Nodes\n- Data Loader: Load CSV from file\n- Processor: Clean and transform data\n- Visualizer: Generate charts\n\n## Usage\n1. Load workflow: `flow.load_json(\"workflow.json\")`\n2. Set input file: `flow.set_node_values(\"loader\", {\"file_path\": \"data.csv\"})`\n3. Run pipeline\n\n## Requirements\n- pandas\n- matplotlib\n\"\"\"\n\nwith open(\"workflow_README.md\", \"w\") as f:\n    f.write(readme)\n</code></pre>"},{"location":"guides/import-export/#real-world-examples","title":"Real-World Examples","text":""},{"location":"guides/import-export/#save-progress","title":"Save Progress","text":"<p>Auto-save during long workflow:</p> <pre><code>import time\n\nflow = NodeFlowWidget()\n\n# Build complex workflow\nfor i in range(10):\n    # Add nodes, configure...\n\n    # Auto-save every step\n    flow.export_json(f\"workflow_backup_{i}.json\")\n\n    time.sleep(1)\n\n# Final save\nflow.export_json(\"workflow_final.json\")\n</code></pre>"},{"location":"guides/import-export/#workflow-variants","title":"Workflow Variants","text":"<p>Create multiple configurations:</p> <pre><code># Base workflow\nflow = NodeFlowWidget()\n# ... configure ...\nflow.export_json(\"base_workflow.json\")\n\n# High-performance variant\nflow.set_node_values(\"processor\", {\"workers\": 16, \"batch_size\": 1000})\nflow.export_json(\"workflow_high_perf.json\")\n\n# Low-memory variant\nflow.set_node_values(\"processor\", {\"workers\": 2, \"batch_size\": 100})\nflow.export_json(\"workflow_low_mem.json\")\n</code></pre>"},{"location":"guides/import-export/#migration","title":"Migration","text":"<p>Update saved workflows:</p> <pre><code>import json\n\n# Load old workflow\nwith open(\"old_workflow.json\", \"r\") as f:\n    data = json.load(f)\n\n# Update node types\nfor node in data[\"nodes\"]:\n    if node[\"type\"] == \"old_processor\":\n        node[\"type\"] = \"new_processor\"\n        # Migrate values\n        if \"data\" in node and \"values\" in node[\"data\"]:\n            values = node[\"data\"][\"values\"]\n            # Update field names\n            if \"threads\" in values:\n                values[\"workers\"] = values.pop(\"threads\")\n\n# Save migrated workflow\nwith open(\"migrated_workflow.json\", \"w\") as f:\n    json.dump(data, f, indent=2)\n\nprint(\"\u2713 Workflow migrated\")\n</code></pre>"},{"location":"guides/import-export/#batch-processing","title":"Batch Processing","text":"<p>Process multiple workflows:</p> <pre><code>import os\n\nworkflows = [\n    \"workflow1.json\",\n    \"workflow2.json\",\n    \"workflow3.json\"\n]\n\nresults = []\n\nfor workflow_file in workflows:\n    flow = NodeFlowWidget()\n    flow.load_json(workflow_file)\n\n    # Process\n    result = process_workflow(flow)\n    results.append(result)\n\n    # Export results\n    flow.export_json(f\"processed_{workflow_file}\")\n\nprint(f\"\u2713 Processed {len(workflows)} workflows\")\n</code></pre>"},{"location":"guides/import-export/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/import-export/#selective-export","title":"Selective Export","text":"<p>Export only specific components:</p> <pre><code>import json\n\n# Export only nodes\nwith open(\"nodes_only.json\", \"w\") as f:\n    json.dump({\"nodes\": flow.nodes}, f, indent=2)\n\n# Export only connections\nwith open(\"edges_only.json\", \"w\") as f:\n    json.dump({\"edges\": flow.edges}, f, indent=2)\n\n# Export configuration only\nwith open(\"config_only.json\", \"w\") as f:\n    json.dump({\"node_templates\": flow.node_templates}, f, indent=2)\n</code></pre>"},{"location":"guides/import-export/#merge-workflows","title":"Merge Workflows","text":"<p>Combine multiple workflows:</p> <pre><code>import json\n\n# Load workflow A\nwith open(\"workflow_a.json\", \"r\") as f:\n    workflow_a = json.load(f)\n\n# Load workflow B\nwith open(\"workflow_b.json\", \"r\") as f:\n    workflow_b = json.load(f)\n\n# Merge nodes and edges\nmerged = {\n    \"nodes\": workflow_a[\"nodes\"] + workflow_b[\"nodes\"],\n    \"edges\": workflow_a[\"edges\"] + workflow_b[\"edges\"],\n    \"viewport\": {\"x\": 0, \"y\": 0, \"zoom\": 1},\n    \"node_templates\": workflow_a.get(\"node_templates\", [])\n}\n\n# Avoid ID conflicts\n# (Production code should rename IDs)\n\n# Save merged\nwith open(\"workflow_merged.json\", \"w\") as f:\n    json.dump(merged, f, indent=2)\n</code></pre>"},{"location":"guides/import-export/#extract-subgraph","title":"Extract Subgraph","text":"<p>Export portion of workflow:</p> <pre><code>import json\n\n# Load full workflow\nflow = NodeFlowWidget()\nflow.load_json(\"full_workflow.json\")\n\n# Select nodes to extract\nselected_ids = [\"node-1\", \"node-2\", \"node-3\"]\n\n# Extract nodes\nselected_nodes = [n for n in flow.nodes if n[\"id\"] in selected_ids]\n\n# Extract relevant edges\nselected_edges = [\n    e for e in flow.edges\n    if e[\"source\"] in selected_ids and e[\"target\"] in selected_ids\n]\n\n# Create subgraph\nsubgraph = {\n    \"nodes\": selected_nodes,\n    \"edges\": selected_edges,\n    \"viewport\": {\"x\": 0, \"y\": 0, \"zoom\": 1}\n}\n\n# Save\nwith open(\"subgraph.json\", \"w\") as f:\n    json.dump(subgraph, f, indent=2)\n</code></pre>"},{"location":"guides/import-export/#html-export-static-visualization","title":"HTML Export (Static Visualization)","text":"<p>Export workflows as standalone HTML files for visualization without Python or Jupyter. Perfect for:</p> <ul> <li>Documentation: Include interactive DAG visualizations in reports</li> <li>Sharing: Send workflow visualizations to non-technical stakeholders</li> <li>Publishing: Embed on websites or wikis</li> <li>Presentations: Show workflow architecture in presentations</li> </ul>"},{"location":"guides/import-export/#basic-html-export","title":"Basic HTML Export","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\n# Build workflow...\n# ...\n\n# Export as interactive HTML\nflow.export_html(\"workflow.html\")\n# \u2713 HTML exported to workflow.html\n\n# Open in any web browser - no Python required!\n</code></pre>"},{"location":"guides/import-export/#interactive-vs-static","title":"Interactive vs Static","text":"<p>Interactive Mode (default): Users can pan, zoom, and interact with the visualization.</p> <pre><code># Interactive: users can pan, zoom, select nodes\nflow.export_html(\n    \"workflow_interactive.html\",\n    interactive=True  # Default\n)\n</code></pre> <p>Static Mode: View-only visualization, no interaction.</p> <pre><code># Static: view-only, no interaction\nflow.export_html(\n    \"workflow_static.html\",\n    interactive=False\n)\n</code></pre>"},{"location":"guides/import-export/#customization-options","title":"Customization Options","text":""},{"location":"guides/import-export/#custom-title","title":"Custom Title","text":"<pre><code>flow.export_html(\n    \"data_pipeline.html\",\n    title=\"Data Processing Pipeline v2.0\"\n)\n</code></pre>"},{"location":"guides/import-export/#custom-height","title":"Custom Height","text":"<pre><code># Fixed height\nflow.export_html(\n    \"workflow.html\",\n    height=\"800px\"\n)\n\n# Full viewport height\nflow.export_html(\n    \"workflow.html\",\n    height=\"100vh\"\n)\n</code></pre>"},{"location":"guides/import-export/#asset-embedding","title":"Asset Embedding","text":"<p>Embedded Assets (default): All JavaScript and CSS inline in single file.</p> <pre><code># Single self-contained HTML file\nflow.export_html(\n    \"workflow.html\",\n    embed_assets=True  # Default\n)\n</code></pre> <p>Separate Assets: JavaScript and CSS in separate files.</p> <pre><code># Creates: workflow.html, standalone.iife.js, standalone.css\nflow.export_html(\n    \"workflow.html\",\n    embed_assets=False\n)\n</code></pre>"},{"location":"guides/import-export/#complete-example","title":"Complete Example","text":"<pre><code>from pynodewidget import NodeFlowWidget\n\n# Create workflow\nflow = NodeFlowWidget()\n\n# Add node types\nflow.add_node_type_from_schema(\n    json_schema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"input\": {\"type\": \"string\", \"default\": \"data.csv\"}\n        }\n    },\n    type_name=\"data_source\",\n    label=\"Data Source\",\n    icon=\"\ud83d\udcc2\"\n)\n\nflow.add_node_type_from_schema(\n    json_schema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"operation\": {\n                \"type\": \"string\",\n                \"enum\": [\"filter\", \"transform\", \"aggregate\"]\n            }\n        }\n    },\n    type_name=\"processor\",\n    label=\"Processor\",\n    icon=\"\u2699\ufe0f\"\n)\n\n# Add nodes\nflow.nodes = {\n    \"source-1\": {\n        \"type\": \"data_source\",\n        \"position\": {\"x\": 100, \"y\": 100},\n        \"data\": {}\n    },\n    \"processor-1\": {\n        \"type\": \"processor\",\n        \"position\": {\"x\": 400, \"y\": 100},\n        \"data\": {}\n    }\n}\n\n# Add edge\nflow.edges = [{\n    \"id\": \"e1\",\n    \"source\": \"source-1\",\n    \"target\": \"processor-1\"\n}]\n\n# Export multiple formats\nflow.export_html(\n    \"pipeline_interactive.html\",\n    title=\"Interactive Pipeline\",\n    interactive=True\n)\n\nflow.export_html(\n    \"pipeline_static.html\",\n    title=\"Static Pipeline View\",\n    interactive=False\n)\n\nflow.export_html(\n    \"pipeline_fullscreen.html\",\n    title=\"Fullscreen Pipeline\",\n    height=\"100vh\"\n)\n</code></pre>"},{"location":"guides/import-export/#use-cases","title":"Use Cases","text":""},{"location":"guides/import-export/#documentation_1","title":"Documentation","text":"<pre><code># Export workflow for technical documentation\nflow.export_html(\n    \"architecture/data_pipeline.html\",\n    title=\"Data Pipeline Architecture\",\n    height=\"800px\",\n    interactive=True\n)\n</code></pre>"},{"location":"guides/import-export/#presentations","title":"Presentations","text":"<pre><code># Full-screen view for presentations\nflow.export_html(\n    \"presentation/workflow_demo.html\",\n    title=\"Workflow Demo\",\n    height=\"100vh\",\n    interactive=True  # Allow zoom during presentation\n)\n</code></pre>"},{"location":"guides/import-export/#reports","title":"Reports","text":"<pre><code># Static view for PDF conversion\nflow.export_html(\n    \"report/workflow_snapshot.html\",\n    title=\"Workflow Snapshot - 2024-12-16\",\n    interactive=False  # Static for consistent screenshots\n)\n</code></pre>"},{"location":"guides/import-export/#generic-export-method","title":"Generic Export Method","text":"<p>The <code>export()</code> method auto-detects format from file extension:</p> <pre><code># Auto-detects HTML format\nflow.export(\"workflow.html\")  # \u2192 calls export_html()\n\n# Auto-detects JSON format\nflow.export(\"workflow.json\")  # \u2192 calls export_json()\n\n# Explicit format\nflow.export(\"workflow.xyz\", format=\"html\")\n</code></pre>"},{"location":"guides/import-export/#browser-compatibility","title":"Browser Compatibility","text":"<p>HTML exports work in all modern browsers:</p> <ul> <li>\u2705 Chrome/Edge (Chromium)</li> <li>\u2705 Firefox</li> <li>\u2705 Safari</li> <li>\u2705 Mobile browsers (iOS Safari, Chrome Mobile)</li> </ul> <p>Requirements: JavaScript must be enabled (standard for all modern browsers).</p>"},{"location":"guides/import-export/#file-size","title":"File Size","text":"Mode Typical Size Interactive (embedded) ~900KB - 1.5MB Interactive (separate) ~10KB HTML + ~900KB JS Static (embedded) ~900KB - 1.5MB <p>Size includes React, ReactFlow, and all dependencies bundled as single file. ```</p>"},{"location":"guides/import-export/#best-practices","title":"Best Practices","text":"<ul> <li>Version filenames: Include version or date in filename</li> <li>Validate before export: Check workflow is valid</li> <li>Include metadata: Add creation date, author, version info</li> <li>Error handling: Use try/except for safe export/import</li> <li>Backup before load: Export current state before loading new workflow</li> </ul>"},{"location":"guides/import-export/#troubleshooting","title":"Troubleshooting","text":"<p>File not found: Check file path and current directory.</p> <p>Invalid JSON: Validate JSON syntax before loading.</p> <p>Missing node templates: Register all node types before loading workflow.</p> <p>Large files: Check file size and confirm before loading very large workflows.</p>"},{"location":"guides/import-export/#next-steps","title":"Next Steps","text":"<ul> <li>Working with Values: Manage node values in workflows</li> <li>Creating Custom Nodes: Build exportable node types</li> <li>NodeFlowWidget API: Full widget API</li> </ul>"},{"location":"guides/styling/","title":"Styling Nodes","text":"<p>Customize node appearance with headers, footers, colors, and layouts.</p>"},{"location":"guides/styling/#overview","title":"Overview","text":"<p>PyNodeWidget provides multiple ways to style nodes:</p> <ol> <li>Class attributes: Set styling properties directly on node classes</li> <li>Node builder helpers: Use <code>with_*</code> functions for common styling patterns</li> <li>Tailwind CSS classes: Apply utility classes for fine-grained control</li> <li>Custom headers/footers: Add branded or informative sections</li> </ol>"},{"location":"guides/styling/#basic-styling-with-class-attributes","title":"Basic Styling with Class Attributes","text":""},{"location":"guides/styling/#icons","title":"Icons","text":"<p>Add visual identifiers with emojis or Lucide icon names:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass DataLoader(JsonSchemaNodeWidget):\n    label = \"Data Loader\"\n    parameters = LoaderParams\n    icon = \"\ud83d\udcc1\"  # Emoji\n\nclass ImageProcessor(JsonSchemaNodeWidget):\n    label = \"Image Processor\"\n    parameters = ProcessorParams\n    icon = \"image\"  # Lucide icon name\n</code></pre> <p>Popular Lucide icons: - <code>\"database\"</code> - Database operations - <code>\"cpu\"</code> - Processing - <code>\"bar-chart\"</code> - Visualization - <code>\"file-text\"</code> - Text/documents - <code>\"filter\"</code> - Filtering - <code>\"git-merge\"</code> - Merging/combining - <code>\"upload\"</code> - Input/upload - <code>\"download\"</code> - Output/download</p> <p>See Lucide Icons for full list.</p>"},{"location":"guides/styling/#colors","title":"Colors","text":"<p>Set node color with Tailwind color names:</p> <pre><code>class InputNode(JsonSchemaNodeWidget):\n    label = \"Input\"\n    parameters = InputParams\n    color = \"blue\"  # Blue theme\n\nclass ProcessingNode(JsonSchemaNodeWidget):\n    label = \"Processing\"\n    parameters = ProcessorParams\n    color = \"green\"  # Green theme\n\nclass ErrorNode(JsonSchemaNodeWidget):\n    label = \"Error Handler\"\n    parameters = ErrorParams\n    color = \"red\"  # Red theme\n</code></pre> <p>Available colors: - <code>\"gray\"</code> - Neutral (default) - <code>\"blue\"</code> - Information - <code>\"green\"</code> - Success/processing - <code>\"yellow\"</code> - Warning - <code>\"red\"</code> - Error/danger - <code>\"purple\"</code> - Special/advanced - <code>\"pink\"</code> - Visualization - <code>\"indigo\"</code> - Data</p>"},{"location":"guides/styling/#layout-types","title":"Layout Types","text":"<p>Control field arrangement:</p> <pre><code>class HorizontalNode(JsonSchemaNodeWidget):\n    label = \"Horizontal\"\n    parameters = Params\n    layout_type = \"horizontal\"  # Fields in rows\n\nclass VerticalNode(JsonSchemaNodeWidget):\n    label = \"Vertical\"  \n    parameters = Params\n    layout_type = \"vertical\"  # Fields in columns (more compact)\n</code></pre> <p>When to use: - <code>\"horizontal\"</code>: Wide forms with labels on left, inputs on right - <code>\"vertical\"</code>: Narrow nodes with stacked fields (default)</p>"},{"location":"guides/styling/#custom-headers","title":"Custom Headers","text":""},{"location":"guides/styling/#enable-custom-headers","title":"Enable Custom Headers","text":"<pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass BrandedNode(JsonSchemaNodeWidget):\n    label = \"Branded Node\"\n    parameters = Params\n\n    # Enable custom header\n    use_custom_header = True\n    header_class = \"bg-gradient-to-r from-blue-500 to-purple-500 text-white p-2 rounded-t\"\n</code></pre>"},{"location":"guides/styling/#header-styling-classes","title":"Header Styling Classes","text":"<p>Use Tailwind utilities:</p> <pre><code># Gradient background\nheader_class = \"bg-gradient-to-r from-blue-500 to-purple-600 text-white\"\n\n# Solid color with shadow\nheader_class = \"bg-indigo-600 text-white shadow-lg\"\n\n# Pattern background\nheader_class = \"bg-gray-800 text-gray-100 border-b-4 border-blue-500\"\n\n# Custom padding and rounded corners\nheader_class = \"bg-blue-600 text-white p-3 rounded-t-lg\"\n</code></pre>"},{"location":"guides/styling/#render-custom-header-content","title":"Render Custom Header Content","text":"<p>Override <code>render_custom_header()</code> for dynamic content:</p> <pre><code>class StatusNode(JsonSchemaNodeWidget):\n    label = \"Status Monitor\"\n    parameters = StatusParams\n    use_custom_header = True\n    header_class = \"bg-gray-800 text-white p-2\"\n\n    @classmethod\n    def render_custom_header(cls, field_values: dict) -&gt; str:\n        \"\"\"Generate HTML for custom header.\"\"\"\n        status = field_values.get(\"status\", \"idle\")\n        color = {\n            \"idle\": \"gray\",\n            \"running\": \"green\",\n            \"error\": \"red\"\n        }.get(status, \"gray\")\n\n        return f'''\n        &lt;div class=\"flex items-center justify-between\"&gt;\n            &lt;span class=\"font-bold\"&gt;{cls.label}&lt;/span&gt;\n            &lt;span class=\"px-2 py-1 bg-{color}-500 rounded text-xs\"&gt;\n                {status.upper()}\n            &lt;/span&gt;\n        &lt;/div&gt;\n        '''\n</code></pre>"},{"location":"guides/styling/#custom-footers","title":"Custom Footers","text":""},{"location":"guides/styling/#enable-custom-footers","title":"Enable Custom Footers","text":"<pre><code>class InfoNode(JsonSchemaNodeWidget):\n    label = \"Info Node\"\n    parameters = Params\n\n    # Enable custom footer\n    use_custom_footer = True\n    footer_class = \"bg-gray-100 p-2 text-sm text-gray-600 rounded-b\"\n</code></pre>"},{"location":"guides/styling/#footer-styling-classes","title":"Footer Styling Classes","text":"<pre><code># Info footer\nfooter_class = \"bg-blue-50 border-t border-blue-200 p-2 text-xs text-blue-700\"\n\n# Warning footer\nfooter_class = \"bg-yellow-50 border-t border-yellow-200 p-2 text-xs text-yellow-700\"\n\n# Success footer\nfooter_class = \"bg-green-50 border-t border-green-200 p-2 text-xs text-green-700\"\n</code></pre>"},{"location":"guides/styling/#render-custom-footer-content","title":"Render Custom Footer Content","text":"<pre><code>class StatsNode(JsonSchemaNodeWidget):\n    label = \"Statistics\"\n    parameters = StatsParams\n    use_custom_footer = True\n    footer_class = \"bg-gray-50 border-t p-2 text-xs\"\n\n    @classmethod\n    def render_custom_footer(cls, field_values: dict) -&gt; str:\n        \"\"\"Show statistics in footer.\"\"\"\n        sample_size = field_values.get(\"sample_size\", 0)\n        confidence = field_values.get(\"confidence\", 0.95)\n\n        return f'''\n        &lt;div class=\"flex justify-between text-gray-600\"&gt;\n            &lt;span&gt;Samples: {sample_size}&lt;/span&gt;\n            &lt;span&gt;Confidence: {confidence*100:.0f}%&lt;/span&gt;\n        &lt;/div&gt;\n        '''\n</code></pre>"},{"location":"guides/styling/#body-styling","title":"Body Styling","text":"<p>Customize the main content area:</p> <pre><code>class CustomBodyNode(JsonSchemaNodeWidget):\n    label = \"Custom Body\"\n    parameters = Params\n\n    # Style the body (where fields appear)\n    body_class = \"bg-gray-50 p-4 space-y-3\"\n</code></pre> <p>Common body classes:</p> <pre><code># Light background\nbody_class = \"bg-gray-50 p-3\"\n\n# Dark background\nbody_class = \"bg-gray-800 text-white p-3\"\n\n# Tight spacing\nbody_class = \"p-2 space-y-1\"\n\n# Loose spacing\nbody_class = \"p-4 space-y-4\"\n\n# Bordered sections\nbody_class = \"border-2 border-gray-300 p-3\"\n</code></pre>"},{"location":"guides/styling/#error-styling","title":"Error Styling","text":""},{"location":"guides/styling/#shadow-on-error","title":"Shadow on Error","text":"<p>Add visual feedback for validation errors:</p> <pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass ValidatedNode(JsonSchemaNodeWidget):\n    label = \"Validated\"\n    parameters = ValidatedParams\n\n    # Shadow size when errors occur\n    shadow_on_error = \"xl\"  # \"sm\", \"md\", \"lg\", \"xl\", or \"none\"\n</code></pre> <p>Shadow sizes: - <code>\"sm\"</code>: Subtle red shadow - <code>\"md\"</code>: Medium red shadow (default) - <code>\"lg\"</code>: Large red shadow - <code>\"xl\"</code>: Extra large red shadow (very noticeable) - <code>\"none\"</code>: No shadow on error</p>"},{"location":"guides/styling/#error-position","title":"Error Position","text":"<p>Control where validation errors appear:</p> <pre><code>class ErrorNode(JsonSchemaNodeWidget):\n    label = \"Error Display\"\n    parameters = ErrorParams\n\n    # Error message position\n    errors_at = \"bottom\"  # \"inline\", \"top\", \"bottom\"\n</code></pre> <p>Error positions: - <code>\"inline\"</code>: Show errors next to each field (default) - <code>\"top\"</code>: Collect errors at top of node - <code>\"bottom\"</code>: Collect errors at bottom of node</p>"},{"location":"guides/styling/#node-builder-helpers","title":"Node Builder Helpers","text":"<p>Use helper functions for common styling patterns:</p>"},{"location":"guides/styling/#with_custom_header","title":"with_custom_header","text":"<p>Add a custom header with colors:</p> <pre><code>from pynodeflow.node_builder import create_minimal_node, with_custom_header\n\nconfig = create_minimal_node(\n    type_name=\"styled\",\n    label=\"Styled Node\",\n    fields={\"value\": \"number\"}\n)\n\n# Add custom header\nconfig = with_custom_header(\n    config,\n    bg_color=\"#4F46E5\",  # Indigo\n    text_color=\"#FFFFFF\",\n    class_name=\"font-bold text-lg\"\n)\n</code></pre>"},{"location":"guides/styling/#with_footer","title":"with_footer","text":"<p>Add a footer section:</p> <pre><code>from pynodeflow.node_builder import with_footer\n\nconfig = with_footer(\n    config,\n    content=\"\u2139\ufe0f This node processes data\",\n    bg_color=\"#F3F4F6\",  # Light gray\n    text_color=\"#374151\"\n)\n</code></pre>"},{"location":"guides/styling/#with_style","title":"with_style","text":"<p>Apply custom styles:</p> <pre><code>from pynodeflow.node_builder import with_style\n\nconfig = with_style(\n    config,\n    min_width=\"250px\",\n    max_width=\"400px\",\n    shadow=\"lg\",\n    border_color=\"#3B82F6\",  # Blue\n    border_width=\"2px\"\n)\n</code></pre> <p>Style options: - <code>min_width</code>: Minimum node width - <code>max_width</code>: Maximum node width - <code>shadow</code>: Shadow size (<code>\"sm\"</code>, <code>\"md\"</code>, <code>\"lg\"</code>, <code>\"xl\"</code>, <code>\"none\"</code>) - <code>border_color</code>: Border color (CSS color) - <code>border_width</code>: Border width (CSS size) - <code>border_radius</code>: Corner rounding (CSS size)</p>"},{"location":"guides/styling/#complete-styling-examples","title":"Complete Styling Examples","text":""},{"location":"guides/styling/#branded-input-node","title":"Branded Input Node","text":"<pre><code>class BrandedInputNode(JsonSchemaNodeWidget):\n    label = \"Data Input\"\n    parameters = InputParams\n    icon = \"download\"\n    color = \"blue\"\n\n    use_custom_header = True\n    header_class = \"bg-gradient-to-r from-blue-600 to-cyan-500 text-white p-3 font-bold\"\n\n    body_class = \"bg-blue-50 p-4 space-y-3\"\n\n    use_custom_footer = True\n    footer_class = \"bg-blue-100 border-t border-blue-300 p-2 text-xs text-blue-700\"\n\n    @classmethod\n    def render_custom_footer(cls, field_values: dict) -&gt; str:\n        source = field_values.get(\"source\", \"unknown\")\n        return f'&lt;div&gt;\ud83d\udce5 Source: {source}&lt;/div&gt;'\n</code></pre>"},{"location":"guides/styling/#status-indicator-node","title":"Status Indicator Node","text":"<pre><code>class StatusNode(JsonSchemaNodeWidget):\n    label = \"Process Status\"\n    parameters = StatusParams\n    icon = \"activity\"\n\n    use_custom_header = True\n    header_class = \"p-2\"\n\n    @classmethod\n    def render_custom_header(cls, field_values: dict) -&gt; str:\n        status = field_values.get(\"status\", \"idle\")\n\n        status_colors = {\n            \"idle\": (\"gray\", \"\u23f8\ufe0f\"),\n            \"running\": (\"green\", \"\u25b6\ufe0f\"),\n            \"error\": (\"red\", \"\u274c\"),\n            \"complete\": (\"blue\", \"\u2705\")\n        }\n\n        color, emoji = status_colors.get(status, (\"gray\", \"\u23f8\ufe0f\"))\n\n        return f'''\n        &lt;div class=\"bg-{color}-600 text-white p-2 rounded-t flex items-center justify-between\"&gt;\n            &lt;span class=\"font-bold\"&gt;{cls.label}&lt;/span&gt;\n            &lt;span class=\"text-xl\"&gt;{emoji}&lt;/span&gt;\n        &lt;/div&gt;\n        '''\n</code></pre>"},{"location":"guides/styling/#warning-node","title":"Warning Node","text":"<pre><code>class WarningNode(JsonSchemaNodeWidget):\n    label = \"Warning\"\n    parameters = WarningParams\n    icon = \"alert-triangle\"\n    color = \"yellow\"\n\n    use_custom_header = True\n    header_class = \"bg-yellow-500 text-black p-2 font-bold\"\n\n    body_class = \"bg-yellow-50 border-l-4 border-yellow-500 p-3\"\n\n    shadow_on_error = \"xl\"\n\n    use_custom_footer = True\n    footer_class = \"bg-yellow-100 p-2 text-xs text-yellow-800\"\n\n    @classmethod\n    def render_custom_footer(cls, field_values: dict) -&gt; str:\n        return '&lt;div&gt;\u26a0\ufe0f Review settings carefully before proceeding&lt;/div&gt;'\n</code></pre>"},{"location":"guides/styling/#compact-processing-node","title":"Compact Processing Node","text":"<pre><code>class CompactProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n    icon = \"cpu\"\n    color = \"green\"\n    layout_type = \"vertical\"\n\n    body_class = \"p-2 space-y-2 text-sm\"\n\n    shadow_on_error = \"md\"\n</code></pre>"},{"location":"guides/styling/#data-visualization-node","title":"Data Visualization Node","text":"<pre><code>class ChartNode(JsonSchemaNodeWidget):\n    label = \"Chart\"\n    parameters = ChartParams\n    icon = \"bar-chart\"\n    color = \"purple\"\n\n    use_custom_header = True\n    header_class = \"bg-gradient-to-r from-purple-600 to-pink-500 text-white p-2\"\n\n    body_class = \"bg-purple-50 p-3\"\n\n    use_custom_footer = True\n    footer_class = \"bg-purple-100 border-t border-purple-300 p-2\"\n\n    @classmethod\n    def render_custom_header(cls, field_values: dict) -&gt; str:\n        chart_type = field_values.get(\"chart_type\", \"bar\")\n        return f'''\n        &lt;div class=\"flex items-center space-x-2\"&gt;\n            &lt;span&gt;\ud83d\udcca&lt;/span&gt;\n            &lt;span class=\"font-bold\"&gt;{chart_type.title()} Chart&lt;/span&gt;\n        &lt;/div&gt;\n        '''\n\n    @classmethod\n    def render_custom_footer(cls, field_values: dict) -&gt; str:\n        title = field_values.get(\"title\", \"Untitled\")\n        return f'&lt;div class=\"text-xs text-purple-700\"&gt;Title: {title}&lt;/div&gt;'\n</code></pre>"},{"location":"guides/styling/#tailwind-css-reference","title":"Tailwind CSS Reference","text":"<p>PyNodeWidget uses Tailwind CSS. Common utilities:</p> <ul> <li>Colors: <code>bg-{color}-{shade}</code>, <code>text-{color}-{shade}</code> (shades 50-950)</li> <li>Spacing: <code>p-{size}</code>, <code>m-{size}</code>, <code>space-y-{size}</code> (sizes 0-64)</li> <li>Layout: <code>flex</code>, <code>grid</code>, <code>items-center</code>, <code>justify-between</code></li> <li>Borders: <code>border</code>, <code>border-{size}</code>, <code>rounded</code>, <code>rounded-{size}</code></li> <li>Shadows: <code>shadow-{sm|md|lg|xl}</code></li> <li>Text: <code>text-{xs|sm|base|lg}</code>, <code>font-{bold|semibold}</code></li> <li>Gradients: <code>bg-gradient-to-{r|b}</code>, <code>from-{color}</code>, <code>to-{color}</code></li> </ul> <p>Full reference: Tailwind CSS Docs</p>"},{"location":"guides/styling/#best-practices","title":"Best Practices","text":"<ul> <li>Consistent colors: Group related nodes with similar colors</li> <li>Meaningful icons: Icons should clarify node purpose  </li> <li>Concise headers: Avoid cluttering with too much info</li> <li>Accessible colors: Ensure sufficient contrast</li> <li>Test error states: Verify error styling is visible</li> </ul>"},{"location":"guides/styling/#troubleshooting","title":"Troubleshooting","text":"<p>Styles not applying: Check Tailwind class spelling.</p> <p>Header/footer not showing: Enable with <code>use_custom_header = True</code> or <code>use_custom_footer = True</code>.</p> <p>Colors not changing: Custom header classes override node-level <code>color</code> attribute.</p> <p>Gradients not working: Use format <code>bg-gradient-to-r from-{color}-{shade} to-{color}-{shade}</code>.</p>"},{"location":"guides/styling/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Custom Nodes: Build custom nodes</li> <li>Conditional Fields: Dynamic field visibility</li> <li>Handles Configuration: Connection point styling</li> </ul>"},{"location":"guides/values/","title":"Working with Values","text":"<p>Read and update node field values from Python with automatic bidirectional sync.</p>"},{"location":"guides/values/#overview","title":"Overview","text":"<p>PyNodeWidget provides bidirectional synchronization between Python and JavaScript using AnyWidget:</p> <ul> <li>UI changes automatically update Python values</li> <li>Python changes automatically update the UI</li> <li>Powered by <code>ObservableDict</code> for automatic sync</li> </ul>"},{"location":"guides/values/#widget-level-value-access","title":"Widget-Level Value Access","text":""},{"location":"guides/values/#reading-node-values","title":"Reading Node Values","text":"<p>Get all values for a node:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\n# Get all values for a node\nvalues = flow.get_node_values(\"processor-1\")\n# Returns: {\"threshold\": 0.5, \"enabled\": True, \"mode\": \"auto\"}\n\n# Access specific value\nthreshold = values.get(\"threshold\", 0.5)\n</code></pre> <p>Get a single value:</p> <pre><code># Get specific value with default\nworkers = flow.get_node_value(\"processor-1\", \"workers\", default=4)\n\n# Equivalent to:\nvalues = flow.get_node_values(\"processor-1\")\nworkers = values.get(\"workers\", 4)\n</code></pre>"},{"location":"guides/values/#setting-node-values","title":"Setting Node Values","text":"<p>Update multiple values:</p> <pre><code># Set multiple values at once\nflow.set_node_values(\"processor-1\", {\n    \"threshold\": 0.8,\n    \"enabled\": False,\n    \"mode\": \"advanced\"\n})\n</code></pre> <p>Update single value:</p> <pre><code># Update one value\nflow.update_node_value(\"processor-1\", \"workers\", 20)\n</code></pre>"},{"location":"guides/values/#checking-node-existence","title":"Checking Node Existence","text":"<pre><code># Check if node has any values\nif \"processor-1\" in flow.node_values:\n    values = flow.node_values[\"processor-1\"]\n</code></pre>"},{"location":"guides/values/#node-level-value-access","title":"Node-Level Value Access","text":"<p>When working with node instances directly:</p>"},{"location":"guides/values/#reading-values","title":"Reading Values","text":"<pre><code>from pynodewidget import JsonSchemaNodeWidget\n\nclass ProcessorNode(JsonSchemaNodeWidget):\n    label = \"Processor\"\n    parameters = ProcessorParams\n\n# Create node instance\nnode = ProcessorNode(threshold=0.5, enabled=True)\n\n# Get all values\nvalues = node.get_values()\n# Returns: {\"threshold\": 0.5, \"enabled\": True, \"mode\": \"auto\"}\n\n# Access specific value\nthreshold = values[\"threshold\"]\n</code></pre>"},{"location":"guides/values/#setting-values","title":"Setting Values","text":"<p>Update multiple values:</p> <pre><code># Set multiple values\nnode.set_values({\n    \"threshold\": 0.8,\n    \"enabled\": False\n})\n\n# Verify update\nprint(node.get_values())\n# {\"threshold\": 0.8, \"enabled\": False, \"mode\": \"auto\"}\n</code></pre> <p>Update single value:</p> <pre><code># Set one value\nnode.set_value(\"workers\", 20)\n\n# Equivalent to:\nnode.set_values({\"workers\": 20})\n</code></pre>"},{"location":"guides/values/#bidirectional-sync","title":"Bidirectional Sync","text":""},{"location":"guides/values/#python-ui","title":"Python \u2192 UI","text":"<p>Changes in Python automatically appear in the UI:</p> <pre><code>flow = NodeFlowWidget()\n\n# User creates a node in the UI with ID \"node-1\"\n# ...\n\n# Update from Python\nflow.update_node_value(\"node-1\", \"threshold\", 0.9)\n\n# UI updates automatically! No refresh needed.\n</code></pre>"},{"location":"guides/values/#ui-python","title":"UI \u2192 Python","text":"<p>Changes in the UI automatically update Python:</p> <pre><code># User changes threshold slider in UI from 0.5 to 0.8\n# ...\n\n# Read updated value in Python\nthreshold = flow.get_node_value(\"node-1\", \"threshold\")\nprint(threshold)  # 0.8 - automatically synced!\n</code></pre>"},{"location":"guides/values/#observing-changes","title":"Observing Changes","text":"<p>Monitor value changes with Traitlets observers:</p> <pre><code>from pynodewidget import NodeFlowWidget\n\nflow = NodeFlowWidget()\n\ndef on_values_change(change):\n    \"\"\"Called when any node value changes.\"\"\"\n    node_id = change[\"name\"]\n    new_values = change[\"new\"]\n    print(f\"Node {node_id} values changed to: {new_values}\")\n\n# Observe all node_values changes\nflow.observe(on_values_change, names=[\"node_values\"])\n</code></pre> <p>Observe specific node:</p> <pre><code>def on_processor_change(change):\n    \"\"\"Monitor specific node.\"\"\"\n    values = change[\"new\"]\n    if \"node-1\" in values:\n        node_values = values[\"node-1\"]\n        print(f\"Processor values: {node_values}\")\n\nflow.observe(on_processor_change, names=[\"node_values\"])\n</code></pre>"},{"location":"guides/values/#nested-values","title":"Nested Values","text":"<p>ObservableDict supports nested dictionaries:</p> <pre><code># Nested configuration\nflow.update_node_value(\"node-1\", \"advanced\", {\n    \"timeout\": 30,\n    \"retries\": 3,\n    \"cache\": {\"enabled\": True, \"ttl\": 3600}\n})\n\n# Update nested value (still syncs!)\nflow.node_values[\"node-1\"][\"advanced\"][\"timeout\"] = 60\n\n# Access nested value\ncache_ttl = flow.node_values[\"node-1\"][\"advanced\"][\"cache\"][\"ttl\"]\n</code></pre>"},{"location":"guides/values/#value-patterns","title":"Value Patterns","text":""},{"location":"guides/values/#default-values","title":"Default Values","text":"<p>Provide defaults when reading:</p> <pre><code># Get with default\nthreshold = flow.get_node_value(\"node-1\", \"threshold\", default=0.5)\n\n# Or use dict.get\nvalues = flow.get_node_values(\"node-1\")\nworkers = values.get(\"workers\", 4)\nmode = values.get(\"mode\", \"auto\")\n</code></pre>"},{"location":"guides/values/#batch-updates","title":"Batch Updates","text":"<p>Update multiple nodes efficiently:</p> <pre><code># Update multiple nodes\nfor node_id in [\"node-1\", \"node-2\", \"node-3\"]:\n    flow.set_node_values(node_id, {\n        \"enabled\": False,\n        \"status\": \"paused\"\n    })\n</code></pre>"},{"location":"guides/values/#conditional-updates","title":"Conditional Updates","text":"<p>Update based on current value:</p> <pre><code># Get current value\ncurrent = flow.get_node_value(\"node-1\", \"count\", 0)\n\n# Increment\nflow.update_node_value(\"node-1\", \"count\", current + 1)\n</code></pre>"},{"location":"guides/values/#reset-to-defaults","title":"Reset to Defaults","text":"<pre><code># Reset node to default values\ndefault_values = node.FieldsModel().model_dump()\nflow.set_node_values(\"node-1\", default_values)\n</code></pre>"},{"location":"guides/values/#real-world-examples","title":"Real-World Examples","text":""},{"location":"guides/values/#progress-tracking","title":"Progress Tracking","text":"<p>Update progress from Python:</p> <pre><code>import time\n\nflow = NodeFlowWidget()\n\n# Simulate long-running process\nfor i in range(100):\n    # Update progress (UI shows immediately)\n    flow.update_node_value(\"processor-1\", \"progress\", i)\n    flow.update_node_value(\"processor-1\", \"status\", \"processing\")\n\n    time.sleep(0.1)\n\n# Mark complete\nflow.update_node_value(\"processor-1\", \"status\", \"complete\")\nflow.update_node_value(\"processor-1\", \"progress\", 100)\n</code></pre>"},{"location":"guides/values/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Adjust based on data:</p> <pre><code># Load data\ndata = load_dataset()\n\n# Auto-configure based on data\nflow.set_node_values(\"loader-1\", {\n    \"rows\": len(data),\n    \"columns\": len(data.columns),\n    \"format\": detect_format(data)\n})\n</code></pre>"},{"location":"guides/values/#validation-feedback","title":"Validation Feedback","text":"<p>Show validation errors:</p> <pre><code>def validate_node(node_id):\n    \"\"\"Validate node configuration.\"\"\"\n    values = flow.get_node_values(node_id)\n\n    threshold = values.get(\"threshold\", 0.5)\n    if threshold &lt; 0 or threshold &gt; 1:\n        flow.update_node_value(node_id, \"error\", \"Threshold must be 0-1\")\n        flow.update_node_value(node_id, \"valid\", False)\n        return False\n\n    flow.update_node_value(node_id, \"error\", \"\")\n    flow.update_node_value(node_id, \"valid\", True)\n    return True\n\n# Validate before processing\nif validate_node(\"processor-1\"):\n    process_data()\n</code></pre>"},{"location":"guides/values/#multi-node-coordination","title":"Multi-Node Coordination","text":"<p>Coordinate multiple nodes:</p> <pre><code># Configure data flow pipeline\nflow.set_node_values(\"loader-1\", {\n    \"file_path\": \"data.csv\",\n    \"status\": \"ready\"\n})\n\nflow.set_node_values(\"processor-1\", {\n    \"input_ready\": True,\n    \"status\": \"waiting\"\n})\n\nflow.set_node_values(\"output-1\", {\n    \"format\": \"json\",\n    \"status\": \"waiting\"\n})\n\n# Start pipeline\nflow.update_node_value(\"loader-1\", \"status\", \"loading\")\ndata = load_data()\n\nflow.update_node_value(\"processor-1\", \"status\", \"processing\")\nresult = process_data(data)\n\nflow.update_node_value(\"output-1\", \"status\", \"saving\")\nsave_result(result)\n\n# Mark all complete\nfor node_id in [\"loader-1\", \"processor-1\", \"output-1\"]:\n    flow.update_node_value(node_id, \"status\", \"complete\")\n</code></pre>"},{"location":"guides/values/#reactive-updates","title":"Reactive Updates","text":"<p>React to user changes:</p> <pre><code>def on_mode_change(change):\n    \"\"\"Adjust settings when mode changes.\"\"\"\n    values = change[\"new\"]\n\n    for node_id, node_values in values.items():\n        mode = node_values.get(\"mode\")\n\n        if mode == \"advanced\":\n            # Enable advanced settings\n            flow.update_node_value(node_id, \"show_debug\", True)\n            flow.update_node_value(node_id, \"log_level\", \"debug\")\n        elif mode == \"simple\":\n            # Disable advanced settings\n            flow.update_node_value(node_id, \"show_debug\", False)\n            flow.update_node_value(node_id, \"log_level\", \"info\")\n\nflow.observe(on_mode_change, names=[\"node_values\"])\n</code></pre>"},{"location":"guides/values/#jupyter-integration","title":"Jupyter Integration","text":""},{"location":"guides/values/#display-current-values","title":"Display Current Values","text":"<pre><code># In a Jupyter cell\nflow = NodeFlowWidget()\n\n# Show node values\nimport json\nprint(json.dumps(flow.node_values, indent=2))\n</code></pre>"},{"location":"guides/values/#interactive-updates","title":"Interactive Updates","text":"<pre><code>from ipywidgets import FloatSlider, VBox\n\n# Create Python widget\nslider = FloatSlider(min=0, max=1, step=0.1, value=0.5)\n\n# Link to node value\ndef on_slider_change(change):\n    flow.update_node_value(\"processor-1\", \"threshold\", change[\"new\"])\n\nslider.observe(on_slider_change, names=[\"value\"])\n\n# Display both\nVBox([slider, flow])\n</code></pre>"},{"location":"guides/values/#computed-values","title":"Computed Values","text":"<pre><code># Cell 1: Create widget\nflow = NodeFlowWidget()\n\n# Cell 2: Compute based on values\ndef compute_stats():\n    values = flow.get_node_values(\"analyzer-1\")\n    sample_size = values.get(\"sample_size\", 100)\n    confidence = values.get(\"confidence\", 0.95)\n\n    # Calculate margin of error\n    margin = 1.96 * (0.5 / (sample_size ** 0.5))\n\n    return {\n        \"sample_size\": sample_size,\n        \"confidence\": confidence,\n        \"margin_of_error\": margin\n    }\n\nstats = compute_stats()\nprint(stats)\n</code></pre>"},{"location":"guides/values/#best-practices","title":"Best Practices","text":"<ul> <li>Descriptive keys: Use clear field names</li> <li>Provide defaults: Always use defaults when reading values</li> <li>Batch updates: Use <code>set_node_values()</code> for multiple changes</li> <li>Type safety: Ensure values match Pydantic model types</li> <li>Validate: Check values before processing</li> </ul>"},{"location":"guides/values/#troubleshooting","title":"Troubleshooting","text":"<p>Values not syncing: Ensure widget is displayed in Jupyter before updates.</p> <p>Nested update not syncing: Use <code>update_node_value()</code> or explicit <code>update()</code> call.</p> <p>Node ID not found: Print <code>list(flow.node_values.keys())</code> to verify node exists.</p> <p>Type errors: Ensure value types match Pydantic model definitions.</p> <p>Observer not triggering: Check observer is registered with correct trait name (<code>\"node_values\"</code>).</p>"},{"location":"guides/values/#next-steps","title":"Next Steps","text":"<ul> <li>Creating Custom Nodes: Build nodes with custom value management</li> <li>NodeFlowWidget API: Full widget API reference</li> <li>Import/Export: Save and load workflows with values</li> </ul>"}]}